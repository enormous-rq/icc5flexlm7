<html><head>
<title>FLEXlm Reference Manual</title>
</head><body>
<title>FLEXlm Reference Manual</title>
<h1>FLEXlm Reference Manual</h1>
<a href="#_IX">Index</a>
<ul>
<li><a href="#Chapter 1">Chapter 1 
Introduction to FLEXlm<I></I></a>
<ul>
<li><a href="#1.1">1.1  About this Manual</a>
<li><a href="#1.2">1.2  How to use this Manual</a>
<li><a href="#1.3">1.3  FLEXlm<I></I> Terms and Definitions</a>
<li><a href="#1.4">1.4  FLEXlm<I></I> APIs</a>
</ul>
<li><a href="#Chapter 2">Chapter 2 
<a name="13483: chap head: Installing the Distribution Kit"></a>Installing the Distribution Kit - <a name="_IX_26"></a>VMS and <a name="_IX_27"></a>Source</a>
<ul>
<li><a href="#2.1">2.1  Binary Installation for VMS Systems</a>
<li><a href="#2.2">2.2  Source Installation</a>
</ul>
<li><a href="#Chapter 3">Chapter 3 
Incorporating FLEXlm<I></I> Into Your Application using the FLEXible API</a>
<ul>
<li><a href="#3.1">3.1  FLEXlm<I></I> Example Applications</a>
<li><a href="#3.2">3.2  Client Heartbeats and License Server Failures</a>
<li><a href="#3.3">3.3  <TT></TT>Internationalization</a>
<li><a href="#3.4">3.4  Lingering Licenses</a>
<li><a href="#3.5">3.5  Multiple Jobs</a>
<li><a href="#3.6">3.6  Security and FLEX<I>lm</I></a>
</ul>
<li><a href="#Chapter 4">Chapter 4 <a name="_IX_57"></a><a name="24121: ChapTitle: Chapter 4 FLEXible API"></a>
FLEXible API</a>
<ul>
<li><a href="#4.1">4.1  FLEXible API Library Routines</a>
<li><a href="#4.2">4.2  Building Your Application</a>
<li><a href="#4.3">4.3  l_new_hostid</a>
<li><a href="#4.4">4.4  <TT></TT>lc_auth_data</a>
<li><a href="#4.5">4.5  lc_check_key</a>
<li><a href="#4.6">4.6  lc_checkin</a>
<li><a href="#4.7">4.7  lc_checkout</a>
<li><a href="#4.8">4.8  lc_chk_conf</a>
<li><a href="#4.9">4.9  lc_convert</a>
<li><a href="#4.10">4.10  lc_cryptstr</a>
<li><a href="#4.11">4.11  lc_err_info</a>
<li><a href="#4.12">4.12  lc_errstring</a>
<li><a href="#4.13">4.13  lc_errtext</a>
<li><a href="#4.14">4.14  lc_expire_days</a>
<li><a href="#4.15">4.15  lc_feat_list</a>
<li><a href="#4.16">4.16  lc_first_job, lc_next_job</a>
<li><a href="#4.17">4.17  lc_free_hostid</a>
<li><a href="#4.18">4.18  lc_free_job</a>
<li><a href="#4.19">4.19  lc_free_mem</a>
<li><a href="#4.20">4.20  lc_get_attr</a>
<li><a href="#4.21">4.21  lc_get_config</a>
<li><a href="#4.22">4.22  lc_heartbeat</a>
<li><a href="#4.23">4.23  lc_hostid</a>
<li><a href="#4.24">4.24  lc_idle</a>
<li><a href="#4.25">4.25  lc_init  -  (license generator only)</a>
<li><a href="#4.26">4.26  lc_log</a>
<li><a href="#4.27">4.27  lc_new_job</a>
<li><a href="#4.28">4.28  lc_next_conf</a>
<li><a href="#4.29">4.29  lc_perror</a>
<li><a href="#4.30">4.30  lc_set_attr</a>
<li><a href="#4.31">4.31  lc_status</a>
<li><a href="#4.32">4.32  lc_userlist</a>
<li><a href="#4.33">4.33  lc_vsend</a>
<li><a href="#4.34">4.34  Rarely used functions</a>
</ul>
<li><a href="#Chapter 5">Chapter 5 
<a name="Controlling Licensing Behavior Of Your Application"></a>Controlling Licensing Behavior Of Your Application With <a name="_IX_285"></a>lc_set_attr</a>
<ul>
<li><a href="#5.1">5.1  LM_A_BEHAVIOR_VER</a>
<li><a href="#5.2">5.2  LM_A_CHECK_BADDATE</a>
<li><a href="#5.3">5.3  LM_A_CHECK_INTERVAL</a>
<li><a href="#5.4">5.4  LM_A_CHECKOUT_DATA</a>
<li><a href="#5.5">5.5  LM_A_CHECKOUTFILTER</a>
<li><a href="#5.6">5.6  LM_A_CKOUT_INSTALL_LIC</a>
<li><a href="#5.7">5.7  LM_A_DISPLAY_OVERRIDE</a>
<li><a href="#5.8">5.8  LM_A_FLEXLOCK</a>
<li><a href="#5.9">5.9  LM_A_FLEXLOCK_INSTALL_ID</a>
<li><a href="#5.10">5.10  LM_A_HOST_OVERRIDE</a>
<li><a href="#5.11">5.11  LM_A_LCM</a>
<li><a href="#5.12">5.12  LM_A_LCM_URL</a>
<li><a href="#5.13">5.13  LM_A_LF_LIST</a>
<li><a href="#5.14">5.14  LM_A_LICENSE_CASE_SENSITIVE</a>
<li><a href="#5.15">5.15  LM_A_LICENSE_DEFAULT</a>
<li><a href="#5.16">5.16  LM_A_LICENSE_FMT_VER</a>
<li><a href="#5.17">5.17  LM_A_LINGER</a>
<li><a href="#5.18">5.18  LM_A_LKEY_LONG</a>
<li><a href="#5.19">5.19  LM_A_LKEY_START_DATE</a>
<li><a href="#5.20">5.20  LM_A_LONG_ERRMSG</a>
<li><a href="#5.21">5.21  LM_A_PERROR_MSGBOX (Windows only)</a>
<li><a href="#5.22">5.22  LM_A_PROMPT_FOR_FILE (Windows only)</a>
<li><a href="#5.23">5.23  LM_A_RETRY_CHECKOUT</a>
<li><a href="#5.24">5.24  <TT></TT>LM_A_RETRY_COUNT, LM_A_RETRY_INTERVAL</a>
<li><a href="#5.25">5.25  LM_A_SETITIMER, LM_A_SIGNAL (Unix only)</a>
<li><a href="#5.26">5.26  <TT></TT>LM_A_TCP_TIMEOUT</a>
<li><a href="#5.27">5.27  <TT></TT>LM_A_UDP_TIMEOUT</a>
<li><a href="#5.28">5.28  LM_A_USER_EXITCALL</a>
<li><a href="#5.29">5.29  LM_A_USER_OVERRIDE</a>
<li><a href="#5.30">5.30  LM_A_USER_RECONNECT</a>
<li><a href="#5.31">5.31  LM_A_USER_RECONNECT_DONE</a>
<li><a href="#5.32">5.32  LM_A_VD_GENERIC_INFO, LM_A_VD_FEATURE_INFO</a>
<li><a href="#5.33">5.33  LM_A_VENDOR_ID_DECLARE</a>
<li><a href="#5.34">5.34  LM_A_VENDOR_GETHOSTID</a>
<li><a href="#5.35">5.35  LM_A_VERSION and LM_A_REVISION</a>
<li><a href="#5.36">5.36  LM_A_WINDOWS_MODULE_HANDLE</a>
</ul>
<li><a href="#Chapter 6">Chapter 6 <a name="45129: ChapTitle: Chapter 9 The License File"></a>
License Models and the License File</a>
<ul>
<li><a href="#6.1">6.1  Demo Licensing</a>
<li><a href="#6.2">6.2  Lenient Licensing: REPORTLOG and OVERDRAFT</a>
<li><a href="#6.3">6.3  Format of the License File</a>
<li><a href="#6.4">6.4  Decimal Format Licenses</a>
<li><a href="#6.5">6.5  Locating the License File</a>
<li><a href="#6.6">6.6  Hostids for FLEXlm<I></I> Supported Machines</a>
<li><a href="#6.7">6.7  Special Hostids</a>
<li><a href="#6.8">6.8  Vendor-defined hostid</a>
<li><a href="#6.9">6.9  Intel Pentium III+ Hostid (HOSTID_INTEL)</a>
<li><a href="#6.10">6.10  <TT></TT>Types of License Files</a>
<li><a href="#6.11">6.11  License Key Length and Start Date</a>
<li><a href="#6.12">6.12  License in a buffer</a>
<li><a href="#6.13">6.13  E-mailing licenses</a>
<li><a href="#6.14">6.14  Order of lines in license file</a>
<li><a href="#6.15">6.15  sort=<I>nnn</I></a>
</ul>
<li><a href="#Chapter 7">Chapter 7 
<a name="_IX_424"></a>lmgrd</a>
<ul>
<li><a href="#7.1">7.1  lmgrd - The License Daemon</a>
</ul>
<li><a href="#Chapter 8">Chapter 8 
<a name="84465: 1head: 4.3 Configuring Your Vendor Daemon"></a>Configuring Your <a name="_IX_437"></a>Vendor Daemon</a>
<ul>
<li><a href="#8.1">8.1  Building Your Vendor Daemon - VMS Systems</a>
<li><a href="#8.2">8.2  Building Your Vendor Daemon - Windows NT Systems</a>
<li><a href="#8.3">8.3  lsvendor.c variables</a>
<li><a href="#8.4">8.4  Vendor Daemon Support Routines</a>
</ul>
<li><a href="#Chapter 9">Chapter 9 <a name="16570: ChapTitle: Chapter 9 Redundant License Servers"></a>
<a name="_IX_481"></a>Redundant License Servers</a>
<ul>
<li><a href="#9.1">9.1  Three-server redundancy</a>
<li><a href="#9.2">9.2  Redundancy via License File List in $LM_LICENSE_FILE</a>
<li><a href="#9.3">9.3  Comparing three-server to License File List</a>
</ul>
<li><a href="#Chapter 10">Chapter 10 
<a name="_IX_488"></a>Debugging Hints</a>
<ul>
<li><a href="#10.1">10.1  Debugging Your Application Code</a>
<li><a href="#10.2">10.2  Solving Problems In The Field</a>
<li><a href="#10.3">10.3  Multiple Vendors Using FLEXlm<I></I> At A Single End-User Site</a>
<li><a href="#10.4">10.4  FLEXlm<I></I> Version Compatibility</a>
</ul>
<li><a href="#Chapter 11">Chapter 11 <TT>
</TT><TT></TT><a name="66148: 1head: 11.5 Communications Transport (TCP vs. UDP)"></a><a name="_IX_499"></a>Communications Transport </a>
<ul>
<li><a href="#11.1">11.1  How to Select UDP Connections</a>
</ul>
<li><a href="#Chapter 12">Chapter 12 
Unix<I></I> and VMS <a name="17446: chap head: Chapter 11"></a>Platform-Specific Notes</a>
<ul>
<li><a href="#12.1">12.1  Data General</a>
<li><a href="#12.2">12.2  Hewlett Packard</a>
<li><a href="#12.3">12.3  IBM</a>
<li><a href="#12.4">12.4  NCR</a>
<li><a href="#12.5">12.5  SGI</a>
<li><a href="#12.6">12.6  SCO</a>
<li><a href="#12.7">12.7  SVR4 Systems</a>
<li><a href="#12.8">12.8  VMS</a>
</ul>
<li><a href="#Chapter 13">Chapter 13 <a name="34811: ChapTitle: Chapter 15 Windows, Win32s, and Windows NT"></a>
<a name="_IX_528"></a>Windows 95/98, and <a name="_IX_529"></a>Windows NT</a>
<ul>
<li><a href="#13.1">13.1  Supported Compilers</a>
<li><a href="#13.2">13.2  lc_new_job() and lc_free_job() Must Be Matched</a>
<li><a href="#13.3">13.3  FLEXlm<I></I> Callback Routines</a>
<li><a href="#13.4">13.4  FLEXlm<I></I> exit() Callback</a>
<li><a href="#13.5">13.5  Default License File</a>
<li><a href="#13.6">13.6  Time Zone Setting</a>
<li><a href="#13.7">13.7  Node Lock and Hostid for Standalone PCs                                   </a>
<li><a href="#13.8">13.8  System Requirements for obtaining Ethernet Address</a>
<li><a href="#13.9">13.9  Quick-Win/ 32 Bit Console Applications</a>
<li><a href="#13.10">13.10  Networking Requirements</a>
<li><a href="#13.11">13.11  Hardware Hostids (Dongles)</a>
<li><a href="#13.12">13.12  Environment Variables (32-bit Platforms)</a>
<li><a href="#13.13">13.13  Special Syntax for Windows Version</a>
<li><a href="#13.14">13.14  Minimum Files Required for Customer Installation</a>
<li><a href="#13.15">13.15  Build Notes</a>
<li><a href="#13.16">13.16  Linking to your Program</a>
<li><a href="#13.17">13.17  If your application is a DLL</a>
<li><a href="#13.18">13.18  Special Operating Conditions</a>
<li><a href="#13.19">13.19  Timers</a>
<li><a href="#13.20">13.20  Ethernet Address for WIN32 Platform</a>
<li><a href="#13.21">13.21  Operation on NEC NT machines</a>
<li><a href="#13.22">13.22  Networking</a>
<li><a href="#13.23">13.23  FLEXlm<I></I> TCP/IP Network Problem</a>
<li><a href="#13.24">13.24  FLEXlm<I></I> Utilities</a>
<li><a href="#13.25">13.25  Servers and Services</a>
<li><a href="#13.26">13.26  Control Panel and Multiple Lmgrd's</a>
<li><a href="#13.27">13.27  WINDOWS 95 Multiple Servers</a>
<li><a href="#13.28">13.28  Default Operation when Server connection is lost</a>
<li><a href="#13.29">13.29  Version Information</a>
<li><a href="#13.30">13.30  Using languages other than `C'</a>
<li><a href="#13.31">13.31  Server Environment Variables</a>
</ul>
<li><a href="#Chapter 14">Chapter 14 
<a name="_IX_542"></a>Netware NLM</a>
<ul>
<li><a href="#14.1">14.1  Introduction and Requirements</a>
<li><a href="#14.2">14.2  Installation</a>
<li><a href="#14.3">14.3  Creating a License File For Netware </a>
<li><a href="#14.4">14.4  Starting the Vendor Daemon on a Netware Server </a>
<li><a href="#14.5">14.5  Preparing the Client System to Use IPX/SPX for FLEXlm<I></I></a>
<li><a href="#14.6">14.6  Accessing License Servers via TCP/IP and SPX/IPX Concurrently </a>
</ul>
<li><a href="#Appendix A ">Appendix A  
<a name="41257: chap head: Distribution Kit Contents"></a><a name="_IX_546"></a>Industry-Standard Licensing APIs</a>
<ul>
<li><a href="#A.1">A.1  The FLEXlm<I></I> FLEXible API</a>
<li><a href="#A.2">A.2  The FLEXlm<I></I> Trivial and Simple APIs</a>
<li><a href="#A.3">A.3  Software License Working Group</a>
<li><a href="#A.4">A.4  LSAPI v1.1</a>
<li><a href="#A.5">A.5  LSAPI General Calls</a>
</ul>
<li><a href="#Appendix B ">Appendix B  
The <a name="_IX_554"></a>Debug <a name="_IX_555"></a><a name="_IX_556"></a>Log File</a>
<ul>
<li><a href="#B.1">B.1  Informational Messages</a>
<li><a href="#B.2">B.2  Configuration Problems</a>
<li><a href="#B.3">B.3  Daemon Software Errors</a>
</ul>
<li><a href="#Appendix C ">Appendix C  
FLEXlm<I></I> Status Return Values</a>
<li><a href="#Appendix D ">Appendix D  
FLEX<I>lm</I> Limits</a>
<ul>
<li><a href="#D.1">D.1  License File Limits</a>
<li><a href="#D.2">D.2  End-User Options File Limits</a>
<li><a href="#D.3">D.3  lc_set_attr() limits</a>
<li><a href="#D.4">D.4  Other API limits</a>
<li><a href="#D.5">D.5  Vendor Daemon Limits</a>
<li><a href="#D.6">D.6  lmgrd</a>
<li><a href="#D.7">D.7  Sub-net, Domains, Wide-Area Networks</a>
<li><a href="#D.8">D.8  LM_LICENSE_FILE</a>
</ul>
<li><a href="#Appendix E ">Appendix E  
<a name="42591: AppTitle: Appendix F Additional lc_set_attr() Attributes"></a>Additional lc_set_attr() Attributes</a>
<ul>
<li><a href="#E.1">E.1  LM_A_ALLOW_SET_TRANSPORT</a>
<li><a href="#E.2">E.2  LM_A_ALT_ENCRYPTION</a>
<li><a href="#E.3">E.3  LM_A_COMM_TRANSPORT</a>
<li><a href="#E.4">E.4  LM_A_CONN_TIMEOUT</a>
<li><a href="#E.5">E.5  LM_A_CRYPT_CASE_SENSITIVE</a>
<li><a href="#E.6">E.6  LM_A_DIAGS_ENABLED</a>
<li><a href="#E.7">E.7  LM_A_DISABLE_ENV</a>
<li><a href="#E.8">E.8  LM_A_EF_1, LM_A_EF_2, LM_A_EF_3, LM_A_EF_4, LM_A_EF_5</a>
<li><a href="#E.9">E.9  LM_A_ETHERNET_BOARDS</a>
<li><a href="#E.10">E.10  LM_A_LICENSE_FILE and LM_A_LICENSE_FILE_PTR</a>
<li><a href="#E.11">E.11  LM_A_MAX_TIMEDIFF</a>
<li><a href="#E.12">E.12  LM_A_NO_TRAFFIC_ENCRYPT</a>
<li><a href="#E.13">E.13  LM_A_PERIODIC_CALL</a>
<li><a href="#E.14">E.14  LM_A_PERIODIC_COUNT</a>
<li><a href="#E.15">E.15  LM_A_USE_START_DATE</a>
<li><a href="#E.16">E.16  LM_A_USER_CRYPT</a>
</ul>
<a href="#_IX">Index</a>
</ul>
<a name="Chapter 1"></a><hr><h1>Chapter 1 
Introduction to FLEXlm<I></I></h1>
<a name="1.1"></a><h2>1.1  About this Manual</h2>
<p>
This manual, the 
FLEXlm<I></I>` Reference Manual, provides a comprehensive description 
of all aspects of 
FLEXlm<I></I> from the software developer's perspective including a 
complete description of the 
<a name="_IX_5"></a>FLEX<I>ible</I> API, the most complete API available for 
license management.<p>
<p>
The 
FLEXlm Programmers Guide<I></I> provides an introduction to 
FLEXlm<I></I>, descriptions 
of the 
<a name="_IX_6"></a>Trivial and<a name="_IX_7"></a> Simple APIs, descriptions of the license administration tools which 
are bundled with 
FLEXlm<I></I>, and guidelines for integration of 
FLEXlm<I></I> into your 
application.<p>
<p>
The 
FLEXlm End-User Manual<I></I> contains information relevant to users of products that 
utilize 
FLEXlm<I></I> as their licensing system. This manual describes setup and 
administration of a 
FLEXlm<I></I> licensing system.<p>
<a name="1.2"></a><h2>1.2  How to use this Manual</h2>
<p>
This manual should be used as a reference to the advanced features of 
FLEXlm<I></I>. It 
should also be used if you plan to use the FLEXible API in your application.<p>
<a name="1.3"></a><h2>1.3  FLEXlm<I></I> Terms and Definitions</h2>
<p>
The following terms are used as defined to describe 
FLEXlm<I></I> concepts and software 
components.<p>
<dl><a name="_IX_8"></a><dt>feature<dd>Any functionality that needs to be licensed. The meaning of 
a feature will depend entirely on the way that an application 
developer uses it. For example, a feature could represent 
any of the following:</dl><ul><li>An application software system consisting of hundreds 
of programs.<li>A single program (regardless of version).<li>A specific version of a program.<li>A part of a program.<li>A piece of data (restricted via the access routines).</ul><dl><a name="_IX_9"></a><dt>license<dd>The legal right to use a feature. 
FLEXlm<I></I> can restrict 
licenses for features by counting the number of licenses 
already in use for a feature when new requests are made by 
the application software (client). 
FLEXlm<I></I> can also restrict 
usage of software to particular nodes or user names.<a name="_IX_10"></a><dt>client<dd>An application program requesting or receiving a license.<a name="_IX_11"></a><dt>daemon<dd>A process that `serves' clients. Sometimes referred to as a 
<I>server</I>.<a name="_IX_12"></a><dt>vendor daemon<dd>The 
<a name="_IX_13"></a>daemon that dispenses licenses for the requested 
features. This daemon is built by an application's vendor 
(from libraries supplied by 
GLOBEtrotter Software<I></I>) and 
contains the vendor's unique encryption seeds.<a name="_IX_14"></a><dt>lmgrd<dd>The 
<a name="_IX_15"></a>daemon process, or license daemon, that sends client 
processes to the correct vendor daemon on the correct 
machine. The same license daemon process can be used by 
all applications from all vendors, as this daemon neither 
authenticates nor dispenses licenses.<a name="_IX_16"></a><dt>server node<dd>A computer system that is running the license server 
software. The 
<a name="_IX_17"></a>server node will contain all the site-specific 
information regarding the usage of all the features. 
Multiple 
<a name="_IX_18"></a>server nodes used for redundancy can logically be 
considered the<I> server node</I>.<a name="_IX_19"></a><dt>license file<dd>A site-specific file that contains descriptions of the server 
node(s) that can run the license daemons, the various 
vendor daemons, and the licenses (features) for all 
supported products. 
<a name="_IX_20"></a><dt>license file list<dd>A list of license files can be accepted in most places where 
a license file is appropriate. The list is separated with a 
colon ':' on Unix, a semi-colon ';' on Windows and a space 
on VMS. When a directory is specified, all files matching 
<I>*.lic</I> in that directory are automatically used, as if specified 
as a list.<a name="_IX_21"></a><dt>license key<dd> A 12- to 20-character hexadecimal number which 
`authenticates' the readable license file text, ensuring that 
the license text has not been modified. 
<a name="_IX_22"></a><dt>license server<dd>The lmgrd and vendor daemon processes. License server 
refers to the processes, not the computer.</dl><a name="1.4"></a><h2>1.4  FLEXlm<I></I> APIs</h2>
<p>
The application program interfaces to 
FLEXlm<I></I> via a set of routines that request 
(checkout) and release (checkin) licenses of selected feature(s). 
<p>
<p>
There are 4 APIs available to the developer: 
<p>
<ul><li><a name="_IX_23"></a>Trivial API<li><a name="_IX_24"></a>Simple API<li><a name="_IX_25"></a>FLEX<I>ible</I> API<li>Java API</ul><p>
Most of the important functionality and flexibility in 
FLEXlm<I></I> is contained in the 
license file; all license file attributes are available to all APIs.<p>
<p>
You should use the Trivial or Simple APIs when you can. The Simple and FLEXible 
APIs should only be used when the Trivial API is not feasible. The Simple and Trivial 
APIs (as well as the JAVA API) are documented in the 
FLEXlm Programmers Guide<I></I>, 
while the FLEXible API is documented in detail in this manual. Following are 
guidelines for which API to use:<p>
<p>
The Simple API must be used instead of the Trivial API when<p>
<ul><li>A single process needs to separately license sub-functionality - that is, when 2 or 
more feature names may be checked out.<li>The checkout call needs to be able to checkout more than 1 license of a feature.</ul><p>
Most commonly, the FLEXible API is required for<p>
<ul><li>Asynchronous queuing, especially in X or Windows-based applications where 
queueing is required.<li>To obtain a list of users of a given feature.<li>Vendor-defined hostid.</ul><p>
If your application requires the FLEXible API 
<I>only</I> for a list of users, you can 
concurrently use the Simple or Trivial API for licensing, and the FLEXible API only 
for a list of users - this is the recommended solution for this problem.<p>
<p>
In the Trivial and Simple APIs, a licensing `policy' is selected as an argument to the 
license request call. In these APIs a `heartbeat' function is usually called explicitly by 
the application, and policy upon server failure must be programmed into the 
application.<p>
<a name="Chapter 2"></a><hr><h1>Chapter 2 
<a name="13483: chap head: Installing the Distribution Kit"></a>Installing the Distribution Kit - <a name="_IX_26"></a>VMS and <a name="_IX_27"></a>Source</h1>
<p><hr>
Note:	For Unix and Windows installation, please refer to the 
FLEXlm<I></I> Programmers Guide 
where this topic is covered in full.<hr><p>
<p>
FLEXlm<I></I> is available via ftp from 
<TT>ftp://ftp.globes.com/flexlm/current</TT>.<p>
<a name="2.1"></a><h2>2.1  Binary Installation for VMS Systems</h2>
<p>
A 
FLEXlm<I></I> binary distribution kit consists of a single directory which contains all the 
libraries, include files, and programs. To install 
FLEXlm<I></I>, you will create a directory 
for the kit, read the distribution media, then run the 
FLEXlm<I></I> installation program.<p>
<h3>2.1.1	 Installation via 
Unix<I></I></h3>
<p>
FLEXlm<I></I>VMS kits are downloaded to 
Unix<I></I> systems from the ftp site. Use 
install_flexlm.ftp to unpack the files. After running install_flexlm.ftp, copy the 
resultant ascii file, along with the file `mftu.com' to your VMS system, using your 
normal networking commands. execute the following commands (substitute 
<TT>alpha_v1</TT> 
for 
<TT>vax_v5</TT> if you are extracting an alpha/openvms kit):<p>
<pre>	$ create/dir [.mftu]</pre>
<pre>	$ copy mftu.com [.mftu]</pre>
<pre>	$ set def [.mftu]</pre>
<pre>	$ @mftu</pre>
<pre>	$ @mftumake</pre>
<pre>	$! In the next command, <I>disk:[dir.mftu</I>] refers to your default</pre>
<pre>	$ mftu :== $disk:[dir.mftu]mftu	</pre>
<pre>	$ set def [-]</pre>
<pre>	$ rename vax_v5 vax_v5.mftu</pre>
<pre>	$ mftu</pre>
<pre>	MFTU&gt; decode vax_v5.mftu</pre>
<pre>	$ backup vax_v5.bck/save [...]</pre>
<a name="2.2"></a><h2>2.2  Source Installation</h2>
<p>
A 
FLEXlm<I></I> source distribution kit consists of a single directory which contains 
subdirectories for the client library, include files, and both license and vendor daemons. 
The 
<a name="_IX_28"></a>BINARY_KIT script will produce a binary kit identical to the binary distribution 
in the subdirectory<TT> 
</TT><I>arch_os</I>. 
<I>arch</I> is the machine architecture and 
<I>os</I> is the operating 
system version, as specified in the BINARY_KIT command. For example, 
<I>arch</I> could 
be one of sun4, hp700, vax, apollo, etc., and 
<I>os</I> could be u4 (for SunOS4). To install 
the source kit, you will create a directory to hold it, read the distribution media, then 
perform the build, which will result in a binary kit for the target platform.<p>
<p>
Source is available upon request by an email request to support@globes.com. After 
installing the source files, create the binary kit<p>
<pre>	% cd flexlm</pre>
<pre>	% v6.1/BINARY_KIT v6.1 <I>arch_os</I></pre>
</ol></ul><p>
It is important to use the correct 
<I>arch_os</I> value when running BINARY_KIT, since the 
BINARY_KIT script may change make parameters depending on the machine 
architecture. 
<p>
<p>
The 
<TT>gplatargs</TT> script in the 
<TT>utils</TT> directory is used to determine architecture specific 
flags. 
<TT>gplatform</TT> in the 
<TT>utils</TT> directory is also used to determine 
<I>arch_os</I>. Both gplatform 
and gplatargs may require modification for new platforms.<p>
<a name="Chapter 3"></a><hr><h1>Chapter 3 
Incorporating FLEXlm<I></I> Into Your Application using the FLEXible API</h1>
<p>
To incorporate 
FLEXlm<I></I> into your application, you will add function calls to your 
application program, build your application, and build a custom vendor daemon as 
discussed in the following sections.<p>
<a name="3.1"></a><h2>3.1  FLEXlm<I></I> Example Applications</h2>
<p>
The 
FLEXlm<I></I> distribution kit contains an example 
<a name="_IX_29"></a>FLEXible API client application 
program in the machind directory called 
<TT><a name="_IX_30"></a>lmflex.c.</TT> 
<TT><a name="_IX_31"></a>lmclient.c</TT> is a small stand-alone 
<a name="_IX_32"></a>Trivial API licensed program and is a good place to start to learn how to integrate 
FLEXlm<I></I> with your application. A 
<a name="_IX_33"></a>Simple API example program is also available in 
<TT><a name="_IX_34"></a>lmsimple.c</TT>. The source to these programs is in the 
<TT>machind</TT> directory.<p>
<p>
Windows and 
Windows NT systems contain a second example application which uses 
Microsoft Visual C++ to build a slightly more complicated example program to 
demonstrate the usage of UDP and other more advanced options.<p>
<p>
The 
<TT>lmcrypt</TT> and 
<TT>makekey</TT> programs can be used to generate licenses for your 
customers, or they can be used as examples of license generation programs. Source to 
the 
<TT>makekey</TT> and 
<TT>lmcrypt</TT> programs is in the machind directory.<p>
<p>
The 
<TT>lmcrypt</TT> and 
<TT>makekey</TT> programs generate the same license keys on all 
FLEXlm<I></I> 
supported platforms for all 
FLEXlm<I></I> versions, thus allowing you to create licenses for 
any supported platform on any other supported platform.<p>
<p>
FLEXlm<I></I> kits also contain an 
<TT>examples</TT> directory at the top-level of the kit hierarchy. 
The 
<TT><a name="_IX_35"></a>examples</TT> directory contains example programs, which have been put on the kit in 
order to illustrate how to perform various operations with 
FLEXlm<I></I>. These programs 
are 
<B>not supported</B>, and 
GLOBEtrotter Software<I></I> may not include them in future 
FLEXlm<I></I> releases.<p>
<a name="_IX_36"></a><a name="3.2"></a><h2>3.2  Client Heartbeats and License Server Failures</h2>
<p>
Your application will need to communicate regularly with the server via `heartbeats', 
to ensure the server is still running. How the heartbeats occur and what action takes 
place when the server is not running are the most important part of incorporating 
FLEXlm<I></I> in an application. Heartbeats for Trivial and Simple APIs are discussed in the 
FLEXlm Programmers Guide<I></I>. The FLEXible API heartbeat is addressed in the 
following sections:<p>
<ul><li><a href="#21737: 1Head: 4.22 lc_heartbeat">Section 4.22, `lc_heartbeat,' on page 46</a><li><a href="#53814: 2head: 5.1.3 LM_A_CHECK_INTERVAL, LM_A_TIMER_TYPE">Section 5.3, `LM_A_CHECK_INTERVAL,' on page 73</a><li><a href="#25274: 2head: 5.1.27 LM_A_RETRY_COUNT, LM_A_RETRY_INTERVAL">Section 5.24, `LM_A_RETRY_COUNT, LM_A_RETRY_INTERVAL,' on 
page 80</a><li><a href="#26627: 2head: 5.1.34 LM_A_USER_EXITCALL">Section 5.28, `LM_A_USER_EXITCALL,' on page 82</a><li><a href="#32158: 2head: 5.1.36 LM_A_USER_RECONNECT">Section 5.30, `LM_A_USER_RECONNECT,' on page 83</a><li><a href="#10195: 2head: 5.1.37 LM_A_USER_RECONNECT_DONE">Section 5.31, `LM_A_USER_RECONNECT_DONE,' on page 83</a></ul><a name="3.3"></a><h2>3.3  <TT></TT>Internationalization</h2>
<p>
A message file for localization of 
FLEXlm<I></I> messages has been provided for Solaris 2.<I>x</I>. 
The message file is 
<TT><a name="_IX_37"></a>FLEXlm</TT><I></I><TT>.po, 
</TT>and it is contained in the machind directory. The text 
domain is `FLEXlm<I></I>'. All messages from 
<a name="_IX_38"></a><TT>lmgrd</TT>, the 
<a name="_IX_39"></a>vendor daemons, and 
<a name="_IX_40"></a><TT>lmutil</TT> are 
contained in this message file. Since the client library does not output any messages, 
and the 
<TT>lmcrypt, makekey</TT> and 
<TT>lmfeats</TT> programs are example programs for the ISV's 
use only (which are shipped in source form, anyway), these have not been 
internationalized. All 
FLEXlm<I></I> client library messages are contained in the file 
<TT>machind/<a name="_IX_41"></a>lmerrors.h</TT>. In order to build a localized version of the daemons and utilities, 
do the following:<p>
<ol><li>Edit 
<TT>FLEXlm.po</TT> to contain the text translations.<li>Run 
<TT>msgfmt</TT> on 
<TT>FLEXlm.po</TT> (produces 
<TT>FLEXlm.mo</TT>).<li>Put 
<TT>FLEXlm.mo</TT> into the appropriate message directory. For example, if you were 
doing a french translation:<pre>	% cp FLEXlm.mo /usr/lib/locale/fr/LC_MESSAGES</pre>
<li>Set your language environment:<pre>	% setenv <a name="_IX_42"></a>LANG fr</pre>
<li>Run 
<TT>lmgrd</TT> or the utility program. You should see the translated messages.</ol>
<a name="_IX_43"></a><a name="_IX_44"></a><a name="35324: 1Head: 3.5 Lingering Licenses"></a><a name="3.4"></a><h2>3.4  Lingering Licenses</h2>
<p>
A lingering license allows you to specify how long a license will remained checked out 
beyond either an 
<a name="_IX_45"></a>lc_checkin() call or program exit (whichever comes first). To use this 
feature, call 
<a name="_IX_46"></a>lc_set_attr() before checking out the feature that should linger:<p>
<pre>lc_new_job	lc_set_attr(job, <a name="_IX_47"></a>LM_A_LINGER, <I>x</I>)</pre>
</ol></ul><p>
<p>
<dl><dt>(long) 
<I>x</I> 
<dd>number of seconds to make the license linger.</dl><p>
In addition, the end-user can specify a longer linger interval in his daemon options file, 
as such:<p>
<pre>	LINGER <I>f1</I> 100</pre>
</ol></ul><p>
The longer of the developer-specified and user-specified times will be used. The actual 
time of checkin will vary somewhat since the vendor daemon checks all lingering 
licenses once per minute. If however, a new license request is made that would 
otherwise be denied, a check of the lingering licenses is made immediately to attempt 
to satisfy the new request. Linger is useful for programs that normally take under a 
minute to complete. Linger is generally only useful if 
<a name="_IX_48"></a>DUP_GROUP is also set.<p>
<h4>See also</h4>
<ul><li><a href="#51599: 2head: 5.1.20 LM_A_LINGER">Section 5.16, `LM_A_LICENSE_FMT_VER,' on page 78</a><li><a href="#92354: 1head: 4.5 Vendor daemon support routines">Section 8.4, `Vendor Daemon Support Routines,' on page 135</a><li><a href="#79592: 2head: 9.1.3 FEATURE or INCREMENT Line">Section 6.3.4, `FEATURE or INCREMENT Line,' on page 96</a></ul><a name="_IX_49"></a><a name="_IX_50"></a><a name="38172: 1Head: 3.7 Multiple Jobs"></a><a name="3.5"></a><h2>3.5  Multiple Jobs</h2>
<p>
<I><a name="_IX_51"></a>lc_new_job(job, 0, y, &amp;job_handle)</I> function calls enable applications to support more 
than one 
FLEXlm<I></I> job in a single binary. Each job has a separate connection to a license 
server, as well as a independent set of job attributes. When a new job is created with 
lc_new_job(), all the 
FLEXlm<I></I> attributes are set to defaults, and attributes can be set 
completely independently for this new job. For example, one job could use TCP and 
another job UDP, running simultaneously, although this is not necessarily a good 
reason for multiple jobs.<p>
<p>
Multiple jobs may be desirable for the following reasons:<p>
<ul><li>If 
<TT>$<a name="_IX_52"></a>LM_LICENSE_FILE</TT> is a license file list (colon-separated on Unix, semicolon 
separated on 
Windows or 
Windows NT or a space separated list on 
VMS 
platforms) with more than one server supporting features for the client, and if the 
application needs to check out more than one feature, it may be necessary to 
communicate with two servers to check out the necessary licenses. This can only 
be done with multiple jobs, since a separate connection is required for each 
server.<li>It may be convenient to have a single process manage licenses for other 
processes. It is usually convenient to manage each process's license as a separate 
job.<li>lc_checkin() checks in all licenses for a given name. If the application needs to 
check-in only some of the licenses, this can be done with multiple jobs, where 
groups of checkouts are done in separate jobs, and checked in separately from 
each job.</ul><p>
The first item can be important as an alternative way of supporting server redundancy. 
Following is a program excerpt that illustrates how to support this:<p>
<pre>	LM_HANDLE *job1 = 0, *job2 = 0;
	VENDORCODE code;
	if (lc_new_job((LM_HANDLE *)0, 0, &amp;code, &amp;job1))
		/* error processing */ ;
	set_all_my_attr(job1); /* do all necessary lc_set_attr() calls */
	if (lc_checkout(job1, "f1", "1.0", 1, LM_CO_NOWAIT, &amp;code, 
								LM_DUP_NONE))
		/* error processing */ ;
	/*	We checkout out one feature successfully, so we're  
	 *	connected to a server already. In order to connect to
	 *	another server, we would need another job
	 */
	if (lc_checkout(job1, "f2", "1.0", 1, LM_CO_NOWAIT, &amp;code, 
								LM_DUP_NONE))
	{
		if (lc_new_job(job1, 0, &amp;code, &amp;job2))
		{
			/* error processing */
			job2 = 0;
		}
		else
		{
			set_all_my_attr(job2);	/* Reset attributes */
			if (lc_checkout(job2, "f2", "1.0", 1, 
					LM_CO_NOWAIT, &amp;code, LM_DUP_NONE))
				 /* error processing */ ;
		}
	}
	/* application code here */
	lc_checkin(job1, LM_CI_ALL_FEATURES, 0);
	lc_free_job(job1);
	if (job2 &amp;&amp; job2 != job1)
	{
		lc_checkin(job2, LM_CI_ALL_FEATURES, 0);
		lc_free_job(job2);
	}</pre>
</ol></ul><p>
	If the application is managing many jobs, you may want to free jobs with 
lc_free_job() 
to save memory. When doing so, make sure that you do not delete a job which still has 
a license checked out - this can result in a core dump. 
<p>
<p>
Jobs can be found and managed using 
lc_first_job() and 
lc_next_job(), which are used 
to walk the list of jobs. Attributes for jobs are set and retrieved with 
lc_set_attr() and 
<a name="_IX_53"></a>lc_get_attr().<p>
<h4>See also</h4>
<ul><li><a href="#75729: 2head: 3.3.15 lc_get_attr">Section 4.18, `lc_free_job,' on page 43</a><li><a href="#83986: 2head: 3.3.18 lc_get_attr">Section 4.20, `lc_get_attr,' on page 44</a><li><a href="#19115: 1Head: 4.27 lc_new_job">Section 4.27, `lc_new_job,' on page 50</a><li><a href="#15999: 2head: 3.3.14 lc_first_job, lc_next_job">Section 4.16, `lc_first_job, lc_next_job,' on page 42</a><li><a href="#43831: 2head: 3.3.30 lc_set_attr">Section 4.30, `lc_set_attr,' on page 53</a></ul><a name="3.6"></a><h2>3.6  Security and FLEX<I>lm</I></h2>
<h3>3.6.1	 Keeping your software secure</h3>
<p>
No software is completely 
<a name="_IX_54"></a>secure. 
FLEXlm<I></I> is no exception. While 
GLOBEtrotter Software<I></I> has made every effort to ensure the integrity of 
FLEXlm<I></I>, all points of attack 
can never be anticipated. Globetrotter Software also maintains a list of techniques for 
making your implementation more secure. These techniques are recommended only 
for companies with the most stringent security requirements, and are not necessary for 
most companies. Please contact technical support (support@globes.com) for a 
description of these techniques. (For security reasons, they are only available to 
supported companies by email.)<p>
<h3>3.6.2	 <a name="_IX_55"></a>lmstrip - Security and Licensing Libraries</h3>
<p>
lmstrip and the source, lmstrip.c, is included in the 
FLEXlm<I></I> kits. lmstrip has 3 related, 
but different, uses:<p>
<ul><li>Adds security to applications (Unix only)<li>Additional security for licensing libraries.<li>Allows 2 companies to use 2 different 
FLEXlm<I></I> versions in the same binary.</ul><p>
The usage for lmstrip is:<p>
<dl><dt>lmstrip 
<I>file</I> [ -l ] [ -e | -n ] [ -r ] [-m] [-mapfile 
<I>filename</I>] [ 
<I>strings</I>... ]<dt>-l<dd>List internal and external names to be stripped<dt>-e<dd>Don't strip external names<dt>-n<dd>Don't strip internal and external names<dt>-r<dd>Replaces strings with random printable characters<dt>-m<dd>Create or use mapfile. Default mapfile name is 
`lmstrip.map.' Forces randomized names to be the same 
across invocations. Required for Windows. Optional for 
Unix.<dt>-mapfile 
<I>filename</I><dd>Override default mapfile name to 
<I>filename</I><dt><I>strings</I><dd>Strip these strings from the executable</dl><p>
Use -e if 
<I>lc_xxx</I> calls are made from shared library back into your code. Use -r if you 
are linking 2 versions of 
FLEXlm<I></I> into the same binary.<p>
<p>
By default, 
<TT>lmstrip</TT> replaces all 
FLEXlm<I></I> function names with null characters. This adds 
security to fully-linked binaries.<p>
<p>
If you're running lmstrip on an object file, using the 
<I>-r</I> argument replaces the function 
names with random characters, truncated to no more than 6 characters long per name.<p>
<h3>3.6.3	 lmstrip Adds Security to Binaries (Unix only)</h3>
<p>
When run on a dynamically-linked binary, lmstrip adds more security than the normal 
Unix strip command, since these binaries retain references to the function calls in case 
they're called from a shared library. 
<TT>lmstrip</TT> removes any such references.<p>
<p>
For this reason 
<TT>lmstrip</TT> cannot be used as-is on a binary when any 
<I>lc_xxx</I> call is made 
from a shared library (which is very rare). Should this apply to you, use 
<TT>lmstrip -e</TT>, 
which leaves the 
<I>lc_xxx</I> calls, but still strips the 
<I>l_xxx</I> calls; this is about the same level 
of security anyway, since the most important functions, from a security viewpoint, are 
the 
<I>l_xxx</I> calls.<p>
<p>
Since symbol names don't occur in fully linked Windows binaries, this is not needed 
on Windows.<p>
<h3>3.6.4	 <a name="24593: 2Head: 3.6.2 Licensing libraries with FLEXlm"></a>Licensing libraries with 
FLEXlm<I></I></h3>
<a name="_IX_56"></a><h4>Unix</h4>
<p>
We recommend the following steps:<p>
<ul><li>ld -r file.o liblmgr.a -o ofile.o
ofile.o then includes all necessary 
FLEXlm<I></I> calls.<li>lmstrip -r ofile.o
This randomizes the names of the 
FLEXlm<I></I> function calls.</ul><p>
You then ship ofile.o to your customers, knowing that they will not see a function 
called lc_checkout(), etc., in the resulting object file.<p>
<h4>Windows</h4>
<pre>Usage:</pre>
<pre>C:&gt; copy lmgr.lib <I>mylmgr</I>.lib
C:&gt; lmstrip -r -m <I>mylmgr</I>.lib
C:&gt; lib <I>mylmgr</I>.lib
C:&gt; lmstrip -r -m myfuncs.lib
C:&gt; lib myfuncs.lib
Where <I>mylmgr</I>.lib is renamed to be unique for your company.</pre>
</ol></ul><p>
With -m, lmstrip creates a `mapfile' which contains a lookup table of randomized 
symbol names which is reused later for other object or library files, ensuring the names 
are mapped identically. For example, `lc_checkout' may be renamed to `xLfH3C'. If 
this happens in 2 separate object files, the renaming must be identical.<p>
<p>
You can now safely ship 
<I>mylmgr</I>.lib and myfuncs.lib to your customers. When your 
customer links their object with myfuncs.lib and mylmgr.lib, everything is resolved 
and functions correctly. And the temptation to alter the libraries and/or functions is 
reduced since the function names are not meaningful nor deducible.<p>
<h3>3.6.5	 Linking with a library that already uses 
FLEXlm<I></I></h3>
<h4>Unix</h4>
<p>
Follow the steps in 
<a href="#24593: 2Head: 3.6.2 Licensing libraries with FLEXlm">Section 3.6.4, `Licensing libraries with 
FLEXlm'</a> (Unix above), 
using ld -r and lmstrip -r. The resulting object file can be linked with a library that 
already calls 
FLEXlm<I></I>, along with a previous 
FLEXlm<I></I> library version. Both coexist 
successfully.<p>
<h4>Windows</h4>
<h4>Follow the steps in 
<a href="#24593: 2Head: 3.6.2 Licensing libraries with FLEXlm">Section 3.6.4, `Licensing libraries with 
FLEXlm'</a> (Windows, 
above), using lmstrip -r -m. 
<I>mylmgr</I>.lib won't conflict with other companies' use of 
FLEXlm, since the symbol names are altered.</h4>
<a name="Chapter 4"></a><hr><h1>Chapter 4 <a name="_IX_57"></a><a name="24121: ChapTitle: Chapter 4 FLEXible API"></a>
FLEXible API</h1>
<p>
This is the most powerful API available for license management. As such, it contains 
quite a bit of complexity. It is essentially unchanged from 
FLEXlm<I></I> v4.0. Where 
possible, new applications should use the Simple or Trivial APIs; however, there is no 
reason to change applications which use the FLEXible API.<p>
<p>
Some functionality is only available in this API. Also, the C interface to license 
generation is 
<I>lc_cryptstr()</I>, which is only available in the FLEXible API.<p>
<a name="4.1"></a><h2>4.1  FLEXible API Library Routines</h2>
<p>
The application program is linked with the 
FLEXlm<I></I> client library. The routines to 
manage licenses are all contained in the 
FLEXlm<I></I> client library 
liblmgr.a (<TT>lmgr.lib 
</TT>for 
Windows NT). The following are the most commonly used routines, however the only 
required routines are 
<I>lc_new_job</I> and 
<I>lc_checkout</I> and the 
<I>LM_CODE() 
</I>macro:<p>
<dl><dt>lc_auth_data<dd>
<table border>

<tr><td align=left><p>
<TT></TT><p>
<td align=left><p>
<TT></TT><p>

</table>
Gets the license file line for a checked-out feature.<dt>lc_checkin<dd>Returns a license of a feature to the license pool.<dt>lc_checkout<dd>Requests a license of a feature.<dt>lc_err_info<dd>Useful for translating error messages.<dt>lc_errstring<dd>Returns an explanatory error string for the most recent 
error.<dt>lc_free_job<dd>Frees a job allocated with lc_new_job.<dt>lc_get_attr<dd>Retrieves a 
FLEXlm<I></I> client attribute.<dt>lc_get_config<dd>Gets the first occurrence of the FEATURE line in the 
cached license file.<dt>lc_heartbeat<dd>Sends heartbeat from client to server.<dt>lc_hostid<dd>Gets system hostid.<dt>lc_idle<dd>Supports Administrator defined TIMEOUT option via 
options.dat files.<dt>lc_init<dd>Used in place of lc_new_job in license generators (like 
lmcrypt and makekey).<dt>lc_new_job<dd>Initializes 
FLEXlm<I></I>, and creates a license job.<dt>lc_perror<dd>Prints an error message to stderr.<dt>lc_set_attr<dd>Sets a 
FLEXlm<I></I> client attribute.<dt>lc_userlist<dd>Gets a list of the users of a feature.</dl><p>
Following is a list of rarely used routines, which mostly exist for historical reasons. It 
is rare that an application will require these functions, and care should be used when 
calling them: 
<I>lc_baddate, lc_ck_feats, lc_crypt, lc_disconn, lc_display, lc_feat_set, 
lc_get_errno, lc_get_feats, lc_gethostid, lc_getid_type, lc_hostname, lc_hosttype, 
lc_isadmin, lc_lic_where, lc_master_list, lc_remove, lc_set_errno, lc_shutdown, 
lc_startup, lc_timer, lc_username</I>. These are documented separately at the end of these 
chapter.<p>
<p>
The include file 
<TT>lmclient.h</TT> contains all the symbolic definitions required for most calls. 
<I>lm_code.h</I> contains the vendor's encryption seeds and 
FLEXlm<I></I> vendor key values. 
<I>lm_attr.h</I> contains the definitions used in the 
lc_set_attr() and 
lc_get_attr() calls.<p>
<a name="4.2"></a><h2>4.2  Building Your Application</h2>
<p>
If you use any of the 
FLEXlm<I></I> symbolic definitions, macros, or data structures, you 
must include 
<TT><a name="_IX_58"></a>lmclient.h 
</TT>and 
<TT>lm_code.h</TT> in your C module. 
<a name="_IX_59"></a>lc_set_attr() calls require 
you to include 
<TT>lm_attr.h</TT>. Your encryption seeds, 
FLEXlm<I></I> vendor keys and vendor 
name are in<TT> lm_code.h</TT>.<p>
<p>
In order to build your application:<p>
<ol><li>Insert the calls that you require into your code.<p>
Link your code with the 
FLEXlm<I></I> library 
<I><a name="_IX_60"></a></I>liblmgr.a (or 
lmgr327b.lib on 
Windows NT 
systems, or 
<I>lmgr.olb</I> on VMS). If you have loaded the distribution kit into 
<TT>/usr/license/</TT> 
then, on Unix, use a command of the following form:<p>
<pre><TT>	% cc -o program program.o $(OBJS) -L/usr/license/lmgr/arch_os -llmgr</TT></pre>
</ol></ul><p>
where 
<TT>$(OBJS)</TT> is the list of the objects for your program. You can put -llmgr anywhere 
after your objects, and before 
<I>-lsocket</I> and 
<I>-lintl</I>, if needed on your system. See how 
<TT>lmclient</TT> is linked in the makefile in the binary kit for your platform for a correct 
example.<p>
<p>
On Unix, it is strongly recommended that your application be linked dynamically. That 
is, avoid -BSTATIC or linking directly with libc.a or other system libraries. Here's 
why:<p>
<ul><li>On many Unix systems, NIS and DNS will fail unless applications are linked with 
shared system libraries.<li>Many important system fixes are implemented by shipping new shared libraries 
to end-users. By linking with static libraries, users often don't obtain essential 
fixes to applications unless the application is re-linked.</ul><a name="11229: 1Head: 4.3 l_new_hostid"></a><a name="_IX_61"></a><a name="4.3"></a><h2>4.3  l_new_hostid</h2>
<h4>Syntax</h4>
<p>
hostid= l_new_hostid()<p>
<h4>Description</h4>
<p>
Returns a malloc'd and zeroed hostid. Use 
<I><a name="_IX_62"></a>lc_free_hostid()</I> to free this memory. This 
may be needed when doing vendor-defined hostids.<p>
<h4>Parameters</h4>
<p>
none.<p>
<h4>Return</h4>
<dl><dt>(HOSTID *) config<dd>A HOSTID struct, or null.</dl><h4>Error Returns</h4>
<dl><dt>LM_CANTMALLOC<dd>malloc call failed.</dl><h4>See also</h4>
<ul><li><a href="#37404: 1Head: 6.38 LM_A_VENDOR_ID_DECLARE">Section 5.33, `LM_A_VENDOR_ID_DECLARE,' on page 86</a><li><a href="#66223: 1head: 9.5 Vendor-defined hostid">Section 6.8, `Vendor-defined hostid,' on page 115</a></ul><a name="60631: 2head: 3.3.2 lc_auth_data"></a><a name="_IX_63"></a><a name="4.4"></a><h2>4.4  <TT></TT>lc_auth_data</h2>
<h4>Syntax</h4>
<pre>config = lc_auth_data(job, feature)</pre>
<h4>Description</h4>
<p>
Gets the license file line for a feature that has been checked out. Since lc_auth_data() 
only returns features which have been successfully checked out, the data returned is 
authenticated.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I> 
<dd>from lc_new_job<dt>(char *) 
<I>feature</I> 
<dd>The desired feature.</dl><h4>Return</h4>
<dl><dt>(<a name="_IX_64"></a>CONFIG *) 
<I>config</I><dd><dd>The config structure, or NULL if error. The config structure 
is defined in the header file 
<TT>lmclient.h</TT>.</dl><h4>Error Returns</h4>
<dl><dt>LM_FUNCNOTAVAIL<dd>Vendor keys do not support this function.<a name="_IX_65"></a><dt>LM_NOFEATURE<dd>Feature not found.</dl><p><hr>
Note:	If you call 
lc_checkout() with the 
<a name="_IX_66"></a>LM_CO_LOCALTEST flag, then use the alternate 
function 
lc_test_conf() to retrieve the license file line for the tested feature. This can 
only be done after the most recent call to 
lc_checkout(). 
lc_test_conf() takes a job 
handle parameter and returns a (struct CONFIG *).<hr><p>
<h4>See also</h4>
<ul><li><a href="#63009: 2head: 3.3.16 lc_get_config">Section 4.21, `lc_get_config,' on page 45</a><li><TT>lmclient.h</TT> for the CONFIG struct definition.</ul><a name="_IX_67"></a><a name="33504: 1Head: 4.6 lc_check_key"></a><a name="4.5"></a><h2>4.5  lc_check_key</h2>
<h4>Syntax</h4>
<pre>status = lc_check_key(job, conf, code)</pre>
<h4>Description</h4>
<p>
lc_check_key determines if the 
<a name="_IX_68"></a>license key in the CONFIG is valid. To verify a license 
file upon installation, you could use code similar to the following example:<p>
<pre>	feats = lc_feat_list(..)
	while (*feats)
	{
		pos = 0;
		while (conf = lc_next_conf(job, *feats, &amp;pos))
		}
			if (lc_check_key(job, conf, &amp;code))
				/*error*/
		}
		feats++;
	}</pre>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(CONFIG *) 
<I>conf</I><dd>From 
<I>lc_next_conf()</I>, 
<I>lc_get_config()</I>.<dt>(VENDORCODE *) 
<I>code</I><dd>From LM_CODE macro.</dl><h4>Return</h4>
<dl><dt>(int) 
<I>status</I><dd>FLEXlm<I></I> error code, or 0 for no error.</dl><h4>Error Returns</h4>
<dl><a name="_IX_69"></a><dt>LM_BADCODE<dd>license-key is invalid - License has been typed incorrectly, 
or altered in some way.<a name="_IX_70"></a><dt>LM_BADPARAM<dd>Problem with 
<I>conf</I> argument.<a name="_IX_71"></a><dt>LM_FUTURE_FILE<dd>License format is invalid, and may be from a `future' 
FLEXlm<I></I> version.</dl><h4>See also</h4>
<ul><li>examples/advanced/<a name="_IX_72"></a>exinstal.c<li><a href="#56692: 2head: 3.3.28 lc_next_conf">Section 4.28, `lc_next_conf,' on page 52</a><li><a href="#29203: 1Head: 4.12 lc_convert">Section 4.9, `lc_convert,' on page 35</a><li><a href="#16090: 1Head: 4.20 lc_feat_list">Section 4.15, `lc_feat_list,' on page 41</a></ul><a name="23439: 2head: 3.3.4 lc_checkin"></a><a name="_IX_73"></a><a name="4.6"></a><h2>4.6  lc_checkin</h2>
<h4>Syntax</h4>
<pre>lc_checkin(job, feature, keep_conn)</pre>
<h4>Description</h4>
<p>
Checks in the licenses of the specified feature. For TCP clients, the daemon will detect 
the fact that the client exited, and return any licenses that were checked out back to the 
available pool. For TCP, this call is used if the application has need of a feature for a 
period of time, then no longer needs it. For UDP, this call is essential to free a license, 
otherwise, the server has to timeout the license. The second parameter is used for TCP 
clients to tell 
FLEXlm<I></I> to keep the connection open to the server for cases where 
another feature will be needed shortly after this one is released. If the communications 
protocol is 
<a name="_IX_74"></a>TCP, there is no appreciable time delay incurred in returning the license if 
the program exits rather than returning the license via 
<I>lc_checkin</I>. However if 
<a name="_IX_75"></a>UDP is 
used, the licenses will not be returned to the pool for 
<TT><a name="_IX_76"></a>LM_A_UDP_TIMEOUT</TT> seconds.<p>
<p>
For reporting purposes in the REPORTLOG file, it is preferable to checkin a license 
with lc_checkin() rather than simply exiting, since these are recorded differently in the 
REPORTLOG file.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) job<dd>From 
<I>lc_new_job()</I><dt>(char *) 
<I>feature</I><dd>The feature name to be checked in, or 
<a name="_IX_77"></a>LM_CI_ALL_FEATURES.<dt>(int) 
<I>keep_conn</I><dd>If non-zero, means `Keep connection to server'; if 0, drops 
TCP connection. Unused for UDP.</dl><h4>See also</h4>
<ul><li><a href="#85076: 2head: 5.1.32 LM_A_UDP_TIMEOUT">Section 5.27, `LM_A_UDP_TIMEOUT,' on page 82</a><li><a href="#66148: 1head: 11.5 Communications Transport (TCP vs. UDP)">Section Chapter 11, `Communications Transport,' on page 145</a></ul><a name="65026: 2head: 3.3.5 lc_checkout"></a><a name="_IX_78"></a><a name="4.7"></a><h2>4.7  lc_checkout</h2>
<h4>Syntax</h4>
<pre>LM_CODE(key, ...)</pre>
<pre>status = lc_checkout(job, feature, version, num_licenses, flag, key, dup_group)</pre>
<h4>Description</h4>
<p>
Checks out one (or more) license(s) of the specified feature. If the process that calls 
<I>lc_checkout</I> exits in any manner, then the checked out license will be returned for re-use by another user. 
 Place the call to 
<I>lc_checkout</I> in an executable that is active 
whenever the user is using the feature. If 
<I>flag</I> is specified as 
<a name="_IX_79"></a><TT>LM_CO_WAIT</TT>, then the 
process will wait until the number of licenses requested for this feature are available. 
The license file must specify a version that is greater than or equal to the version in the 
<I>lc_checkout</I> call.<p>
<p>
If the license file is 
<I>counted</I>, that is, if the number of users specified on the FEATURE 
line is non-zero, 
<I>lc_checkout 
</I>will request the license from a license server. If the 
number of users on the FEATURE line is `uncounted,' it will grant permission based 
on the contents of the license file only - hostid, version, expiration date, etc.<p>
It is strongly recommended that the application first indicate the expected license 
file location, with
<I>          <a name="lc_set_attr"></a>lc_set_attr</I>(<I>job</I>, 
<a name="LM_A_LICENSE_DEFAULT"></a>LM_A_LICENSE_DEFAULT, 
<I>licpath</I>/license.dat). 

The 
<I>licpath</I> should be a location in your `installation hierarchy'. Since this is 
rarely known at compile time, the most common method is to use the registry on 
Windows, or 
<I>getenv()</I> on Unix to find out where the application was installed. 
This makes license installation and product use easier and more reliable.Multiple checkout requests from the same process in the same license job will not 
result in additional licenses being checked out, unless a new request specifies 
more licenses than were previously checked out. That is, two calls to 
lc_checkout(...,1,...); will result in only 1 license being checked out, not 2. A 
second call to request 2 licenses would result in a total of 2 licenses.For improved security, it is recommended that the parameters 
<I>feature, version, 
etc., 
</I>be `hidden'- the string should not be directly declared in source code. It 
should be built up chars or smaller strings, and then created via 
sprintf(). That 
way, it is more difficult for users to change the license being checked out by 
altering the string in the binary.<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job()</I><dt>(char *) 
<I>feature</I><dd>The ASCII feature name desired.<dt>(char *) 
<I>version</I><dd>The version of the feature desired in floating point 
format, maximum of 10 characters (e.g.: 
`12345.123' or `123.456789'. This value must be 
&lt;= the version number in the license file for the 
checkout to succeed.</dl>letters are not allowed in versions; `v1.0' is illegal.Prior to 
FLEXlm<I></I> v4.0, the version argument to 
<I>lc_checkout()</I> was of type double.<dl><dt>(int) 
<I>num_licenses</I><dd>The number of licenses to check out. (Must be &gt; 
0)<dt>(int) 
<I>flag</I> 
<dd>The checkout option flag.<dt>Possible values for 
<I>flag</I> are:</dl><dl><a name="_IX_80"></a><dt>LM_CO_NOWAIT<dd>Do not wait - <I>non-blocking</I>.<a name="_IX_81"></a><dt>LM_CO_WAIT<dd>Wait, return when license is granted - <I>blocking</I>.<a name="_IX_82"></a><dt>LM_CO_QUEUE<dd>Queue request, return immediately. This request 
will give you the license if it is available. You can 
find out if you hold the license by calling 
lc_status().<a name="_IX_83"></a><dt>LM_CO_LOCALTEST<dd>Perform local tests, but do not check out a license 
(return status). The status from this call will detect 
all checkout errors that can be determined from 
the license file 
<I>only</I>. In particular, 
LM_MAXUSERS/LM_USERQUEUED is not 
detected.</dl><dl><dt>(VENDORCODE *) 
<I>key</I><dd>The first argument to 
<TT>LM_CODE</TT>, which includes 
the vendor's encryption seed for this feature.<dt>(int) 
<I>dup_group</I><dd>Duplicate grouping mask for this feature</dl><p>
Requests for licenses from `duplicates' can either be `grouped', or not `grouped'. 
Grouping duplicates allows license requests from separate processes to use a single 
license if the process's USER, HOST, DISPLAY, and/or VENDOR_DEFINED field 
are the same. The 
<I>dup_group</I> parameter allows you to select what to compare to 
constitute a group from the set {<a name="_IX_84"></a>USER 
<a name="_IX_85"></a>HOST 
<a name="_IX_86"></a>DISPLAY 
<a name="_IX_87"></a>VENDOR}. Any of the four 
fields that are not set to compare will automatically `match'; thus not setting any of 
the four fields yields a site license, since all users on all hosts on all displays are the 
same as far as the comparison is concerned. The following examples illustrate the use 
of the duplicate grouping capability:<p>
<dl><dt><B>dup_group value</B><dd><B><dd>Meaning</B><a name="_IX_88"></a><dt>LM_DUP_NONE<dd>Every process gets a new license.<a name="_IX_89"></a><dt>LM_DUP_USER<dd>All requests from this user name share the same 
license.<a name="_IX_90"></a><dt>LM_DUP_HOST<dd>All requests from this host name share the same 
licenses. This is a `floating node-locked' license.<a name="_IX_91"></a><dt>LM_DUP_DISP<dd>All requests from this display share the same 
license. (Useful for display or GUI based 
products, like a window system.)<a name="_IX_92"></a><dt>LM_DUP_VENDOR<dd>All requests with the same vendor-defined data, 
use the same license. (Useful for sharing licenses 
among otherwise unrelated processes.)<dt>LM_DUP_USER | LM_DUP_HOST
<dd><dd>All requests from this user name on this host name 
use the same license. 
<dt>LM_DUP_USER| LM_DUP_DISP<dd>
<dd><dd>All requests from this user name on this display 
use the same license. (One user, displaying on a 
single node, using several nodes to run the 
software.)<dt>LM_DUP_USER | LM_DUP_HOST | LM_DUP_DISP
<dd><dd><dd><dd><dd>All requests from this user name on this host name 
using this display use the same license.<dt>LM_DUP_USER | LM_DUP_VENDOR
<dd><dd>All requests from this user name with the same 
vendor data use the same license.<dt>LM_DUP_SITE<dd>All requests from any user on any node on any 
display with any vendor data use the same license. 
(<a name="_IX_93"></a>SITE LICENSE)</dl><p>
The first client that checks out the feature specifies the duplicate grouping for the 
feature. (The duplicate grouping value is reset whenever all licenses are checked back 
in.) Any subsequent client that attempts to check out the feature with a different 
duplicate grouping mask will be rejected and an error reflecting this will appear in the 
<TT>lmgrd</TT> Debug log file.<p>
<h4>RESERVE and DUP_GROUP</h4>
<p>
There is an important interaction Between 
<a name="RESERVE"></a>RESERVE and the 
<a name="_IX_94"></a>Duplicate Grouping 
Mask. A license reservation for an entity not contained in the duplicate grouping mask 
in the 
lc_checkout() call (e.g., a USER reservation) when the duplicate grouping mask 
is set to 
<TT>LM_DUP_HOST | LM_DUP_DISP</TT>) can cause an interesting interaction at 
run-time. 
<p>
<p>
To understand why this is the case, consider the following example:<p>
<ul><li>Your software groups duplicates based on USER and DISPLAY<li>Your end-user has a license file with a single license<li>Your end-user reserves this license for HOST `nodea'<li>User `joe' on display `displaya' on HOST `nodea' checks out a license. He gets 
the license, since his HOST matches the reservation.<li>User `joe' on display `displaya' on HOST `nodeb' checks out a license. He also 
gets a license, since he is grouped with the first license as a duplicate.<li>The first user (joe/displaya/nodea) checks in his license.</ul><p>
At this point in the example, the situation appears to be inconsistent. The second user 
continues to hold the reservation, which means that a user on `nodeb' is using a license 
reserved for `nodea'. Once this second user checks in the license, the reservation will 
return to the pool of reservations to be used by anyone on `nodea'.<p>
<p>
FLEXlm<I></I> was designed to allow this potential temporary inconsistency rather than the 
alternative, which is to have an unusable reservation.<p>
<a name="29206: 3Head: Registry and ~/.flexlmrc"></a><h4>Registry and ~/.flexlmrc</h4>
<p>
Environment variables can be taken either from the environment, or from the registry 
(on Windows) or ~/.flexlmrc (Unix). After a successful checkout, the 
$VENDOR_LICENSE_FILE variable is set for the location in the registry (Windows) 
or ~/.flexlmrc (Unix). This way, all subsequent checkouts for features from this vendor 
will automatically use the license that worked previously. Note that this location is 
added to all other locations the application may look for the license. This automatic 
registry update can be turned off with<p>
<pre>lc_set_attr(job, LM_A_CKOUT_INSTALL_LIC, (LM_A_VAL_TYPE)0);</pre>
<h4>Return</h4>
<dl><dt>(int) 
<I>status</I><dd>0 - OK, license checked out.<dt>&lt;&gt; 0<dd>Error.</dl><h4>Error Returns</h4>
<dl><a name="_IX_95"></a><dt>LM_BADCODE<dd><a name="_IX_96"></a>License key in license file does not match other data in file.<a name="_IX_97"></a><dt>LM_BADFEATPARAM<dd>Duplicate selection mismatch for this feature'<dt><dd>The checkout request for this feature has specified a 
duplicates mask (LM_DUP_<I>xxx</I>) that does not match the 
mask specified by an earlier checkout. This is probably the 
result of using different versions of your client software, or 
from having an uninitialized variable in the dup_group 
field for lc_checkout().<a name="_IX_98"></a><dt>LM_BADHANDSHAKE<dd>Authentication handshake with daemon failed.<a name="_IX_99"></a><dt>LM_BADPARAM<dd>`key' structure is incorrect type, or feature == NULL, or 
num_licenses == 0.<a name="_IX_100"></a><dt>LM_BADSYSDATE<dd>System clock has been set back. This error can only occur 
when the FEATURE line contains an expiration date.<a name="_IX_101"></a><dt>LM_BAD_VERSION<dd>Version argument is invalid floating point format.<a name="_IX_102"></a><dt>LM_BUSYNEWSERV<dd>License server busy starting another copy of itself - retry.<a name="_IX_103"></a><dt>LM_CANTCONNECT<dd>Cannot establish a connection with a license server.<a name="_IX_104"></a><dt>LM_FEATQUEUE<dd>Feature is queued. 
<I>lc_status</I> will indicate when it is 
available.<a name="_IX_105"></a><dt>LM_FUNCNOTAVAIL<dd>Vendor keys do not support this function.<a name="_IX_106"></a><a name="_IX_107"></a><dt>LM_LOCALFILTER<dd>Checkout request filtered by the vendor-defined filter 
routine.<dt>LM_MAXLIMIT<dd>Checkout exceeds MAX specified in options file.<a name="_IX_108"></a><dt>LM_MAXUSERS<dd>All licenses in use. Applications usually need to 

test for both LM_MAXUSERS and LM_USERSQUEUED 

instead of only LM_MAXUSERS.<a name="LM_NO_SERVER_IN_FILE"></a><dt>LM_NO_SERVER_IN_FILE<dt><dd>No license server specified for counted license.<a name="_IX_109"></a><dt>LM_NOFEATURE<dd>Can not find feature in the license file.<a name="_IX_110"></a><dt>LM_NOSERVSUPP<dd>Server has different license file than client<dd> - client's license 
has feature, but server's does not.<a name="_IX_111"></a><dt>LM_OLDVER<dd>License file does not support a version this new.<dt>LM_PLATNOTLIC<dd>This platform is not authorized by the license - running on 
a platform not included in PLATFORMS='...' list.<a name="_IX_112"></a><dt>LM_SERVBUSY<dd>License server busy - <dd>the request should be retried. (This is 
a rare occurrence.)<a name="LM_USERSQUEUED"></a><dt>LM_USERSQUEUED<dd>Like LM_MAXUSERS, but also indicates that there are 
already some users queued. Applications usually need to 
test for both LM_MAXUSERS and LM_USERSQUEUED 
instead of only LM_MAXUSERS.</dl><h4>See also</h4>
<ul><li><a href="#14252: 1Head: 6.5 LM_A_CHECKOUT_DATA">Section 5.4, `LM_A_CHECKOUT_DATA,' on page 73</a><li><a href="#12939: 1Head: 9.18 LM_A_LICENSE_DEFAULT">Section 5.15, `LM_A_LICENSE_DEFAULT,' on page 78</a><li><a href="#40191: 1Head: 6.15 LM_A_HOST_OVERRIDE">Section 5.10, `LM_A_HOST_OVERRIDE,' on page 76</a><li><a href="#35603: 1Head: 6.12 LM_A_DISPLAY_OVERRIDE">Section 5.7, `LM_A_DISPLAY_OVERRIDE,' on page 74</a><li><a href="#37713: 1Head: 6.34 LM_A_USER_OVERRIDE">Section 5.29, `LM_A_USER_OVERRIDE,' on page 82</a><li><a href="#23439: 2head: 3.3.4 lc_checkin">Section 4.6, `lc_checkin,' on page 29</a><li><a href="#79592: 2head: 9.1.3 FEATURE or INCREMENT Line">Section 6.3.4, `FEATURE or INCREMENT Line,' on page 96</a><li><a href="#69383: 1head: 3.37 lc_status">Section 4.31, `lc_status,' on page 53</a><li><a href="#38172: 1Head: 3.7 Multiple Jobs">Section 3.5, `Multiple Jobs,' on page 19</a><li><a href="#22496: 1Head: 5.6 LM_A_CKOUT_INSTALL_LIC">Section 5.6, `LM_A_CKOUT_INSTALL_LIC,' on page 74</a></ul><a name="_IX_113"></a><a name="4.8"></a><h2>4.8  lc_chk_conf</h2>
<h4>Syntax</h4>
<pre>errors = lc_chk_conf(job, conf, check_name)</pre>
<h4>Description</h4>
<p>
Given a pointer to a CONFIG struct, lc_chk_conf returns a string describing errors in 
the struct, or NULL if no problems are found. 
<p>
Normally<I> lc_ck_conf()</I> should only be used by a license generation program that 
calls 
<I>lc_crypt()</I>, such as 
<TT>lmcrypt</TT>, since warnings are issued on valid license 
feature lines.<I>conf</I> must be a valid CONFIG pointer 
 -  otherwise it will core dump.<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job()</I><dt>(CONFIG *) 
<I>conf</I><dd>The feature (CONFIG *) to be checked.<dt>(int) 
<I>check_name</I><dd>If non-zero, error messages will be reported if the feature 
name is invalid.</dl><h4>Return</h4>
<dl><dt>(char *) 
<I>errors</I><dd>A descriptive error string or 0 if no errors found.</dl><a name="_IX_114"></a><a name="29203: 1Head: 4.12 lc_convert"></a><a name="4.9"></a><h2>4.9  lc_convert</h2>
<h4>Syntax</h4>
<pre>status = lc_convert(job, str, return_str, errors, flag)</pre>
<h4>Description</h4>
<p>
This is an API for companies that want to provide their own front-end for installing 
license files. 
<I>lc_convert()</I> can be used in combination with 
<I><a name="_IX_115"></a>lc_check_key()</I> to provide a 
user-friendly front-end.<p>
<p>
<I>lc_convert()</I> also changes `SERVER 
<a name="_IX_116"></a>this_host' to the real hostname, on either 
<a name="_IX_117"></a>decimal 
or readable licenses. It only does this if 
<I>lc_convert()</I> is run on the same hostid as 
appears on the SERVER line, and does not do this for hostids of DEMO or ANY.<p>
<p>
The output, if readable is requested, will be compatible with the 
<a name="_IX_118"></a>LM_A_LICENSE_FMT_VER setting, which defaults to the current 
FLEXlm<I></I> version.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job()</I><dt>(char *) 
<I>str</I><dd>License file (in readable or decimal format) as a string.<dt>(ptr to char *) 
<I>return_str</I><dd><I>str</I> converted to desired format. Should be freed by caller; 
use 
<I><a name="_IX_119"></a>lc_free_mem()</I> on Windows.<dt>(ptr to char *) 
<I>errors</I><dd>If return value is non-zero, then this is set to a description 
of the problem. Should be freed by caller; use 
<I>lc_free_mem()</I> on Windows.<dt>(int) 
<I>flag</I><dd><a name="_IX_120"></a>LC_CONVERT_TO_READABLE or 
<a name="_IX_121"></a>LC_CONVERT_TO_DECIMAL.</dl><h4>Return</h4>
<dl><dt>(int) 
<I>status</I><dd>0 == success.
-1, if syntax error in 
<I>str</I>, and 
<I>errors</I> is set to explanatory 
message.
Otherwise, 
FLEXlm<I></I> errno.</dl><h4>Error Returns</h4>
<dl><a name="_IX_122"></a><dt>LM_BADPARAM<dd>Invalid 
<I>flag</I> argument.<dt>-1<dd>Explanatory string is provided in 
<I>errors</I>.</dl><h4>See also</h4>
<ul><li>examples/advanced/<a name="_IX_123"></a>exinstal.c, for an example program.<li><a href="#56692: 2head: 3.3.28 lc_next_conf">Section 4.28, `lc_next_conf,' on page 52</a><li><a href="#29203: 1Head: 4.12 lc_convert">Section 4.9, `lc_convert,' on page 35</a><li><a href="#16090: 1Head: 4.20 lc_feat_list">Section 4.15, `lc_feat_list,' on page 41</a><li><a href="#33883: 2head: 3.4.8 lc_cryptstr">Section 4.10, `lc_cryptstr,' on page 36</a>, because lc_convert() has a similar 
interface as lc_cryptstr().<li><a href="#51599: 2head: 5.1.20 LM_A_LINGER">Section 5.16, `LM_A_LICENSE_FMT_VER,' on page 78</a></ul><a name="33883: 2head: 3.4.8 lc_cryptstr"></a><a name="_IX_124"></a><a name="4.10"></a><h2>4.10  lc_cryptstr</h2>
<h4>Syntax</h4>
<pre>status = lc_cryptstr(job, str, return_str, code, flag, filename, errors)</pre>
<h4>Description</h4>
<p>
Generates license file as a string with 
<a name="_IX_125"></a>license keys filled in. This new function is used 
by the 
<TT>lmcrypt</TT> command, and for some vendors will be an easier interface than 
lc_crypt() for generating licenses. You pass a string, which is a whole, valid license 
file, with one exception: each license key must be replaced with a single '0' (zero). 
<p>
<p>
If 
<I>flag 
</I>has 
<TT>LM_CRYPT_ONLY</TT> set, then the function returns the license key for the first 
FEATURE, INCREMENT, PACKAGE, or UPGRADE line in the file. If the 
LM_CRYPT_ONLY bit is clear in the 
<I>flag</I> argument (<TT>!(flag &amp; LM_CRYPT_ONLY))</TT>, 
then the whole file is returned as a string, with valid license keys. If 
<I>flag</I> has 
<TT>LM_CRYPT_FORCE</TT> set, then every line will have the license key re-computed, even 
if the key is not set to '0' If 
<TT>LM_CRYPT_FORCE</TT> is set, and if a line already has a 
license key, the start date will be taken from the current key.<p>
<p>
Comment lines are retained in the 
<I>return_str</I> output.<p>
<p>
<I>return_str</I> and 
<I>errors</I> are malloc'd by 
<I>lc_cryptstr()</I>, and not reused by 
FLEXlm<I></I>, so it is 
the responsibility of the caller to free the space returned if needed. (<I>lc_free_mem()</I> 
should be used on Windows, and can be used everywhere, to free this memory).<p>
<p>
The default start date is `today'. If you want to specify a start date other than today, 
then in place of a '0' in the license key, use the following syntax:<p>
<pre>	start:dd-mmm-yyy.</pre>
<h4>Example:	</h4>
<pre>	start:1-jan-1995</pre>
</ol></ul><p>
The output, if readable is requested, will be compatible with the 
<a name="_IX_126"></a>LM_A_LICENSE_FMT_VER setting, which defaults to the current 
FLEXlm<I></I> version.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job.</I><dt>(char *) 
<I>str</I> 
<dd>Set 
<I>str</I> to a complete valid license file, where the 
license keys are replaced with '0'.<dt>(ptr to char *) 
<I>return_str</I><dd>Resulting license file string. Malloc'd by 
<I>lc_cryptstr</I>, and freed by the calling program. Pass 
the address of a char pointer.<dt>(VENDORCODE *) 
<I>code</I><dd>From 
<TT>LM_CODE</TT> macro, with 
<I>code.data[0]</I> and 
<I>code.data[1]</I> XOR'd with 
<a name="_IX_127"></a>VENDOR_KEY5.<dt>(int) 
<I>flag</I><dd>mask which can be binary OR'd ('|') with the 
following flags:
<TT><a name="_IX_128"></a>LM_CRYPT_ONLY</TT> - If true, only return license 
key for first FEATURE in 
<I>str.
</I><TT><a name="_IX_129"></a>LM_CRYPT_FORCE</TT> - if set, recompute the 
license key for 
<I>every</I> line, even if the license key 
is already present on the line.
<I><a name="_IX_130"></a>LM_CRYPT_IGNORE_FEATNAME_ERRS</I> - If 
set, no warnings returned about invalid feature 
names.
<I><a name="_IX_131"></a>LM_CRYPT_DECIMAL</I> - output will be decimal 
format. Otherwise, readable format.<dt>(char *) 
<I>filename</I><dd>for error reporting, or (char *)0. This name will 
appear in the error message as the filename.<dt>(ptr to char *) 
<I>errors</I><dd>for error reporting, or (char **)0. If there are 
errors, the return value is non-zero and errors is set 
to an explanatory string. Malloc'd by 
<I>lc_cryptstr</I>, 
and freed by the calling program (use 
<I><a name="_IX_132"></a>lc_free_mem()</I> on Windows). Pass the address of a 
char pointer.
If a warning occurs, this 
<I>errors</I> is set to a warning 
string, but the return value is 0 (success)</dl><h4>Return</h4>
<dl><dt>(int) 
<I>status</I><dd>0 == success, !0 indicates an error occurred,</dl><h4>Error Returns</h4>
<p>
Since different errors can occur on every line of the input 
<I>str</I>, 
<I>lc_cryptstr</I> must be able 
to report all these errors independently, and does so via the 
<I>errors</I> parameter. The 
<I>errors</I> parameter is used for both errors and warnings. If there are only warnings, the 
return value from 
<I>lc_cryptstr</I> is success (0), but 
<I>errors</I> is set to a warning message. If 
it's an error, 
<I>lc_cryptstr</I> returns non-zero, and no license keys are generated in 
<I>return_str</I>. Here is an example of error reporting:<p>
<dl><dt>Input:<dd></dl><pre>	FEATURE f1 demo 1.a50 01-jan-1999 0 0 HOSTID=08002b32b161</pre>
<dl><dt>Error reported:</dl><pre>stdin:line 1:Bad version number - must be floating point number, with no letters</pre>
</ol></ul><p>
With this error, no license key is generated and 
<I>return_str</I> will be the same as the input 
<I>str</I>.<p>
<p>
Before calling 
<I>lc_cryptstr()</I>, add the following code:<p>
<pre>	LM_CODE(code, ENCRYPTION_SEED1, ENCRYPTION_SEED2, VENDOR_KEY1,</pre>
<pre>		VENDOR_KEY2, VENDOR_KEY3, VENDOR_KEY4, VENDOR_KEY5);</pre>
<pre>	VENDORCODE vc;</pre>
<pre>	[...]</pre>
<pre>	(void) memcpy((char *)&amp;vc, (char *)&amp;code, sizeof(vc));</pre>
<pre>	vc.data[0] ^= VENDOR_KEY5;</pre>
<pre>	vc.data[1] ^= VENDOR_KEY5;</pre>
<pre>	lc_cryptstr(job, ., &amp;vc, ..); /* for example */</pre>
<h4>See also</h4>
<a href="#33504: 1Head: 4.6 lc_check_key"><p>
Section 4.5, `lc_check_key,' on page 28</a><p>
<a href="#29203: 1Head: 4.12 lc_convert"><p>
Section 4.9, `lc_convert,' on page 35</a><p>
<a href="#13840: 1Head: 4.27 lc_free_mem"><p>
Section 4.19, `lc_free_mem,' on page 44</a><p>
<a href="#51599: 2head: 5.1.20 LM_A_LINGER"><p>
Section 5.16, `LM_A_LICENSE_FMT_VER,' on page 78</a><p>
<p>
machind/lmcrypt.c<p>
<p>
machind/makekey.c<p>
<a name="37211: 2head: 3.3.11 lc_errstring"></a><a name="_IX_133"></a><a name="4.11"></a><h2>4.11  lc_err_info</h2>
<h4>Syntax</h4>
<pre>err_info = lc_err_infojob)</pre>
<h4>Description</h4>
<p>
Returns a pointer to a LM_ERR_INFO struct, which contains all necessary 
information to present an error message to the user. This is the supported method for 
<a name="internationalization"></a>internationalization and 
<a name="translation:foreign languages"></a>translation of 
FLEXlm<I></I> 
<a name="error messages:translation"></a>error messages.<p>
<p>
The format of LM_ERR_INFO is:<p>
<dl><dt>(int) maj_errno<dd>The 
FLEXlm<I></I> error number. See 
<I>lmerrors.h</I> and 
<I>lm_lerrs.h</I> 
in the machind directory for English versions of the error 
messages.<dt>(int) min_errno<dd>The minor error number. This allows a support person with 
access to the 
FLEXlm<I></I> source code to pinpoint the location 
where the error occurred, and thereby provide improved 
support.<dt>(int) sys_errno<dd>The most recent system `errno' (or winsock error on 
Windows)<dt>(char *) feature<dd>The name of the feature that the error applies to.<dt>(char **) lic_files<dd>a null terminated list of char pointers of the license files 
used when the error occurred.<dt>(char *) context<dd>This is a string which gives additional information about 
the error. Its contents depends on the type of error, but is not 
language dependent. Refer to machind/lcontext.h for 
information needed for translation.</dl><p>
This information allows applications to present error messages in any language and in 
any desired format. The three items that need to be translated are context and long and 
short error messages, which all depend on the 
<I>err_info.maj_errno</I>. 
<I>err_info</I>.<I>context</I> is 
the English context message, which is also available in machind/lcontext.h. The 
English error message for 
<I>err_info.maj_errno</I> are in machind/lm_errs.h (short) and 
machind/lm_lerr.h (long). Given an 
<I>err_info.maj_errno</I> and a language, there should 
be a unique context string and unique long and short error messages.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job()</I><dt>Return<dt>(LM_ERR_INFO *) 
<I>err_info</I><dd>pointer to the LM_ERR_INFO struct, outlined 
above.</dl><h4>See also</h4>
<ul><li><a href="#68231: 2head: 3.3.32 lc_perror">Section 4.29, `lc_perror,' on page 52</a><li><a href="#15264: 1Head: 4.14 lc_errtext">Section 4.13, `lc_errtext,' on page 40</a></ul><a name="_IX_134"></a><a name="4.12"></a><h2>4.12  lc_errstring</h2>
<h4>Syntax</h4>
<pre>string = lc_errstring(job)</pre>
<h4>Description</h4>
<p>
Returns the 
FLEXlm<I></I> error string for the most recent 
FLEXlm<I></I> error, along with the 
major and minor error number. If a 
Unix<I></I> error is involved, the 
Unix<I></I> error description 
will also be included in the message, along with the 
Unix<I></I><I> errno</I>.<p>
<p>
This memory is managed by the 
FLEXlm<I></I> library. Do not attempt to free it. This string 
is freed and reset when another 
FLEXlm<I></I> error occurs, so it's only valid between 
FLEXlm<I></I> calls.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job()</I></dl><h4>Return</h4>
<dl><dt>(char *) 
<I>string</I><dd>The 
FLEXlm<I></I> error string text.</dl><h4>Examples</h4>
<pre>No such feature exists (-5,116)</pre>
<pre>Cannot find license file, (-1,73:2), No such file or directory</pre>
<h4>See also</h4>
<ul><li><a href="#68231: 2head: 3.3.32 lc_perror">Section 4.29, `lc_perror,' on page 52</a><li><a href="#15264: 1Head: 4.14 lc_errtext">Section 4.13, `lc_errtext,' on page 40</a></ul><a name="_IX_135"></a><a name="15264: 1Head: 4.14 lc_errtext"></a><a name="4.13"></a><h2>4.13  lc_errtext</h2>
<h4>Syntax</h4>
<pre>string = lc_errtext(job, lm_errno)</pre>
<h4>Description</h4>
<p>
lc_errtext() returns the English text string corresponding to the 
FLEXlm<I></I> lm_errno.   Do 
not attempt to free memory for this string - it's managed by FLEXlm. It's value 
changes when another 
FLEXlm<I></I> error occurs.<p>
<p>
Normally, lc_errstring() or lc_perror() are preferred and recommended, since they 
contain more information, including the 
FLEXlm<I></I> minor error number (used by 
GLOBEtrotter Software<I></I> for support when needed) and any system error information, 
if applicable.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job()</I><dt>(int) 
<I>lm_errno</I><dd>FLEXlm<I></I> error number.</dl><h4>Return</h4>
<dl><dt>(char *) 
<I>string</I><dd>The 
FLEXlm<I></I> error string text.</dl><h4>See also</h4>
<ul><li><a href="#68231: 2head: 3.3.32 lc_perror">Section 4.29, `lc_perror,' on page 52</a><li><a href="#37211: 2head: 3.3.11 lc_errstring">Section 4.11, `lc_err_info,' on page 38</a></ul><a name="_IX_136"></a><a name="4.14"></a><h2>4.14  lc_expire_days</h2>
<pre>days = lc_expire_days(job, conf);</pre>
<h4>Description</h4>
<p>
Returns the number of days until a license expires.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job()</I><dt>(CONFIG *) 
<I>conf</I><dd>A FEATURE line from the license file. Use 
<I>lc_next_conf()</I>, 
<I>lc_get_config()</I> or 
<I>lc_auth_data()</I> to obtain the CONFIG 
pointer.</dl><h4>Return</h4>
<dl><dt>(int) 
<I>days</I><dd>LM_FOREVER: Unexpiring license.<dt><dd>&gt; 0: Number of days until expiration.<dt><dd>==0: The license will expire tonight at midnight.<dt><dd>&lt; 0: 
FLEXlm<I></I> errno.</dl><h4>Error Returns</h4>
<dl><dt>LM_BADPARAM<dd>conf 
is 0.<a name="_IX_137"></a><dt>LM_LONGGONE<dd><I>conf</I> has already expired.</dl><a name="_IX_138"></a><a name="16090: 1Head: 4.20 lc_feat_list"></a><a name="4.15"></a><h2>4.15  lc_feat_list</h2>
<h4>Syntax</h4>
<pre>list = lc_feat_list(job, flags, dupaction)</pre>
<h4>Description</h4>
<p>
Gets the list of all features in the license file.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(int) 
<I>flags</I><dd>LM_FLIST_ALL_FILES for all license files. If 0, only the 
first license in the license-file list is used.<dt>(void) (*<I>dupaction</I>)() 
<dd>Action routine called when a duplicate feature is found. 
This routine is called upon the second occurrence of any 
feature name. If specified as NULL, no call is made.</dl><h4>Return</h4>
<dl><dt>(char **) 
<I>list</I><dd>List of features.<I> list</I> is a pointer to a NULL-terminated array 
of feature string pointers. Both the pointers and the string 
data are malloc'd; this memory is freed upon a subsequent 
call to<I> 
</I>lc_feat_list()<I>. 
</I>Do not free this data. If NULL, an 
error has occurred.</dl><p>
The 
dupaction() callback routine is called with two parameters:<p>
<pre>	(*dupaction)(feature, daemon)</pre>
</ol></ul><p>
<p>
<dl><dt>(char *) 
<I>feature</I><dd>feature name.<dt>(char *) daemon<dd>daemon for `feature'.</dl><h4>Error Returns</h4>
<dl><dt>LM_CANTMALLOC<dd>malloc() call failed.<a name="_IX_139"></a><dt>LM_NOFEATURE<dd>Specified feature not found.</dl><a name="15999: 2head: 3.3.14 lc_first_job, lc_next_job"></a><a name="_IX_140"></a><a name="_IX_141"></a><a name="4.16"></a><h2>4.16  lc_first_job, lc_next_job</h2>
<h4>Syntax</h4>
<pre>LM_HANDLE *job</pre>
<pre>job = lc_first_job(job);</pre>
<pre>while (job)</pre>
<pre>{</pre>
<pre>	/*processing*/</pre>
<pre>	job = lc_next_job(job);</pre>
<pre>}</pre>
<h4>Description</h4>
<p>
lc_first_job() and 
lc_next_job() are used to walk the list of jobs. This only works 
properly if all calls to 
<I>lc_new_job()</I> have a pointer to the current job as the first 
parameter.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>current job.</dl><h4>Return</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>next currently active job, or (LM_HANDLE *)0 if end.</dl><h4>Error Returns</h4>
<dl><dt>None</dl><h4>See also</h4>
<ul><li><a href="#75729: 2head: 3.3.15 lc_get_attr">Section 4.18, `lc_free_job,' on page 43</a><li><a href="#19115: 1Head: 4.27 lc_new_job">Section 4.27, `lc_new_job,' on page 50</a><li><a href="#38172: 1Head: 3.7 Multiple Jobs">Section 3.5, `Multiple Jobs,' on page 19</a></ul><a name="39426: 1Head: 4.21 lc_free_hostid"></a><a name="4.17"></a><h2>4.17  lc_free_hostid</h2>
<h4>Syntax</h4>
<pre>lc_free_hostid(job_handle, hostid_ptr)</pre>
<h4>Description</h4>
<p>
lc_free_hostid()<I> 
</I>frees the memory associated with a hostid which has been allocated 
with 
<I><a name="l_new_hostid"></a>l_new_hostid()</I> or 
<I><a name="lc_copy_hostid"></a>lc_copy_hostid()</I>. If passed a hostid list, 
<I><a name="_IX_142"></a>lc_free_hostid()</I> frees 
the whole list.<p>
<p><hr>
Note:	Do not use this function on the return data from 
<I><a name="_IX_143"></a>lc_gethostid()</I> or 
<I><a name="_IX_144"></a>lc_getid_type()</I>, 
since they free their own memory.<hr><p>
<h4><I></I>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(HOSTID *) 
<I>hostid_ptr</I><dd>From 
<I><a name="l_new_hostid"></a>l_new_hostid().</I></dl><h4>Return</h4>
<dl><dt>None</dl><h4>Error Returns</h4>
<dl><dt>LM_BADPARAM<dd>no such job.</dl><h4>See also</h4>
<ul><li><a href="#11229: 1Head: 4.3 l_new_hostid">Section 4.3, `l_new_hostid,' on page 26</a></ul><a name="75729: 2head: 3.3.15 lc_get_attr"></a><a name="4.18"></a><h2>4.18  lc_free_job</h2>
<h4>Syntax</h4>
<pre>lc_free_job(job_handle)</pre>
<h4>Description</h4>
<p>
lc_free_job()<I> 
</I>frees the memory associated with a job, which has been allocated by 
<a name="_IX_145"></a>lc_new_job(). On Windows, this call is mandatory and must be matched to the 
corresponding 
<I>lc_new_job()</I> call. On Unix or VMS, this call is only needed by an 
application that uses a large number of jobs over its lifetime.<p>
<h4><I></I>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I></dl><h4>Return</h4>
<dl><dt>None</dl><h4>Error Returns</h4>
<dl><dt>LM_BADPARAM<dd>no such job.</dl><h4>See also</h4>
<ul><li><a href="#25921: 2head: 3.3.23 lc_init">Section 4.25, `lc_init 
 -  (license generator only),' on page 49</a><li><a href="#19115: 1Head: 4.27 lc_new_job">Section 4.27, `lc_new_job,' on page 50</a><li><a href="#43831: 2head: 3.3.30 lc_set_attr">Section 4.30, `lc_set_attr,' on page 53</a><li><a href="#38172: 1Head: 3.7 Multiple Jobs">Section 3.5, `Multiple Jobs,' on page 19</a></ul><a name="_IX_146"></a><a name="13840: 1Head: 4.27 lc_free_mem"></a><a name="4.19"></a><h2>4.19  lc_free_mem</h2>
<h4>Syntax</h4>
<pre>lc_free_mem(job, char_pointer)</pre>
<h4>Description</h4>
<p>
lc_free_mem()<I> 
</I>frees memory allocated by another 
FLEXlm<I></I> function. 
<I>lc_free_mem() 
</I>is 
portable, and can be used everywhere, but is currently only needed on Windows.<p>
<h4><I></I>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(char *) 
<I>char_pointer</I><dd>Memory allocated by 
<I>lc_cryptstr()</I><I> or</I><I> lc_convert()</I><I>.</I></dl><h4>Return</h4>
<dl><dt>None</dl><h4>See also</h4>
<ul><li><a href="#29203: 1Head: 4.12 lc_convert">Section 4.9, `lc_convert,' on page 35</a><li><a href="#33883: 2head: 3.4.8 lc_cryptstr">Section 4.10, `lc_cryptstr,' on page 36</a></ul><a name="83986: 2head: 3.3.18 lc_get_attr"></a><a name="_IX_147"></a><a name="4.20"></a><h2>4.20  lc_get_attr</h2>
<h4>Syntax</h4>
<pre>#include "lm_attr.h"</pre>
<pre>status = lc_get_attr(job, key, value)</pre>
<h4>Description</h4>
<p>
Retrieves a 
FLEXlm<I></I> attribute. The key describes which attribute to retrieve, and the 
value is a pointer to the value for the attribute. See 
<TT>lm_attr.h</TT> for key constants and value 
types.<p>
<I>value</I> must be a pointer to the correct attribute type, and should be cast to a 
(short *).Types of char * are handled a little differently than other types. Types of int or 
short are declared, and a pointer to the declared variable is passed as an argument. 
Types of char * are declared as char *, and the variable itself is passed.<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(int) 
<I>key</I> 
<dd>Which attribute to get.</dl><h4>Return</h4>
<dl><dt>(short *) 
<I>value</I> 
<dd>Value of the attribute (cast to appropriate type).<dt>(int) 
<I>status</I><dd>0 - OK, &lt;&gt;0, error.</dl><h4>Error Returns</h4>
<dl><a name="_IX_148"></a><dt>LM_NOSUCHATTR<dd>No such attribute exists.<a name="_IX_149"></a><dt>LM_NOADMINAPI<dd><a name="_IX_150"></a><TT>LM_A_VD_GENERIC_INFO</TT> or 
<TT><a name="_IX_151"></a>LM_A_VD_FEATURE_INFO</TT> only - request was made to 
other company's vendor daemon.<dt>LM_NOSERVSUPP<dd><TT>LM_A_VD_GENERIC_INFO</TT> or 

<TT>LM_A_VD_FEATURE_INFO</TT> only - pre-v4.0 server does 
not support these requests.</dl><h4>See also</h4>
<ul><li><a href="#43831: 2head: 3.3.30 lc_set_attr">Section 4.30, `lc_set_attr,' on page 53</a><li><a href="#Controlling Licensing Behavior Of Your Application">Section Chapter 5, `Controlling Licensing Behavior Of Your Application With 
lc_set_attr,' on page 71</a></ul><a name="63009: 2head: 3.3.16 lc_get_config"></a><a name="_IX_152"></a><a name="4.21"></a><h2>4.21  lc_get_config</h2>
<h4>Syntax</h4>
<pre>config = lc_get_config(job, feature)</pre>
<h4>Description</h4>
<p>
Gets the license file data for a given feature. 
FLEXlm<I></I> allows multiple valid FEATURE 
and INCREMENT lines (of the same feature name) in a license file. 
<I>lc_get_config</I><I>()</I> 
will return the first CONF struct, and 
<I>lc_next_config()</I> retrieves the next 
(<I>lc_next_config()</I> can also find the first). 
<I>lc_get_config</I>() does not authenticate feature 
lines. That is, a user can type in a feature line with an invalid license-key, and 
<I>lc_get_config()</I> will still return it. For an authenticated feature line, you must first 
checkout the feature, and then use 
<I>lc_auth_data</I>().<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(char *) 
<I>feature</I> 
<dd>The desired feature.</dl><h4>Return</h4>
<dl><dt>(struct config *) 
<I>config</I><dd>The config structure. If no feature found, then NULL. The 
config structure is defined in the header file 
<TT>lmclient.h</TT>.</dl><h4>Error Returns</h4>
<dl><dt>LM_NOFEATURE<dd>Specified feature does not exist.<dt>LM_NOCONFFILE<dd>License file does not exist.<dt>LM_BADFILE<dd>License file corrupted.<dt>LM_NOREADLIC<dd>Cannot read license file.<dt>LM_SERVNOREADLIC<dd>Cannot read license data from license server.</dl><h4>See also</h4>
<ul><li><a href="#60631: 2head: 3.3.2 lc_auth_data">Section 4.4, `lc_auth_data,' on page 27</a><li><a href="#56692: 2head: 3.3.28 lc_next_conf">Section 4.28, `lc_next_conf,' on page 52</a></ul><a name="_IX_153"></a><a name="21737: 1Head: 4.22 lc_heartbeat"></a><a name="4.22"></a><h2>4.22  lc_heartbeat</h2>
<h4>Syntax</h4>
<pre>rc = lc_heartbeat(job, ret_num_reconnects, minutes)</pre>
<h4>Description</h4>
<p>
<I>lc_heartbeat()</I> exchanges heartbeat messages with the license server. By default, 
heartbeats are sent automatically, using 
<I>lc_timer()</I>. To use 
<I>lc_heartbeat()</I>, you must call 
<TT>lc_set_attr(job, LM_A_CHECK_INTERVAL, (LM_A_VAL_TYPE)-1)</TT> to turn off the 
automatic 
<I>lc_timer()</I>. Heartbeat messages are strongly recommended for security - for 
the client to ensure that it will re-checkout its licenses from a restarted server, thereby 
reducing over usage. Heartbeats are not needed for the server to retain a client's license 
(unless UDP communications is used) - the server retains the license until the client 
exits. If 
<I>lc_heartbeat()</I> is called, the client will automatically reconnect and re-checkout from a server that has restarted. It also informs the application of a number 
of states that may indicate attempted tampering with the license server.<p>
<p>
The return value, if non-zero, indicates that the server is down, and how many 
reconnect attempts have been made. This can be used in many ways, to inform the user 
the server is down, and possibly to deny use after a specified number of failures.<p>
<p>
The arguments 
<I>ret_num_reconnects</I> and 
<I>minutes</I> are optional. Their use is 
recommended where security is particularly important - otherwise they can be safely 
set to 0, and they will be ignored. If utilized, they indicate that a server has been 
stopped and started many times in a few minutes, possibly signifying attempted theft.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job()</I><I>.</I><dt>(int *) 
<I>ret_num_reconnects</I><dd>Pointer to int. If Null, this argument is ignored. If non-null, 
and the client has just successfully reconnected to the 
server, the return value will be 0 (success), and 
<I>ret_num_reconnects</I> is set to the number of times the client 
has reconnected in the last 
<I>minutes</I>. If this is a large 
number, it may indicate attempted theft.<dt>(int) 
<I>minutes</I><dd>If 0, this argument is ignored. If non-zero, it's used to detect 
when a server is being started and stopped many times in a 
short period, which can indicate attempted theft. The 
reporting period is set with 
<I>minutes</I>.</dl><h4>Return</h4>
<dl><dt>(int) 
<I>rc</I><dd>If non-zero, the license server is currently down, and is the 
number of failed attempts to reconnect.</dl><h4><B>How 
</B>lc_heartbeat()<B> Works</B></h4>
<p>
lc_heartbeat() sends a 
<a name="_IX_154"></a>heartbeat to the server. It then reads the response from the 
previously sent heartbeat. The first heartbeat is sent when the application first connects 
to the server, usually in 
lc_checkout(). In this manner, there is normally no delay in 
lc_heartbeat(). 
<p>
<p>
If 
lc_heartbeat() is unable to read a response from the server, it attempts to reconnect 
to the server. If the application has set an 
<TT><a name="_IX_155"></a>LM_A_USER_RECONNECT</TT> function, this 
function will also get called, which is useful if lc_heartbeat is registered as a callback 
(the default). If this reconnect fails, then an internal flag is set and subsequent calls to 
lc_heartbeat() will attempt reconnection. These attempts are made for 
<TT><a name="_IX_156"></a>LM_A_RETRY_COUNT</TT> times on Unix and VMS (On Windows, the attempt is made 
forever). If a reconnection occurs before 
<TT>LM_A_RETRY_COUNT</TT> attempts, the 
<TT><a name="_IX_157"></a>LM_A_USER_RECONNECT_DONE</TT> routine, if specified, will be called. If a 
reconnection fails to occur after 
<TT>LM_A_RETRY_COUNT</TT> attempts, the 
<TT><a name="_IX_158"></a>LM_A_USER_EXITCALL</TT> routine, if specified, will be called. If 
<TT><a name="_IX_159"></a>LM_A_USER_EXITCALL</TT> is not specified, the application will exit with the error 
message, `<TT>Lost license, cannot reconnect</TT>' to stderr.<p>
<h4><B>lc_heartbeat(), User TIMEOUT Option, and UDP Timeout</B></h4>
<p>
If 
lc_heartbeat() is not called for an extended period, then the application may lose its 
license. This can happen for two reasons: the application is communicating via UDP 
or the end-user has set a 
<TT><a name="_IX_160"></a>TIMEOUT</TT> for this feature in the end-user options file. In both 
cases, the server has a timeout associated with the license which gets invoked if 
lc_heartbeat() is not called within the timeout interval. Make sure that 
<TT><a name="_IX_161"></a>LM_A_UDP_TIMEOUT 
</TT><TT>and</TT><TT> 
<a name="_IX_162"></a>LM_A_TCP_TIMEOUT 
</TT>are large enough to 
accommodate your usage of 
lc_heartbeat(). Similarly, make sure 
<I><a name="_IX_163"></a>ls_minimum_user_timeout</I> in 
<TT><a name="_IX_164"></a>lsvendor.c 
</TT>is large enough so that users will not timeout 
applications that are in use.<p>
<p>
If the license is inadvertently released, the next 
<I>lc_heartbeat()</I> will automatically re-acquire the license, if there is still a license available.<p>
<h4>See also</h4>
<ul><li><a href="#21737: 1Head: 4.22 lc_heartbeat">Section 4.22, `lc_heartbeat,' on page 46</a></ul><a name="_IX_165"></a><a name="4.23"></a><h2>4.23  lc_hostid</h2>
<h4>Syntax</h4>
<pre>stat = lc_hostid(job, id_type, buf)</pre>
<h4>Description</h4>
<p>
Fills in 
<I>buf</I> with a hostid string specified by 
<I>id_type</I>. If 
<I>id_type</I> is HOSTID_DEFAULT, 
you get the default 
<I>id_type</I> on the system.<p>
<p>
This function allows developers access to hostid information in string format. This 
function is recommended in the future; avoid functions that deal with (HOSTID *) 
struct information, since this struct may change from version to version.<p>
<p>
Note that lc_hostid may return a space-separated list of hostids, if appropriate.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(int) 
<I>id_type</I><dd>Hostid types are specified and described in lmclient.h.</dl><h4>Return</h4>
<dl><dt>(int) 
<I>stat</I><dd>0 if successful, 
FLEXlm<I></I> errno otherwise.<dt>(char) 
<I>buf</I><dd>A pointer to a char array of length MAX_CONFIG_LINE. 
If successful, the hostid string is returned here.</dl><h4>Error Returns</h4>
<dl><dt>LM_FUNCNOTAVAIL<dd>Vendor keys do not support this 
<I>id_type</I>.</dl><h4>See also</h4>
<ul><li><TT>lmclient.h</TT> for definition of HOSTID struct</ul><a name="91352: 2head: 3.3.22 lc_idle"></a><a name="_IX_166"></a><a name="4.24"></a><h2>4.24  lc_idle</h2>
<h4>Syntax</h4>
<pre>lc_idle(job, flag)</pre>
<h4>Description</h4>
<p>
Informs 
FLEXlm<I></I> when the process is idle. 
lc_idle() enables the end-user feature 
inactivity 
<a name="_IX_167"></a>TIMEOUT to allow idle licenses to be reclaimed. Use of 
lc_idle() is 
recommended for end-users to take advantage of the TIMEOUT option. 
lc_idle() also 
affects vendor daemon timeout of UDP clients.<p>
<p>
lc_idle()<I> 
</I>can be used to bracket a portion of the application code that prompts for user 
input, so that when the user is not using the application, the 
FLEXlm<I></I> daemon can 
detect the fact that the application is idle. lc_idle only sets a flag internally in the 
application; it is therefore safe to call as often as necessary.<p>
<p>
A typical use would be:<p>
<pre>	lc_idle(1);		/* Process is idle now */</pre>
<pre>	... get input from user...</pre>
<pre>	lc_idle(0);	/* Process is no longer idle */</pre>
<h4><B>Parameters</B></h4>
<dl><dt>(int) 
<I>flag</I><dd>0 if process is not idle, non-zero if process is idle.</dl><h4><B>Return</B></h4>
<p>
None.<p>
<p><hr>
Caution:	There is no detection of license loss (due to daemon shutdown, etc.) while the 
application is `idle'. 
<a name="_IX_168"></a>UDP clients can inadvertently lose their license if the 
application is idle longer than 
<a name="_IX_169"></a><TT>LM_A_UDP_TIMEOUT</TT>. When the application is 
active again, the license, if it is still available, will be re-checked out.<hr><p>
<h4>See also</h4>
<ul><li><a href="#21737: 1Head: 4.22 lc_heartbeat">Section 4.22, `lc_heartbeat,' on page 46</a><li><a href="#85076: 2head: 5.1.32 LM_A_UDP_TIMEOUT">Section 5.27, `LM_A_UDP_TIMEOUT,' on page 82</a><li><a href="#52105: 2head: 6.3.17 ls_minimum_user_timeout">Section 8.3.18, `ls_minimum_user_timeout,' on page 131</a></ul><a name="25921: 2head: 3.3.23 lc_init"></a><a name="_IX_170"></a><a name="4.25"></a><h2>4.25  lc_init  -  (license generator only)</h2>
<h4>Syntax</h4>
<pre>#include "lm_code.h"</pre>
<pre>LM_CODE(code, ENCRYPTION_SEED1, ENCRYPTION_SEED2, VENDOR_KEY1,</pre>
<pre>	VENDOR_KEY2, VENDOR_KEY3, VENDOR_KEY4, VENDOR_KEY5);</pre>
<pre>LM_HANDLE *job = (LM_HANDLE *)NULL;</pre>
<pre>status = lc_init(prevjob, VENDOR_NAME, &amp;code, &amp;job)</pre>
<h4>Description</h4>
<p>
<I>lc_init()</I> should only be used with license generators, and should not normally be used 
in applications shipped to clients. Use 
<I>lc_new_job()</I> instead, as it offers enhanced 
security.<p>
<p>
Please refer to 
<I>lc_new_job() 
</I>for information about 
<I>lc_init()</I>. The only differences are:<p>
<ul><li><I>lc_init()</I> requires 
<TT>#include `lm_code.h'</TT>. 
<I>lc_new_job()</I> does not.<li>With 
<I>lc_init()</I>, use the LM_CODE macro to create the 3rd argument to 
<I>lc_init()</I>. 
With 
<I>lc_new_job()</I>, the 3rd argument is instead a pointer to an uninitialized 
VENDORCODE struct.<li>With 
<I>lc_new_job()</I>, the 2nd argument is unused, and is preferably 0. With 
<I>lc_init()</I>, it's VENDOR_NAME.<li>With 
<I>lc_new_job()</I>, 
<I>lc_new.o 
</I>(<I>lc_new.obj 
</I>on Windows) must also be linked into 
the application.</ul><h4>See also</h4>
<ul><li><a href="#19115: 1Head: 4.27 lc_new_job">Section 4.27, `lc_new_job,' on page 50</a></ul><a name="_IX_171"></a><a name="4.26"></a><h2>4.26  lc_log</h2>
<h4>Syntax</h4>
<pre>lc_log(job, msg)</pre>
<h4>Description</h4>
<p>
Logs a message in the lmgrd debug log file, if the license is served by lmgrd.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job()</I><I>.</I><dt>(char *) 
<I>msg</I><dd>The message to be logged. The maximum length of the 
string is 
<a name="_IX_172"></a><TT>LM_LOG_MAX_LEN</TT>.</dl><h4>Return</h4>
<p>
None.<p>
<h4>Error Returns</h4>
<dl><dt>LM_NOSOCKET<dd>Communications failure to daemon.<dt>LM_CANTWRITE<dd>Write error sending message to daemon.</dl><h4>See also</h4>
<ul><li><a href="#35936: 1head: 9.2 Locating the License File">Section 6.5, `Locating the License File,' on page 108</a></ul><a name="_IX_173"></a><a name="19115: 1Head: 4.27 lc_new_job"></a><a name="4.27"></a><h2>4.27  lc_new_job</h2>
<h4>Syntax</h4>
<pre>VENDORCODE code;</pre>
<pre>LM_HANDLE *job = (LM_HANDLE *)NULL;</pre>
<pre>status = lc_new_job(prevjob, unused, &amp;code, &amp;job)</pre>
<h4>Description</h4>
<p>
<I>lc_new_job()</I> should not be used with license generators (like 
<I>lmcrypt</I> and 
<I>makekey</I>). 
Use 
<I>lc_init()</I> instead.<p>
<p>
All applications that call lc_new_job() must link 
<a name="_IX_174"></a>lm_new.o (<a name="_IX_175"></a>lm_new.obj on Windows) 
into their application. If the application fails to link with an error about `<a name="_IX_176"></a>l_n36_buf', 
it means that you need to link lm_new.o (lm_new.obj) in also.<p>
<p>
<I>lc_new_job()</I> initializes 
FLEXlm<I></I> and creates a license `<a name="_IX_177"></a>job.' Subsequent calls to 
lc_new_job() create new license jobs. Each license job is independent.<p>
<p><hr>
Note:	lc_new_job() MUST be the first 
FLEXlm<I></I> call you make in your application. Do NOT 
call 
lc_set_attr() or 
lc_get_attr() before calling 
lc_new_job().<hr><p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>prevjob</I><dd>Must be NULL on first call to 
<I>lc_new_job</I>. On 
subsequent calls, use any existing job previously 
initialized with lc_new_job().<dt>unused<dd>This argument is currently unused, but is there to 
keep the arguments the same as lc_init(). We 
recommending supplying a 0 argument.<dt>pointer to (VENDORCODE) 
<I>code</I><dd>pointer to VENDORCODE struct. Initialized in 
this call. Used later as argument to<I> lc_checkout().</I></dl><h4>Return</h4>
<dl><dt>pointer to (LM_HANDLE *) 
<I>job</I><dd>Set to job for the current process. This is used as 
the first argument to all subsequent 
<I>lc_xxx() 
</I>functions.<dt>(int) status 
<dd>Value of 
<I>lc_get_errno() 
</I>after initialization is 
complete, 0 if successful.<dd></dl><h4>Error Returns</h4>
<dl><dt>LM_BAD_TZ<dd>Time zone offset from GMT is &gt; 24 hours (may imply a 
user is attempting to bypass an expiration date).<dt>LM_BADPLATFORM<dd>Vendor keys do not support this platform.<a name="_IX_178"></a><dt>LM_BADKEYDATA<dd>Bad vendor keys.<a name="_IX_179"></a><dt>LM_BADVENDORDATA<dd><dt><dd>Unknown vendor key type.<dt>LM_CANTMALLOC<dd>malloc() call failed.<a name="_IX_180"></a><dt>LM_DEFAULT_SEEDS<dd>ENCRYPTION_SEEDs were left to default values, but 
daemon name is not `demo'.<a name="_IX_181"></a><a name="_IX_182"></a><dt>LM_EXPIRED_KEYS<dd>Vendor keys have expired.<a name="_IX_183"></a><dt>LM_KEY_NO_DATA<dd>Vendor key data not supplied.<a name="_IX_184"></a><dt>LM_LIBRARYMISMATCH<dd><TT>lmclient.h/liblmgr.a</TT> version mismatch.<a name="_IX_185"></a><a name="_IX_186"></a><dt>LM_NONETWORK<dd>Networking software not available on this machine.<a name="_IX_187"></a><dt>LM_OLDVENDORDATA<dd>Old vendor keys supplied.</dl><h4>See also</h4>
<ul><li><a href="#25921: 2head: 3.3.23 lc_init">Section 4.25, `lc_init 
 -  (license generator only),' on page 49</a><li><a href="#75729: 2head: 3.3.15 lc_get_attr">Section 4.18, `lc_free_job,' on page 43</a><li><a href="#38172: 1Head: 3.7 Multiple Jobs">Section 3.5, `Multiple Jobs,' on page 19</a></ul><a name="56692: 2head: 3.3.28 lc_next_conf"></a><a name="_IX_188"></a><a name="4.28"></a><h2>4.28  lc_next_conf</h2>
<h4>Syntax</h4>
<pre>config = lc_next_conf(job, feature, pos)</pre>
<h4>Description</h4>
<p>
Returns the next line in the license file matching `feature.' The search is started from 
`pos'. 
<I>lc_next_conf</I>() does not authenticate feature lines. That is, a user can type in a 
feature line with an invalid license-key, and 
<I>lc_next_conf()</I> will still return it. For an 
authenticated feature line, you must first checkout the feature, and then use 
<I>lc_auth_data</I>().<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(char *) 
<I>feature</I> 
<dd>The desired feature line.<dt>(ptr to CONFIG *)<I>pos<dd></I><dd>Declare CONFIG *pos = 0;.and use &amp;pos for argument.</dl><h4>Return</h4>
<dl><dt>(struct config *) 
<I>config</I><dd>The config structure. If none found, then NULL.<dt>(long *) 
<I>pos</I><dd>Updated to next license file entry.</dl><h4>Error Returns</h4>
<dl><dt>(See 
lc_get_config()).</dl><h4>Example</h4>
<pre>CONFIG *pos = 0, *conf;
	while (conf = lc_next_conf(job, "myfeature", &amp;pos))
		/* ... */</pre>
<h4>See also</h4>
<ul><li><a href="#60631: 2head: 3.3.2 lc_auth_data">Section 4.4, `lc_auth_data,' on page 27</a></ul><a name="68231: 2head: 3.3.32 lc_perror"></a><a name="_IX_189"></a><a name="4.29"></a><h2>4.29  lc_perror</h2>
<h4>Syntax</h4>
<pre>lc_perror(job, string)</pre>
<h4>Description</h4>
<p>
Prints a 
FLEXlm<I></I> error message, in the same format as the 
Unix<I></I> routine 
perror(), e.g.:<p>
<pre>	"string": FLEXlm error-string</pre>
</ol></ul><p>
If a system error has also occurred, it will be included in the message.<p>
<p>
On 
<a name="_IX_190"></a>Windows and 
Windows NT systems, a message box of type MB_OK will be 
displayed with the 
FLEXlm<I></I> error message. The 
FLEXlm<I></I> error messages are available 
by calling 
<a name="_IX_191"></a>lc_errstring().<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(char *) 
<I>string</I><dd>The first part of the error message, as above. 
</dl><h4>Return</h4>
<p>
None.<p>
<h4>See also</h4>
<ul><li><a href="#37211: 2head: 3.3.11 lc_errstring">Section 4.11, `lc_err_info,' on page 38</a></ul><a name="43831: 2head: 3.3.30 lc_set_attr"></a><a name="_IX_192"></a><a name="4.30"></a><h2>4.30  lc_set_attr</h2>
<h4>Syntax</h4>
<pre>#include "lm_attr.h"</pre>
<pre>status = lc_set_attr(job, key, (LM_A_VAL_TYPE)value)</pre>
<h4>Description</h4>
<p>
Sets a 
FLEXlm<I></I> attribute. The key describes which attribute to set, and the value is the 
value for the attribute. See the header file 
<TT>lm_attr.h</TT> for key constants and value types. 
<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(int) 
<I>key</I><dd>Which attribute to set.<dt>(<a name="_IX_193"></a><TT>LM_A_VAL_TYPE</TT>) 
<I>value</I><dd><dt><dd>Value to set it to. Values should be of the appropriate type 
for the particular attribute (see 
<TT>lm_attr.h</TT>), but should be cast 
to 
<TT>LM_A_VAL_TYPE</TT>.</dl><h4>Return</h4>
<dl><dt>(int) 
<I>status</I><dd> 0 - Ok, !=0, error.</dl><h4>Error Returns</h4>
<dl><dt>LM_FUNCNOTAVAIL<dd>Vendor keys do not support this function.<dt>LM_BADPARAM<dd>Specified parameter is incorrect.<dt>LM_NOCONFFILE<dd>Specified license file cannot be found 
(<TT>LM_A_LICENSE_FILE</TT> or 
<TT>LM_A_LICENSE_FILE_PTR</TT>).<a name="_IX_194"></a><dt>LM_NOSUCHATTR<dd>Specified attribute does not exist.</dl><h4>See also</h4>
<ul><li><a href="#Controlling Licensing Behavior Of Your Application">Section Chapter 5, `Controlling Licensing Behavior Of Your Application With 
lc_set_attr,' on page 71</a></ul><a name="69383: 1head: 3.37 lc_status"></a><a name="4.31"></a><h2>4.31  lc_status</h2>
<h4>Syntax</h4>
<pre>status = lc_status(job, feature)</pre>
<h4>Description</h4>
<p>
Returns the status of the requested feature.<p>
<p>
This call is used only when QUEUEing for a license. Normally QUEUEing is done in 
the following manner:<p>
<pre>rc = lc_checkout(....<a name="_IX_195"></a>LM_CO_NOWAIT,...);</pre>
<pre>if (rc == LM_MAXUSERS || rc == LM_USERSQUEUED)</pre>
<pre>{	</pre>
<pre>	printf("Waiting for license...");</pre>
<pre>	rc = lc_checkout(....<a name="_IX_196"></a>LM_CO_WAIT,...);</pre>
<pre>}</pre>
</ol></ul><p>
However, in this example the application must wait in the 
<I>lc_checkout</I> call. If the 
application needs to continue doing processing, you can use 
lc_status() to periodically 
check on the status. This might be coded in the following manner:<p>
<pre>rc = lc_checkout(...,<a name="_IX_197"></a>LM_CO_QUEUE,...)
switch (rc) 
{
	case 0:
		break; /* got the license */
	case LM_MAXUSERS:
	case <a name="_IX_198"></a>LM_USERSQUEUED:
	case <a name="_IX_199"></a>LM_FEATQUEUE:
		printf("Waiting for license...");
		while (lc_status(feature)
		{
			/* processing */
		}
		break; /* got the license */
	default:
		lc_perror("Checkout for license failed");
}</pre>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(char *) 
<I>feature</I><dd>The feature name.</dl><h4>Return</h4>
<dl><dt>(int) 
<I>status</I><dd>Status of this feature (in this process): 

&lt; 0 
 -  error;
0 
 -  feature is checked out by this process.</dl><h4>Error Returns</h4>
<dl><dt>LM_CANTCONNECT<dd><dd>Feature was checked out, but lost connection to the 
daemon.<dt>LM_FEATQUEUE<dd>This process is in the queue for this feature.<a name="_IX_200"></a><dt>LM_NEVERCHECKOUT<dd><dd><dd><dt><dd>Feature was never checked out by this process, or was 
checked back in after a checkout.</dl><h4>See also</h4>
<ul><li><a href="#65026: 2head: 3.3.5 lc_checkout">Section 4.7, `lc_checkout,' on page 29</a></ul><a name="64942: 2head: 3.3.36 lc_userlist"></a><a name="_IX_201"></a><a name="4.32"></a><h2>4.32  lc_userlist</h2>
<h4>Syntax</h4>
<pre>LM_USERS *users;</pre>
<pre>users = lc_userlist(job, feature)</pre>
<h4>Description</h4>
<p>
Provides a list of who is using the feature, including information about the users of the 
license. This is used by 
<TT><a name="_IX_202"></a>lmstat -a</TT>.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(char *) 
<I>feature</I><dd>The feature name.</dl><p><hr>
Note:	<I>lc_userlist()</I> is a potentially `expensive' call (it may cause a lot of network traffic), 
depending on the number of users of 
<I>feature</I>. Therefore this call must be used with 
caution. In particular, it is a good idea to call 
<I>lc_userlist()</I> when a checkout fails with 
LM_MAXUSERS/LM_USERSQUEUED error, to inform who is using the feature. 
However, 
<I>do not call lc_userlist() before every checkout call</I>, since this will be 
guaranteed to cause network load problems when a large number of licenses are 
checked out.<hr><p>
<h4>Return 
</h4>
<p>
If successful, 
lc_userlist() returns a pointer to a linked list of structures, one for each 
user of the license. (This data should not be modified by the caller. It will be freed on 
the next call to 
lc_userlist()). 
<p>
<p>
See 
<TT>lmclient.h</TT> for a description of the LM_USERS structure.<p>
<p>
The list of users returned by 
lc_userlist() includes a special record, indicated by an 
empty username (name[0]==0), which contains the total number of licenses supported 
by the daemon for the specified feature (in the 
nlic field), and the daemon's idea of the 
current time (in the 
time field). 
<p>
<p>
If there is an error, 
lc_userlist() returns NULL and sets the variable job-&gt;lm_errno with 
the error code. 
<p>
<p>
lc_userlist() 
only returns information about users the server knows about, therefore it 
will not return any information about users of node-locked uncounted, or DEMO 
licenses, unless the server's license file includes the node-locked licenses and the client 
is not reading the license file (via @host, port@host or USE_SERVER).<p>
<p>
Reserved licenses are indicated by the 
<a name="_IX_203"></a>lm_isres() macro (defined in 
<TT>lmclient.h</TT>). In this 
case, the `name' contains the entity that the reservation is for.<p>
<h4>Error Returns</h4>
<dl><dt>LM_BADCOMM<dd>Communications error with license server.<dt>LM_CANTMALLOC<dd>malloc() call failed.<dt>LM_FUNCNOTAVAIL<dd>Vendor keys do not support this function.<dt>LM_NOFEATURE<dd>Specified feature cannot be found.</dl><h4>See also</h4>
<ul><li><TT>lmclient.h</TT> for 
<TT>LM_USER</TT> structure definition.</ul><a name="40445: 2head: 3.3.41 lc_vsend"></a><a name="_IX_204"></a><a name="4.33"></a><h2>4.33  lc_vsend</h2>
<h4>Syntax</h4>
<pre>rcv_str = lc_vsend(job, send_str)</pre>
<h4>Description</h4>
<p>
Sends a message to the vendor daemon and returns a result string. If the client is not 
already connected to a server, this function will connect to the first server in the first 
license file in its list. The string can be up to 140 bytes.<p>
<p>
You must set up a processing routine in your vendor daemon to receive the message 
from 
lc_vsend() and send the reply. This routine is specified in 
<TT><a name="_IX_205"></a>lsvendor.c 
</TT>in the 
variable 
<I><a name="_IX_206"></a>ls_vendor_msg</I>.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(char *) 
<I>send_str</I><dd>String to be send to your vendor daemon.</dl><h4>Return</h4>
<dl><dt>(char *) 
<I>rcv_str</I><dd>String returned by 
ls_vendor_msg() in your 
vendor daemon.<dt>(char *) NULL<dd><dd>if unsuccessful.</dl><h4>Error Returns</h4>
<dl><dt>LM_BADCOMM<dd>Communications problem with the vendor daemon.<dt>LM_CANTREAD<dd>Cannot read data from license server.<a name="_IX_207"></a><dt>LM_NOFILEVSEND<dd>Communications protocol does not support this function.<dt>LM_NOSERVSUPP<dd>Your vendor daemon does not support this function.</dl><h4>See also</h4>
<ul><li><a href="#73612: 2head: 6.3.24 ls_vendor_msg">Section 8.3.27, `ls_vendor_msg,' on page 133</a></ul><a name="4.34"></a><h2>4.34  Rarely used functions</h2>
<p>
The following functions are more rarely needed, and many exist only for compatibility 
with earlier 
FLEXlm<I></I> versions. They should be used with care, and questions are 
welcomed before their use.<p>
<h3>4.34.1	 <a name="_IX_208"></a>lc_baddate</h3>
<p>
Obsolete and no longer needed. This check is now automatically performed when 
appropriate.<p>
<h4>See also</h4>
<ul><li><a href="#36879: 1Head: 5.2 LM_A_CHECK_BADDATE">Section 5.2, `LM_A_CHECK_BADDATE,' on page 72</a><li><a href="#13656: 2Head: 8.3.3 ls_a_check_baddate">Section 8.3.3, `ls_a_check_baddate,' on page 128</a></ul><h3>4.34.2	 l<a name="_IX_209"></a>c_ck_feats</h3>
<h4>Syntax</h4>
<pre>stat = lc_ck_feats(job, vendor)</pre>
<h4>Description</h4>
<p>
Checks the 
<a name="_IX_210"></a>FEATURESET line for a given vendor. 
<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(char *) 
<I>vendor</I><dd>The vendor to be checked.</dl><h4>Return</h4>
<dl><dt>(int) 
<I>stat</I><dd>Status of the FEATURESET line: 1 if OK, 0 if bad.</dl><h4>Error Returns</h4>
<dl><a name="_IX_211"></a><dt>LM_NOFEATSET<dd>No FEATURESET line found for this vendor.<a name="_IX_212"></a><dt>LM_CANTCOMPUTEFEATSET
Cannot compute FEATURESET code for this vendor.<a name="_IX_213"></a><dt>LM_BADFEATSET<dd>The code on the FEATURESET line is incorrect.<a name="_IX_214"></a><dt>LM_FUNCNOTAVAIL<dd>Vendorkeys do not support FEATURESET.</dl><h4>See also</h4>
<ul><li><a href="#13021: 2head: 6.3.20 ls_use_featset">Section 8.3.23, `ls_use_featset,' on page 132</a><li><a href="#69035: 2head: 8.1.5 FEATURESET Line">Section 6.3.7, `FEATURESET Line,' on page 105</a><li><a href="#38172: 1Head: 3.7 Multiple Jobs">Section 3.5, `Multiple Jobs,' on page 19</a></ul><h3>4.34.3	 <a name="_IX_215"></a>lc_copy_hostid</h3>
<h4>Syntax</h4>
<pre>copy = lc_copy_hostid(job, orig)</pre>
<h4>Description</h4>
<p>
Returns a copy of a hostid list, and allocates memory as necessary. Using lc_hostid(), 
this function should not be needed.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job()</I><dt>(HOSTID *) 
<I>orig</I><dd>Hostid list to be copied.</dl><h4>Return</h4>
<dl><dt>(HOSTID *) 
<I>copy</I><dd>Copy of 
<I>orig</I>, or 0 upon failure. Memory was allocated as 
needed.</dl><h4>Error Returns</h4>
<dl><dt>LM_CANTMALLOC<dd>Out of memory.</dl><h4>See also</h4>
<ul><li><a href="#39426: 1Head: 4.21 lc_free_hostid">Section 4.17, `lc_free_hostid,' on page 43</a></ul><h3>4.34.4	 <a name="_IX_216"></a>lc_crypt</h3>
<h4>Syntax</h4>
<a name="_IX_217"></a><pre>CONFIG conf;</pre>
<pre>char *sdate;</pre>
<pre>LM_CODE(code, ...)	</pre>
<pre>enc_code = lc_crypt(job, &amp;conf, sdate, &amp;vc);</pre>
<h4>Description</h4>
<p>
Computes the 
<a name="_IX_218"></a>license key for a 
FLEXlm<I></I> feature line. 
<I>lc_crypt()</I> is the older form of the 
FLEXlm<I></I> authentication routine - <I>lc_crypstr()</I> is now the preferred method.<p>
<p>
<I>lc_crypt() 
</I>takes its input parameters and creates the license key that appears in the 
license file. Vendors generally will not call 
<I>lc_crypt()</I> directly, unless they are writing 
a custom license generation program, in which case 
<I>lc_cryptstr()</I> is preferred. 
<p>
<p>
The CONFIG * parameter should be a pointer to a struct that has been correctly filled 
in. To do so, first make sure it is set to zeroes with 
<TT>memset(&amp;conf, 0, sizeof(conf))</TT>. Then 
fill in each item in the struct, using the definition as it appears in 
<TT>lmclient.h</TT>, and noting 
that many items are now optional, and do not need setting.<p>
<p>
The sdate parameter can be obtained by calling 
<I>l_bin_date()</I> with the date string, e.g.<p>
<pre>	l_bin_date("1-jan-1993");</pre>
</ol></ul><p>
To obtain the start date from a license file license key (The license key on the 
FEATURE line), use 
<I>l_extract_date()</I>:<p>
<pre>	char code[21];</pre>
<pre>	<a name="_IX_219"></a>l_extract_date(code);</pre>
</ol></ul><p>
The last argument (VENDORCODE *) must be set up as in the following example:<p>
<pre>	LM_CODE(code, ENCRYPTION_SEED1, ENCRYPTION_SEED2, VENDOR_KEY1,</pre>
<pre>	VENDOR_KEY2, VENDOR_KEY3, VENDOR_KEY4, VENDOR_KEY5);</pre>
<pre>	VENDORCODE vc;</pre>
<pre>	/*...*/</pre>
<pre>	memcpy((char *)&amp;vc, (char *)&amp;code, sizeof(vc));</pre>
<pre>	vc.data[0] ^= <a name="_IX_220"></a>VENDOR_KEY5;</pre>
<pre>	vc.data[1] ^= VENDOR_KEY5;</pre>
<pre>	lc_crypt(job, &amp;conf, l_bin_date(0), &amp;vc);</pre>
<p><hr>
Note:	This use of VENDOR_KEY5 is a security precaution taken mostly for dynamic 
linking environments.<hr><p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>FLEXlm<I></I> job, from 
<I>lc_new_job().</I><dt>(CONFIG *) 
<I>conf</I><dd>Filled-in CONFIG structure pointer.<dt>(char *) 
<I>sdate</I><dd>Start date, in coded format. See below.<dt>(<a name="_IX_221"></a>VENDORCODE *) 
<I>vc</I><dd>Vendor's encryption seeds (from lm_code.h), 
where the data[0] and data[1] members have been 
XORd (`^') with VENDOR_KEY5.</dl><h4>Return</h4>
<dl><dt>(char *) 
<I>enc_code</I><dd>The license key, which should match the license 
file.<dt>(char *) NULL<dd>Error.</dl><h4>Error Returns</h4>
<dl><dt>LM_CANTMALLOC<dd>malloc() call failed.<dt>LM_LGEN_VER<dd>Attempt to generate license with incompatible 
attributes for the specified version of 
FLEXlm<I></I>.<dt>LM_BADPARAM<dd>Parameters and job attributes are inconsistent.<dt>LM_BADDATE<dd>Invalid start date.</dl><p><hr>
Note:	<I>lc_cryptstr()</I> is the recommended function to generate license files. 
<hr><p>
<h4>	See Also</h4>
<a href="#33883: 2head: 3.4.8 lc_cryptstr"><p>
Section 4.10, `lc_cryptstr,' on page 36</a><p>
<h3>4.34.5	 <TT></TT><a name="_IX_222"></a>lc_disconn</h3>
<h4>Syntax</h4>
<pre>status = lc_disconn(job, flag)</pre>
<h4>Description</h4>
<p>
Drops the connection to the server. A count of `logical' connections is maintained and 
if other features are active the connection is maintained, unless 
<I>flag</I> is non-zero.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job()</I><dt>(int) 
<I>flag</I><dd>Non-zero to force disconnection.</dl><h4>Return</h4>
<dl><dt>(int) 
<I>status</I><dd>&lt;0 -&gt; error<dt><dd>== 0 -&gt; success<dt><dd>&gt; 0 -&gt; # of `logical' connections remaining.</dl><h3>4.34.6	 <a name="_IX_223"></a>lc_display, 
<a name="_IX_224"></a>lc_hostname, 
<a name="_IX_225"></a>lc_username</h3>
<h4>Syntax</h4>
<pre>lc_display(job, flag)</pre>
<pre>lc_hostname(job, flag)</pre>
<pre>lc_username(job, flag)</pre>
<h4>Description</h4>
<p>
Returns environment information about the current process.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job()</I><dt>(int) 
<I>flag</I><dd>0 - Return system's idea of value.
!= 0 - Return 
FLEXlm<I></I>'s idea of value.</dl><h4>Return</h4>
<dl><dt>(char *)<dd>Display name, host name, or user name.</dl><h3>4.34.7	 <a name="_IX_226"></a>lc_feat_set</h3>
<h4>Syntax</h4>
<pre>line = lc_feat_set(job, daemon, code, codes)</pre>
<h4>Description</h4>
<p>
Computes the 
<a name="_IX_227"></a>FEATURESET 
<I>code</I> for the specified 
<I>daemon</I>, if 
<I>codes</I> is NULL. If 
<I>codes</I> is a pointer to a char *, the pointer is set to an array of license keys for each 
FEATURE line for this 
<I>daemon</I>.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(char *) 
<I>daemon</I><dd>The daemon desired.<dt>(VENDORCODE *) 
<I>code</I> 
<dd>Vendor's encryption seeds from LM_CODE 
macro.<dt>(char **) 
<I>codes</I><dd>Concatenated license keys (returned). If a pointer 
to a char * is passed, this gets set to a string which 
is a concatenation of the license keys for each 
FEATURE line for this vendor daemon - to be 
used for calculating a checksum using your own 
checksum algorithm.</dl><h4>Return</h4>
<dl><dt>(char *) 
<I>line</I> 
<dd>The FEATURESET line for the license file, or 
NULL for error.</dl><h4>Error Returns</h4>
<dl><dt>LM_CANTMALLOC 
<dd>malloc() call failed.</dl><h4>See also</h4>
<ul><li><a href="#13021: 2head: 6.3.20 ls_use_featset">Section 8.3.23, `ls_use_featset,' on page 132</a><li><a href="#69035: 2head: 8.1.5 FEATURESET Line">Section 6.3.7, `FEATURESET Line,' on page 105</a></ul><h3>4.34.8	 <a name="_IX_228"></a><a name="16620: 2Head: 4.33.8 lc_get_errno"></a>lc_get_errno</h3>
<h4>Syntax</h4>
<pre>error = lc_get_errno(job)</pre>
<h4>Description</h4>
<p>
The most recently set 
FLEXlm<I></I> error is obtainable via l<I>c_get_errno(</I>). This can be used 
after any 
FLEXlm<I></I> function. lc_err_info is now recommended instead, since it includes 
full error information.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd><dd><dd>From 
<I>lc_new_job().</I></dl><h4>Return</h4>
<dl><dt>(int) 
<I>error</I><dd>See 
<TT>lmclient.h</TT>, 
<I>lm_lerr.h</I> and 
<I>lmerrors.h</I> for a list of 
possible 
FLEXlm<I></I> errors and associated English 
descriptions.</dl><h4>See also</h4>
<ul><li><a href="#37211: 2head: 3.3.11 lc_errstring">Section 4.11, `lc_err_info,' on page 38</a><li><a href="#68231: 2head: 3.3.32 lc_perror">Section 4.29, `lc_perror,' on page 52</a><li><TT>lmclient.h</TT></ul><h3>4.34.9	 l<a name="_IX_229"></a>c_get_feats</h3>
<h4>Syntax</h4>
<pre>fs_code = lc_get_feats(job, vendor)</pre>
<h4>Description</h4>
<p>
Gets the license key from the 
<a name="_IX_230"></a>FEATURESET line for the specified vendor.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(char *)<I> vendor</I><dd>The vendor name.</dl><h4>Return</h4>
<dl><dt>(char *) 
<I>fs_code</I><dd>The code from the FEATURESET line for this vendor.</dl><h4>Error Returns</h4>
<dl><dt>LM_NOFEATURE<dd>FEATURESET line for requested vendor cannot be found.</dl><h4>See also</h4>
<ul><li><a href="#69035: 2head: 8.1.5 FEATURESET Line">Section 6.3.7, `FEATURESET Line,' on page 105</a></ul><h3>4.34.10	 <a name="_IX_231"></a>lc_gethostid</h3>
<h4>Syntax</h4>
<pre>hid = lc_gethostid(job)</pre>
<h4>Description</h4>
<p>
lc_hostid() should normally be used instead.<p>
<p>
Returns the 
<a name="_IX_232"></a>hostid for the local host. 
lc_gethostid() is simply a call to 
lc_getid_type(default_hostid_type);<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I></dl><h4>Return</h4>
<dl><dt>(<a name="_IX_233"></a>HOSTID *) 
<I>hid</I><dd>A pointer to the hostid structure, filled in for the current 
host, or NULL on failure.</dl><p><hr>
Note:	The memory returned by 
<I>lc_getid_type</I> is shared by 
<I>lc_gethostid</I>, and both functions 
free this memory when called. Therefore, do not call 
<I>lc_getid_type</I>, and then 
<I>lc_gethostid</I>, and expect the first pointer to remain valid.<hr><p>
<h4>Error Returns</h4>
<dl><dt>LM_CANTFINDETHER<dd>Cannot find ethernet device. If this error is returned, a null 
HOSTID pointer will be returned. (Prior to v5, this was a 
NOHOSTID type, rather than a NULL pointer).</dl><h4>See also</h4>
<ul><li><TT>lmclient.h 
</TT>for the definition of the HOSTID struct</ul><h3>4.34.11	 lc_getid_type</h3>
<h4>Syntax</h4>
<pre>hid = lc_getid_type(job, idtype)</pre>
<h4>Description</h4>
<p>
lc_hostid() should normally be used instead.<p>
<p>
Returns the HOSTID of the specified type for the local host.<p>
<p><hr>
Note:	The memory returned by 
<I>lc_getid_type</I> is shared by 
<I>lc_gethostid</I>, and both functions 
free this memory when called. Therefore, do not call 
<I>lc_getid_type</I>, and then 
<I>lc_gethostid</I>, and expect the first pointer to remain valid.<hr><p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(int) 
<I>idtype</I><dd>The requested 
<a name="_IX_234"></a>hostid type (see 
<TT>lmclient.h</TT>). Types are:</dl><dl><a name="_IX_235"></a><dt>HOSTID_LONG<dd> Longword hostid, e.g., SUN<a name="_IX_236"></a><dt>HOSTID_ETHER<dd> Ethernet address, e.g., 
<a name="_IX_237"></a>VAX<a name="_IX_238"></a><dt>HOSTID_USER<dd> Username<a name="_IX_239"></a><dt>HOSTID_DISPLAY<dd> Display name<a name="_IX_240"></a><dt>HOSTID_HOSTNAME<dd> Node name<a name="_IX_241"></a><dt>HOSTID_ID_MODULE<dd> HP300 Id-Module hostid<a name="_IX_242"></a><dt>HOSTID_STRING<dd>string ID, MAX HOSTID_LEN, used for SCO<a name="_IX_243"></a><dt>HOSTID_FLEXID1_KEY<dd>FLEXid Dongle<a name="_IX_244"></a><dt>HOSTID_FLEXID2_KEY<dd>FLEXid Dongle<a name="_IX_245"></a><dt>HOSTID_FLEXID3_KEY<dd>FLEXid Dongle<a name="_IX_246"></a><dt>HOSTID_FLEXID4_KEY<dd>FLEXid Dongle<a name="_IX_247"></a><dt>HOSTID_DISK_SERIAL_NUM<dt><dd>Windows and NT disk serial number<a name="_IX_248"></a><dt>HOSTID_INTERNET<dd>Internet IP address<a name="_IX_249"></a><dt>HOSTID_SERNUM_ID<dd><a name="_IX_250"></a>ID=n hostid. idptr-&gt;id.string contains this hostid<a name="_IX_251"></a><dt>HOSTID_VENDOR<dd>Start of Vendor-defined hostid types<a name="_IX_252"></a><dt>HOSTID_INTEL32<dd>Intel Pentium III+ CPUID (v7.0d+), 32-bit format<a name="_IX_253"></a><dt>HOSTID_INTEL64<dd>Intel Pentium III+ CPUID (v7.0d+), 64-bit format<a name="_IX_254"></a><dt>HOSTID_INTEL96<dd>Intel Pentium III+ CPUID (v7.0d+), 96-bit format</dl><h4>Return</h4>
<dl><dt>(HOSTID *) 
<I>hid</I><dd>A pointer to the hostid structure, filled in for the current 
host, or NULL on failure. (See 
<TT>lmclient.h</TT> for the definition 
of the HOSTID struct).</dl><h4>Error Returns</h4>
<dl><dt>LM_CANTFINDETHER<dd>
Cannot find ethernet device.</dl><p><hr>
Note:	lc_getid_type() does NOT process either `<a name="_IX_255"></a>ANY' or `<a name="_IX_256"></a>DEMO' hostid types.<hr><p>
<h4>See also</h4>
<ul><li><TT>lmclient.h</TT> for definition of HOSTID struct<li><a href="#20049: 1head: 9.4 Special Hostids">Section 6.7, `Special Hostids,' on page 114</a></ul><h3>4.34.12	 <a name="_IX_257"></a>lc_hosttype</h3>
<h4>Syntax</h4>
<pre>htype = lc_hosttype(job, benchmark)</pre>
<h4>Description</h4>
<p>
Returns information about the local host.<p>
<p>
Some typical results when 
<I>benchmark</I> is set:<p>
<pre>	Dec Alphastation 400 4/233, Digital Unix v3: 2274</pre>
<pre>	Sun Sparcstation 2, OS 4.1.x: 245</pre>
<pre>	Intel 486/66, BSDI v2.x: 404</pre>
</ol></ul><p>
The number in the vendor_speed field is currently unused.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(int) 
<I>benchmark</I><dd>Controls whether the internal 
FLEXlm<I></I> benchmark is to be 
run. If benchmark is 0, no benchmark is run, otherwise the 
benchmark is run. The benchmark uses SIGVTALRM, and 
runs for approximately 0.5 seconds. If this interferes with 
your application, or if you do not use the benchmark result, 
then set benchmark to 0 when calling 
lc_hosttype().</dl><h4>Return</h4>
<dl><dt>(<a name="_IX_258"></a>HOSTTYPE *) 
<I>htype</I><dd>A pointer to the hosttype structure, filled in for the current 
host. If 
lc_hosttype() cannot determine the host type, it will 
return a pointer to a HOSTTYPE struct with a type of 
LM_UNKNOWN.</dl><h4>Error Returns</h4>
<dl><dt>LM_FUNCNOTAVAIL<dd>Vendor keys do not support this function.</dl><h3>4.34.13	 <a name="_IX_259"></a>lc_isadmin</h3>
<h4>Syntax</h4>
<pre>stat = lc_isadmin(job, user)</pre>
<h4>Description</h4>
<p>
Verifies that the specified user is a license administrator. A `<a name="_IX_260"></a>license administrator' is a 
member of the `<a name="_IX_261"></a>lmadmin' group. If there is no lmadmin group in the 
<TT>/etc/groups</TT> file, 
then anyone in group 0 is a license administrator.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
lc_new_job().<dt>(char *) 
<I>user</I><dd>Login name of user to test.</dl><h4>Return</h4>
<dl><dt>(int) 
<I>stat</I><dd>Indication of whether the user is an administrator: 0 if the 
user is not an administrator, &lt;&gt;0 if an administrator. 
Always returns 1 on 
<a name="_IX_262"></a>non-Unix systems.</dl><h4>See also</h4>
<ul><li><a href="#lmgrd">Section 7.1, `lmgrd - The License Daemon,' on page 123</a></ul><h3>4.34.14	 <a name="_IX_263"></a>lc_lic_where</h3>
<h4>Syntax</h4>
<pre>path = lc_lic_where(job)</pre>
<h4>Description</h4>
<p>
Returns pathname of 
FLEXlm<I></I> license file. This function does not support the license 
file list in the 
<a name="_IX_264"></a><TT>LM_LICENSE_FILE</TT> environment variable 
 -  it only reports on the first 
file in the list, or, if a feature was already checked out, the file that was used for the 
checkout. Use 
<TT>lc_get_attr(LM_A_LF_LIST,</TT><I>...</I><TT>)</TT> for the full list.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I></dl><h4>Return</h4>
<dl><dt>(char *) 
<I>path</I><dd>Path of the license file that 
FLEXlm<I></I> will use. 
<B>Note - </B><I>This 
returned string must not be modified by the caller.</I><dt>(char *)NULL<dd>No license file set.</dl><h4>See also</h4>
<dl><a href="#75080: 2head: 5.1.17 LM_A_LF_LIST"><dt>Section 5.13, `LM_A_LF_LIST,' on page 77</a></dl><h3>4.34.15	 <a name="_IX_265"></a>lc_master_list</h3>
<h4>Syntax</h4>
<pre>list = lc_master_list(job)</pre>
<h4>Description</h4>
<p>
Returns the list of server nodes.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I> 
<dd>From 
<I>lc_new_job().</I></dl><h4>Return</h4>
<dl><dt>(<a name="_IX_266"></a>LM_SERVER *) 
<I>list</I><dd>List of the server nodes. If NULL, error code is in 
<I>lc_get_errno().</I></dl><h4>Error Returns</h4>
<dl><a name="_IX_267"></a><dt>LM_NO_SERVER_IN_FILE<dt><dd>No SERVER lines in license file.<a name="_IX_268"></a><dt>LM_BADFILE<dd>Server hostname too long (&gt; MAX_HOSTNAME).</dl><h4>See also</h4>
<ul><li><TT>lmclient.h</TT> for the definition of 
<TT>LM_SERVER</TT> struct</ul><h3>4.34.16	 <a name="_IX_269"></a>lc_remove</h3>
<h4>Syntax</h4>
<pre>status = lc_remove(job, feature, user, host, display)</pre>
<h4>Description</h4>
<p>
Removes the specified user's license for 
<I>feature</I>. This is used by the 
<TT>lmremove</TT> 
command, and has the same restrictions regarding 
<TT><a name="_IX_270"></a>lmadmin</TT> group. 
<I>lc_remove</I> normally 
is only used when the client's system has had a hard crash, and the server does not 
detect the client node failure. If 
<I>lc_remove</I> is called on a healthy client, the license will 
be checked out again by the client with its next heartbeat.<p>
<p><hr>
Note:	If 
<TT>lmgrd</TT> is started with the 
<TT>-x lmremove</TT> flag, then 
<I>lc_remove</I> has no effect.<hr><p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(char *) 
<I>feature</I><dd>Remove the license for this feature.<dt>(char *) 
<I>user</I><dd>User name of license to remove.<dt>(char *) 
<I>host</I><dd>Host name of license to remove.<dt>(char *) 
<I>display</I><dd>Display name of license to remove.</dl><h4>Return</h4>
<dl><dt>(int) 
<I>status</I> 
<dd> 0 - OK,!=0, error status.</dl><h4>Error Returns</h4>
<dl><dt>LM_BADCOMM<dd>communications error.<dt>LM_BADPARAM<dd>no licenses issued to this 
<I>user.</I><dt>LM_CANTCONNECT<dd>Cannot connect to license server.<dt>LM_CANTREAD<dd>Cannot read from license server.<dt>LM_CANTWRITE<dd>Cannot write to license server.<dt>LM_NOFEATURE<dd>Feature not found in license file data.<a name="_IX_271"></a><dt>LM_NOTLICADMIN<dd>failed because user is not in 
<TT>lmadmin</TT> group.<a name="_IX_272"></a><dt>LM_REMOVETOOSOON<dt><dd>failed because ls_min_lmremove time has not elapsed.</dl><h4>See also</h4>
<ul><li><a href="#95659: 2head: 6.1.2 Privileged license administration commands">Section 7.1.6, `Privileged License Administration Commands,' on page 126</a><li><a href="#66148: 2head: 6.3.14 ls_min_lmremove">Section 8.3.17, `ls_min_lmremove,' on page 131</a><li><a href="#21737: 1Head: 4.22 lc_heartbeat">Section 4.22, `lc_heartbeat,' on page 46</a></ul><h3>4.34.17	 lc_set_errno</h3>
<h4>Syntax</h4>
<pre>lc_set_errno(job, error)</pre>
<h4>Description</h4>
<p>
The 
FLEXlm<I></I> error is settable via 
lc_set_errno(). This should not normally be used, 
since the error should be set by the 
FLEXlm<I></I> libraries. You may want to set the error to 
0 before calling a 
FLEXlm<I></I> function.<p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd><dd><dd>From 
<I>lc_new_job().</I><dt>(int) 
<I>error</I><dd>See 
<TT>lmclient.h</TT> for a list of possible 
FLEXlm<I></I> error codes.</dl><h4>Return</h4>
<dl><dt>(void) none</dl><h4>See also</h4>
<ul><li><a href="#37211: 2head: 3.3.11 lc_errstring">Section 4.11, `lc_err_info,' on page 38</a><li><a href="#68231: 2head: 3.3.32 lc_perror">Section 4.29, `lc_perror,' on page 52</a><li><a href="#16620: 2Head: 4.33.8 lc_get_errno">Section 4.34.8, `lc_get_errno,' on page 61</a><li><TT>lmclient.h</TT></ul><h3>4.34.18	 <a name="_IX_273"></a>lc_shutdown</h3>
<h4>Syntax</h4>
<pre>status = lc_shutdown(job, prompt, print)</pre>
<h4>Description</h4>
<dl><dt>Shuts down the 
FLEXlm<I></I> servers. This is used by 
<TT><a name="_IX_274"></a></TT><TT>lmdown</TT>.</dl><h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) job<dd>From 
<I>lc_new_job().</I><dt>(int) 
<I>prompt</I><dd> unused (as of v6).<dt>(int) 
<I>print</I><dd> unused (as of v6).</dl><h4>Return</h4>
<dl><dt>(int) 
<I>status</I><dd> 0 
 -  server not shut down; &lt;&gt; 0 
 -  server shut down.</dl><h4>Error Returns</h4>
<dl><dt>LM_FUNCNOTAVAIL<dd>Vendor keys do not support this function.<dt>LM_FUNCNOTAVAIL<dd>(VMS) - This function is not available with VMS.<a name="_IX_275"></a><dt>LM_NOTLICADMIN<dd>You are not an authorized license administrator.<dt>LM_CANTREAD<dd>Cannot read data from license server.</dl><h4>See also</h4>
<ul><li><a href="#95659: 2head: 6.1.2 Privileged license administration commands">Section 7.1.6, `Privileged License Administration Commands,' on page 126</a></ul><h3>4.34.19	 <TT></TT>lc_startup</h3>
<h4>Syntax</h4>
<pre>status = lc_startup (job, lmgrd_path, logfile, license_file)</pre>
<h4>Description</h4>
<p>
lc_startup() starts 
<TT>lmgrd</TT> from within your program. 
lc_startup() does not report the 
success of the 
<TT>lmgrd</TT> process. 
lc_startup() calls the appropriate 
<I>system() 
</I>call given its 
arguments, and is unable to detect success of the 
<I>system()</I> call, since the process is 
started in the background.<p>
<p><hr>
Note:	lc_startup() is available on 
Unix<I></I> systems only. 
lc_startup() works for non-redundant 
servers only, and only if the application is running on the license server node.<a name="_IX_276"></a><hr><p>
<h4>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I><dt>(char *) 
<I>lmgrd_path</I> 
<dd>The pathname to 
<TT>lmgrd</TT>.<dt>(char *) 
<I>logfile</I><dd>The daemon log file location. (Passing a NULL string or a 
NULL pointer will cause the Debug log file to go to stdout, 
which is probably not what you want.). If the first character 
is '+', then the logfile will be appended, if it exists. If the 
logfile does not exist, it will be created.<dt>(char *) 
<I>license_file</I><dd>The location of the license file (NULL for default).</dl><h4>Return</h4>
<dl><dt>(int) 
<I>status</I><dd>0 - lmgrd_path is NULL.<dt><dd>&lt;&gt; 0 - startup of 
<TT>lmgrd</TT> attempted. 
</dl><h3>4.34.20	 <a name="_IX_277"></a>lc_timer</h3>
<h4>Syntax</h4>
<pre>num_failed_attempts = lc_timer(job)</pre>
<h4>Description</h4>
<p>
This routine is called by vendors that cannot tolerate the use of interval timers by 
FLEXlm<I></I>. The purpose of 
<I>lc_timer</I> is twofold:<p>
<ul><li>Ensure the vendor daemon is continually running 
 -  otherwise an end-user may 
kill the license server when all licenses are in use, restart the server, and obtain 
unauthorized licenses.<li>Keep license server informed that the client is still using its license 
 -  otherwise 
the license-server may timeout the client, and drop its license.</ul><p>
If no 
FLEXlm<I></I> timers are used, then 
<I>lc_timer</I> must be called periodically. To avoid 
FLEXlm<I></I>'s use of timers, call 
<TT>lc_set_attr(<a name="_IX_278"></a>LM_A_CHECK_INTERVAL, -1)</TT>, and 
<TT>lc_set_attr(<a name="_IX_279"></a>LM_A_RETRY_INTERVAL, -1)</TT>.<p>
<p>
If the default timer is left installed<I>, 
</I>lc_timer() is called by the 
FLEXlm<I></I>-installed timer. 
lc_timer() also performs all the reconnection functions, so it is important to keep 
calling 
lc_timer(), even if your reconnection handler is called.<p>
<p>
lc_timer() will not do anything if it is called less than 20 seconds since it was last 
called. This prevents unnecessary networking delays, and no delays will occur because 
of 
<I>lc_timer</I>. Under certain circumstances, 
lc_timer() must be called often enough to 
avoid the application losing its license 
 -  the vendor daemon will time out clients due 
to either 
<a name="_IX_280"></a>UDP timeout or the end-user 
<TT><a name="_IX_281"></a>TIMEOUT</TT> option. The application must ensure 
that 
<TT><a name="_IX_282"></a>LM_A_UDP_TIMEOUT</TT>, 
<I><a name="_IX_283"></a>LM_A_TCP_TIMEOUT</I> and 
<I><a name="_IX_284"></a>ls_minimum_user_timeout</I> 
are large enough that the application will not inadvertently lose its license. In general, 
it is a good idea to call 
<I>lc_timer() 
</I>once every 5 minutes, although occasional lapses are 
relatively harmless.<p>
<h4><TT></TT>Parameters</h4>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>From 
<I>lc_new_job().</I></dl><h4>Return</h4>
<dl><dt><I>num_failed_attempts</I><dd>0 - success; Heartbeat messages exchanged with server
&gt;0 - failure; Number of failed attempts to contact the 
server.</dl><h4>See also</h4>
<ul><li><a href="#52105: 2head: 6.3.17 ls_minimum_user_timeout">Section 8.3.18, `ls_minimum_user_timeout,' on page 131</a><li><a href="#85076: 2head: 5.1.32 LM_A_UDP_TIMEOUT">Section 5.27, `LM_A_UDP_TIMEOUT,' on page 82</a><li><a href="#53814: 2head: 5.1.3 LM_A_CHECK_INTERVAL, LM_A_TIMER_TYPE">Section 5.3, `LM_A_CHECK_INTERVAL,' on page 73</a></ul><a name="Chapter 5"></a><hr><h1>Chapter 5 
<a name="Controlling Licensing Behavior Of Your Application"></a>Controlling Licensing Behavior Of Your Application With <a name="_IX_285"></a>lc_set_attr</h1>
<p>
The FLEXible API allows you to control the licensing behavior of your application 
with a set of 
<I>attributes</I>. 
FLEXlm<I></I> attributes allow you control over licensing policy, 
internal operations of 
FLEXlm<I></I> (e.g. use of timers, etc), and control of the licensing 
parameters of your process (e.g., define how 
FLEXlm<I></I> will define `username', 
`hostname', and `display name,' etc. for managed license distribution.).<p>
<p>
To set 
FLEXlm<I></I> attributes, use the 
<I>lc_set_attr</I> call, described in 
<a href="#43831: 2head: 3.3.30 lc_set_attr">Section 4.30, 
`lc_set_attr,' on page 53</a>.<p>
<p>
Essential FLEXible-API attributes, which should be set by every FLEXible API 
application, are:<p>
<ul><li>License file location:</ul>LM_A_LICENSE_DEFAULT<ul><li>Heartbeat security policy:</ul>LM_A_CHECK_INTERVALLM_A_RETRY_INTERVALLM_A_USER_RECONNECTLM_A_USER_RECONNECT_DONELM_A_USER_EXITCALL<ul><li>Performance:</ul>LM_A_RETRY_CHECKOUT<p>
The following attributes are often useful:<p>
<ul><li>Vendor-defined Hostid:</ul>LM_A_VENDOR_ID_DECLARELM_A_VENDOR_GETHOSTID<ul><li>Customized checkout:</ul>LM_A_CHECKOUTFILTERLM_A_CHECKOUT_DATA<ul><li>Information useful for error, or informational, reporting:</ul>LM_A_LF_LISTLM_A_VD_GENERIC_INFOLM_A_VD_FEATURE_INFO<ul><li>Disabling SIGALRM, for applications such as applications that use FORTRAN 
and XView, that cannot tolerate any use of SIGALRM:</ul>LM_A_SETITIMERLM_A_SIGNAL<p>
The other attributes are rarely needed, and are listed in 
<a href="#42591: AppTitle: Appendix F Additional lc_set_attr() Attributes">Appendix E, `Additional 
lc_set_attr() Attributes' on page 197</a>.<p>
<p>
The attributes are changed with 
lc_set_attr()<I> 
</I>and queried with<I> 
</I>lc_get_attr().<I> 
</I>The 
section heading is the attribute name. The first line of each section is the data type of 
the attribute. All attribute definitions are in 
<TT>lm_attr.h.</TT> 
<p>
<p>
When using these attributes with 
lc_set_attr(), the argument must be of the correct type 
(each item below lists its associated type), and must then be cast to 
<TT><a name="_IX_286"></a>LM_A_VAL_TYPE</TT>. 
When using them with 
<a name="_IX_287"></a>lc_get_attr(), the pointer argument should point to a value of 
the correct type (noting that short and int are different in this case), and must be cast to 
a (short *).<p>
<a name="16715: 1Head: 5.1 LM_A_BEHAVIOR_VER"></a><a name="5.1"></a><h2>5.1  LM_A_BEHAVIOR_VER</h2>
<h3>Type</h3>
<p>
char *<p>
<h3>Default</h3>
<p>
LM_BEHAVIOR_V6<p>
<p>
The overall behavior for all 
FLEXlm<I></I> components can easily be set in lm_code.h.<p>
<p>
Valid values are LM_BEHAVIOR_V<I>x</I>, where 
<B>x</B> is 2, 3, 4, 5 5_1 and 6.<p>
<p>
For the vendor daemon, in lsvendor.c, set:<p>
<p>
                char *ls_a_behavior_ver = LM_BEHAVIOR_VX;<p>
<a name="36879: 1Head: 5.2 LM_A_CHECK_BADDATE"></a><a name="5.2"></a><h2>5.2  LM_A_CHECK_BADDATE</h2>
<h3>Type</h3>
<p>
*int<p>
<h3>Default</h3>
<p>
False<p>
<p>
If True, and the license that authorizes the application has an expiration date, a check 
is made to see if the system date has been set back on the client node. If the checkout 
fails for this reason, the checkout error is LM_BADSYSDATE.<p>
<h4>See also</h4>
<ul><li><a href="#13656: 2Head: 8.3.3 ls_a_check_baddate">Section 8.3.3, `ls_a_check_baddate,' on page 128</a></ul><a name="53814: 2head: 5.1.3 LM_A_CHECK_INTERVAL, LM_A_TIMER_TYPE"></a><a name="_IX_288"></a><a name="_IX_289"></a><a name="_IX_290"></a><a name="5.3"></a><h2>5.3  LM_A_CHECK_INTERVAL</h2>
<h3>Type:</h3>
<p>
int<p>
<p>
<TT>LM_A_CHECK_INTERVAL</TT><I> 
</I>controls the client's detection of daemon failures. 
FLEXlm<I></I> client routines will install a 
<TT><a name="_IX_291"></a>SIGALRM</TT> handler or no handler at all, based on 
<TT>LM_A_CHECK_INTERVAL</TT>. The minimum value for 
<TT>LM_A_CHECK_INTERVAL</TT><I> 
</I>is 
30 seconds.<p>
<h3>Default</h3>
<p>
120 second interval.<p>
<p>
The results of possible settings of this variable are:<p>
<dl><b>Variable<B><dd></B>Setting<B><dd><dd></B>Result</b><dt><I>check_interval</I><dd>&lt; 0<dd>No 
<a name="_IX_292"></a>SIGALRM timer installed.<dt><I>check_interval</I><dd>&gt;= 0, &lt; 30<dd>Old interval unchanged.<dt><I>check_interval</I><dd>&gt;= 30<dd>Timer interval.<dt>The timer handler remembers any other handler that was installed, and calls the previously installed handler when it has checked the socket. If it is unacceptable to have handlers installed for either of these signals (or to have the intervals changed), then set 
check_interval &lt; 0. If you set check_interval &lt; 0, then no checking of the daemon will 
be done unless you call 
<I>lc_timer</I> periodically. You could, of course, do this from your 
own timer signal handler.</dl><h4>See also</h4>
<ul><li><a href="#21737: 1Head: 4.22 lc_heartbeat">Section 4.22, `lc_heartbeat,' on page 46</a><li><a href="#66148: 1head: 11.5 Communications Transport (TCP vs. UDP)">Chapter 11, `Communications Transport' on page 145</a><li><a href="#42045: 1Head: 5.11 LM_A_SETITIMER, LM_A_SIGNAL">Section 5.25, `LM_A_SETITIMER, LM_A_SIGNAL (Unix only),' on page 81</a></ul><a name="_IX_293"></a><a name="14252: 1Head: 6.5 LM_A_CHECKOUT_DATA"></a><a name="5.4"></a><h2>5.4  LM_A_CHECKOUT_DATA</h2>
<h3>Type</h3>
<p>
(char *)<p>
<p>
This option allows you to send some vendor-specific data to the vendor daemon in 
addition to the normal USER/HOST/DISPLAY data which is sent. This checkout data 
can be used to group duplicates in addition to the USER/HOST/DISPLAY by setting 
the 
<a name="_IX_294"></a><TT>LM_DUP_VENDOR</TT> bit in the duplicate grouping bitmask passed to 
<a name="_IX_295"></a>lc_checkout(). 
The checkout data can be modified before each individual 
lc_checkout()<I> or 
</I><a name="_IX_296"></a>lc_checkin()<I> 
</I>call. This makes it possible for a process to check out several different 
independent licenses (if 
<TT>LM_DUP_VENDOR</TT> is in the duplicate mask), and to checkin 
the licenses independently by setting the vendor-defined field each time before calling 
lc_checkin(). The vendor-defined data is a character string, with a maximum size of 
<TT><a name="_IX_297"></a>MAX_VENDOR_CHECKOUT_DATA</TT> bytes (32).<p>
<p>
You have the option in your vendor daemon of allowing this data to be visible or not. 
The daemon variable 
<I><a name="_IX_298"></a>ls_show_vendor_def</I> controls whether the vendor-defined field is 
visible to your end-users via 
<TT><a name="_IX_299"></a>lmstat</TT> (or any utility which calls 
<a name="_IX_300"></a>lc_userlist()).<p>
<p>
Each checkout or checkin request uses the value of the vendor-defined data from the 
last 
lc_set_attr() call. Checkins will only be performed for features on which the 
vendor-defined field matches.<p>
<h3>Default</h3>
<p>
None.<p>
<a name="_IX_301"></a><a name="32537: 1Head: 5.3 LM_A_CHECKOUTFILTER"></a><a name="5.5"></a><h2>5.5  LM_A_CHECKOUTFILTER</h2>
<h3>Type</h3>
<p>
Pointer to a function returning int.<p>
<p>
The checkout filter allows you to examine the FEATURE line which is going to be used 
in an 
<a name="_IX_302"></a>lc_checkout() request, and either allow the checkout to proceed or reject this 
particular FEATURE line. This filter function will be called with a pointer to the 
CONFIG struct which is about to be checked out. If this function returns 0, then 
checkout proceeds, otherwise if this function returns a non-zero value, then the 
checkout proceeds to the next available FEATURE line. If this function returns a non-zero value and sets the error obtainable from 
lc_get_errno(), then this value will be the 
return of 
lc_checkout(), otherwise, if 
<I>lc_get_errno</I>() is set to 0 by this function, the 
result of 
lc_checkout() would be 
<TT><a name="_IX_303"></a>LM_LOCALFILTER</TT> (assuming the checkout was not 
attempted on further FEATURE lines, or that another FEATURE line did not produce 
a 
<TT>LM_MAXUSERS/LM_USERSQUEUED</TT> result).<p>
<h3>Default</h3>
<p>
None.<p>
<p><hr>
Note:	Using CHECKOUTFILTER when the client is not reading the license file (via 
@host, port@host or USE_SERVER) requires the license server to pass each license 
to the client for verification. For this reason, CHECKOUTFILTER should be used 
with discretion.<hr><p>
<a name="22496: 1Head: 5.6 LM_A_CKOUT_INSTALL_LIC"></a><a name="5.6"></a><h2>5.6  LM_A_CKOUT_INSTALL_LIC</h2>
<h3>Type</h3>
<p>
Pint.<p>
<p>
By default, a successful checkout automatically updates the registry 
$VENDOR_LICENSE_FILE setting to include the license file location that was used 
for the checkout. This can be disabled by setting this attribute to 0.<p>
<h3>Default</h3>
<p>
None.<p>
<h4>See also</h4>
<ul><li><a href="#29206: 3Head: Registry and ~/.flexlmrc">Section , `Registry and ~/.flexlmrc,' on page 33</a></ul><a name="_IX_304"></a><a name="35603: 1Head: 6.12 LM_A_DISPLAY_OVERRIDE"></a><a name="5.7"></a><h2>5.7  LM_A_DISPLAY_OVERRIDE</h2>
<h3>Type</h3>
<p>
(char *)<p>
<p>
This string, if specified, will be used to override the display name as derived from the 
Unix<I></I> 
ttyname() system call.<p>
<p><hr>
Note:	This value cannot be changed for a job after the initial connection to the vendor 
daemon.<hr><p>
<h3>Default</h3>
<p>
No override of display name.<p>
<p>
The most common use of this attribute is for setting the display to the 
<a name="_IX_305"></a>X-Display name. 
Unfortunately, the only reliable way of obtaining the name of the X-Display is via an 
X call. Therefore, this can only be done by the X-based application, after 
<I><a name="_IX_306"></a>XOpenDisplay</I> (or 
<I><a name="_IX_307"></a>XtAppInitialize</I>) has been called.<p>
<p>
The correct Display name is available via the X macro<p>
<pre>                <a name="_IX_308"></a>DisplayString(&lt;display&gt;)</pre>
</ol></ul><p>
In addition, it is essential to note that there are at least three possible aliases for using 
the monitor attached to the computer in use: `<TT>localhost:0</TT>', `<TT>unix:0</TT>' and `<TT>:0</TT>'. If any 
of these are used, the 
<I>lc_set_attr(LM_A_DISPLAY_OVERRIDE) 
</I>should use the result 
of 
<a name="_IX_309"></a>gethostname() instead. Finally, it may be safest to use the IP address as a string, to 
avoid the problem of aliases for a particular display host.<p>
<p>
The following example code can be used for this purpose:<p>
<pre>/* 
 * assume XOpenDisplay or XtAppInitialize has already been called 
 */
#include &lt;netdb.h&gt;
char display_name[50], *cp, display_ip[9];
struct hostent *he;
/*...*/
strncpy(display_name, DisplayString(display), 49);
if (!(strncmp(display_name, ":0", 2)) ||
                        !(strncmp(display_name, "unix:0", 6)) ||
                        !(strncmp(display_name, "localhost:0", 12)))
{
  static char d[50];
	gethostname(d, 47);
	if (*d)
	{
		strcat(d, ":0");
		display_name = d;
	}
}
he = gethostbyname(display_name)
sprintf(display_ip, "%x", *((int *)he-&gt;h_addr));
lc_set_attr(LM_A_DISPLAY_OVERRIDE, display_ip);</pre>
<a name="_IX_310"></a><a name="5.8"></a><h2>5.8  LM_A_FLEXLOCK</h2>
<h3>Type:</h3>
<p>
int<p>
<p>
Turns on FLEXlock capability. This must be enabled to use FLEXlock, but application 
security is poorer.<p>
<h3>Default</h3>
<p>
off.<p>
<p>
See the Programmers Guide for additional information on FLEXlock.<p>
<a name="_IX_311"></a><a name="5.9"></a><h2>5.9  LM_A_FLEXLOCK_INSTALL_ID</h2>
<h3>Type:</h3>
<p>
short *<p>
<p>
For additional security, each time that your application is installed, and the user 
activates the FLEXlock operation, a random id number is generated.  This number can 
be used to identify work done with your application in this mode.  If this number is 
saved in the work, and compared when accessing it, you may be able to  determine if 
your application has been re-installed.<p>
<p>
You can obtain this number by calling<p>
<pre>short code_id;
lc_get_attr(job, LM_A_FLEXLOCK_INSTALL_ID, (short *)&amp;code_id);</pre>
</ol></ul><p>
After the FLEXlock operation is activated, an entry is generated in the registry.  It is 
located at:<p>
<pre>HKEY_LOCAL_MACHINE-&gt;SOFTWARE-&gt;GLOBEtrotter Software Inc.-&gt;FLEXlock</pre>
</ol></ul><p>
A subkey for each feature is located inside the FLEXlock subkey and is a combination 
of the vendor name and the feature name.  If this subkey is deleted, the program will 
act as if you had never activated the FLEXlock functionality.  (Familiarity with the 
registry editor is necessary for testing FLEXlock enabled features.)<p>
<p>
See the Programmers Guide for additional information on FLEXlock.<p>
<a name="_IX_312"></a><a name="40191: 1Head: 6.15 LM_A_HOST_OVERRIDE"></a><a name="5.10"></a><h2>5.10  LM_A_HOST_OVERRIDE</h2>
<h3>Type:</h3>
<p>
(char *)<p>
<p>
This string, if specified, will be used to override the hostname as derived from the 
Unix<I></I> 
<I><a name="_IX_313"></a>gethostname()</I> system call.<p>
<p><hr>
Note:	This value cannot be changed for a job after the initial connection to the vendor 
daemon.<hr><p>
<h3>Default</h3>
<p>
No override of host name.<p>
<a name="_IX_314"></a><a name="5.11"></a><h2>5.11  LM_A_LCM</h2>
<h3>Type:</h3>
<p>
int<p>
<p>
Used to turn off LCM. 
<p>
<h3>Default</h3>
<p>
True<p>
<p><hr>
Note:	LCM is only available on Windows.<hr><p>
<a name="_IX_315"></a><a name="5.12"></a><h2>5.12  LM_A_LCM_URL</h2>
<h3>Type:</h3>
<p>
(char *)<p>
<p>
Used to override the LCM URL default:<p>
<pre>lc_set_attr(job, LM_A_LCM_URL, 
		(LM_A_VAL_TYPE)"www.mycompany.com/licenses");</pre>
<h3>Default</h3>
<p>
www.globetrotter.com/<I>vendorname</I>, where<I> vendorname 
</I>is your vendor 
daemon name.<p>
<p>
See the Programmers Guide for additional information on LCM.<p>
<p><hr>
Note:	LCM is only available on Windows.<hr><p>
<a name="_IX_316"></a><a name="75080: 2head: 5.1.17 LM_A_LF_LIST"></a><a name="5.13"></a><h2>5.13  LM_A_LF_LIST</h2>
<h3>Type</h3>
<p>
pointer to (char **)<p>
<p>
List of all license files searched for features. Useful for failure messages for debugging. 
Note that 
lc_lic_where() only prints one file, the one last searched. For example:<p>
<pre>	#include "lm_attr.h"
	/*...*/
	char **cp;
	lc_get_attr(job, LM_A_LF_LIST, (LM_A_VAL_TYPE)&amp;cp);
	if (cp)
	{
		puts("files searched are: ");
		while (*cp)
			printf("\t%s\n",*cp++);
	}</pre>
<a name="28127: 1Head: 5.8 LM_A_LICENSE_CASE_SENSITIVE"></a><a name="_IX_317"></a><a name="5.14"></a><h2>5.14  LM_A_LICENSE_CASE_SENSITIVE</h2>
<h3>Type</h3>
<p>
int<p>
<h3>Default</h3>
<p>
false<p>
<p>
If true, the license file is case-sensitive. Before v6, license files were largely case-sensitive. The default is strongly recommended, and makes end-user usage much 
easier. This should be set to true to generate license files compatible with older versions 
of 
FLEXlm<I></I>. This attribute is automatically turned on by setting 
<a name="_IX_318"></a>LM_VER_BEHAVIOR in lm_code.h to LM_BEHAVIOR_V5_1 or less.<p>
<a name="12939: 1Head: 9.18 LM_A_LICENSE_DEFAULT"></a><a name="_IX_319"></a><a name="5.15"></a><h2>5.15  LM_A_LICENSE_DEFAULT</h2>
<h3>Type</h3>
<p>
(char *)<p>
<p>
The default license file location. We recommend that this be set to the default location 
in your distribution hierarchy. If LM_A_LICENSE_DEFAULT is set, 
FLEXlm<I></I> still 
honors the $VENDOR_LICENSE_FILE and $<a name="_IX_320"></a>LM_LICENSE_FILE environment 
variables first.<p>
<p><hr>
Note:	It is strongly recommended that this attribute be set for all applications.<hr><p>
<a name="51599: 2head: 5.1.20 LM_A_LINGER"></a><a name="_IX_321"></a><a name="5.16"></a><h2>5.16  LM_A_LICENSE_FMT_VER</h2>
<h3>Type</h3>
<p>
(char *)<p>
<p>
Licenses generated by 
<I>lc_cryptstr()</I> will be compatible with the version specified. 
Valid arguments are LM_BEHAVIOR_V<I>n</I>, where 
<I>n</I> is 2, 3, 4, 5, 5_1, or 6. Note that 
this is not automatically set by LM_BEHAVIOR_VER in lm_code.h. If the license 
compatible with the desired version cannot be generated:<p>
<ul><li>the error LM_LGEN_VER (-94) will be generated: `Attempt to generate license 
with incompatible attributes'.<li>The feature line will be left as is, without replacing the 
<a name="_IX_322"></a>license key with a correct 
one.</ul><h4>See Also</h4>
<ul><li><a href="#33883: 2head: 3.4.8 lc_cryptstr">Section 4.10, `lc_cryptstr,' on page 36</a></ul><a name="_IX_323"></a><a name="5.17"></a><h2>5.17  LM_A_LINGER</h2>
<p>
Type: long<p>
<p>
This option controls the license linger time for your application. Any checkout 
performed after setting 
<a name="_IX_324"></a>LINGER to a non-zero value will cause the license to be held 
by the vendor daemon for the specified number of seconds after either a checkin or 
your process exits. The vendor daemon only checks for lingering licenses once per 
minute, which will limit the granularity of this setting.<p>
<h3>Default</h3>
<p>
0 (No linger).<p>
<h4>See Also</h4>
<ul><li><a href="#35324: 1Head: 3.5 Lingering Licenses">Section 3.4, `Lingering Licenses,' on page 18</a><li><a href="#92354: 1head: 4.5 Vendor daemon support routines">Section 8.4, `Vendor Daemon Support Routines,' on page 135</a></ul><a name="_IX_325"></a><a name="19845: 1Head: 5.11 LM_A_LKEY_LONG"></a><a name="5.18"></a><h2>5.18  LM_A_LKEY_LONG</h2>
<h3>Type</h3>
<p>
int<p>
<h3>Default</h3>
<p>
false<p>
<p>
If true, license file 
<a name="_IX_326"></a>license keys will be long - 64-bit, and short keys will not be 
accepted. Also turns on start date in the license key (which can be turned on separately 
with LM_A_LKEY_START_DATE. If used, ls_a_lkey_long in lsvendor.c must also 
be set to 1. This attribute is automatically turned on by setting LM_VER_BEHAVIOR 
in lm_code.h to LM_BEHAVIOR_V5_1 or less.<p>
<h3>Default</h3>
<p>
<I>false.</I><p>
<a name="_IX_327"></a><a name="14771: 1Head: 5.12 LM_A_LKEY_START_DATE"></a><a name="5.19"></a><h2>5.19  LM_A_LKEY_START_DATE</h2>
<h3>Type</h3>
<p>
int<p>
<h3>Default</h3>
<p>
false<p>
<p>
If true, license keys will contain start dates, and will automatically turn on 
LM_A_LKEY_LONG, so that license keys will be 20 hex characters long. Useful for 
generating licenses in pre-v6 format. This attribute is automatically turned on by 
setting LM_VER_BEHAVIOR in lm_code.h to LM_BEHAVIOR_V5_1 or less.<p>
<a name="_IX_328"></a><a name="5.20"></a><h2>5.20  LM_A_LONG_ERRMSG</h2>
<h3>Type</h3>
<p>
int<p>
<h3>Default</h3>
<p>
true<p>
<p>
The default is long error messages. Error messages can be presented in a long, more 
descriptive format. The new format contains embedded newline characters, which 
some applications may not be able to handle, or may need special handling.<p>
<p>
Applications will often find it useful to present the short error message first, and then 
long error message upon user request. This can be done thus:<p>
<pre>	lc_set_attr(job, LM_A_LONG_ERRMSG, (LM_A_VAL_TYPE)0);
	....
	/*error occurs*/
	lc_perror(job);
	/* user requests long error message */
	lc_set_attr(job, LM_A_LONG_ERRMSG, (LM_A_VAL_TYPE)1);
	lc_perror(job);</pre>
</ol></ul><p>
Note that this only works if another 
FLEXlm<I></I> error doesn't occur in between, which 
would change the error condition and message. Not all error conditions have long 
explanations or context-sensitive information. 
<p>
<p>
Example:<p>
<pre>        Invalid host
	 The hostid of this system does not match the hostid
	 specified in the license file</pre>
<pre>	Hostid:        12345678
	License path:  ./file1.lic:./file2.lic:./file3.lic
	FLEXlm error:  -9,9</pre>
</ol></ul><p>
The format is:<p>
<pre>        short-error-description
	optional-long-explanation [1-3 lines]
	optional-context-information
	License path:   path1:...:pathn
	FLEXlm error:   major, minor</pre>
</ol></ul><p>
This attribute is automatically turned off by setting LM_VER_BEHAVIOR in 
lm_code.h to LM_BEHAVIOR_V5_1 or less.<p>
<a name="_IX_329"></a><a name="5.21"></a><h2>5.21  LM_A_PERROR_MSGBOX (Windows only)</h2>
<h3>Type</h3>
<p>
int<p>
<p>
If true, lc_perror() presents the error message in an error message box. Also turned off 
when $FLEXLM_BATCH is set.<p>
<h3>Default</h3>
<p>
<I>True.</I><p>
<a name="_IX_330"></a><a name="5.22"></a><h2>5.22  LM_A_PROMPT_FOR_FILE (Windows only)</h2>
<h3>Type</h3>
<p>
int<p>
<p>
When true the user is prompted for the license file path or server name or IP-address if 
needed. Also turned off when $FLEXLM_BATCH is set.<p>
<h3>Default</h3>
<p>
<I>True.</I><p>
<a name="_IX_331"></a><a name="5.23"></a><h2>5.23  LM_A_RETRY_CHECKOUT</h2>
<h3>Type</h3>
<p>
int<p>
<p>
When true, checkouts that fail due to communications errors are automatically retried 
once. Often this second attempt will succeed on networks with poor communications. 
This is turned on by default in both the Simple and Trivial API, and the default is off 
in the FLEXible API. Use lc_set_attr(job, LM_A_RETRY_CHECKOUT, 
(LM_A_VAL_TYPE)1); to turn this attribute on for the FLEXible API 
(recommended). It's turned off by default in the FLEXible API so that previous default 
behavior is preserved.<p>
<h3>Default</h3>
<p>
<I>false 
</I><I>(for backward compatibility, but we recommend setting to 
</I><I>true</I><I>)</I><I>.</I><p>
<a name="25274: 2head: 5.1.27 LM_A_RETRY_COUNT, LM_A_RETRY_INTERVAL"></a><a name="_IX_332"></a><a name="_IX_333"></a><a name="5.24"></a><h2>5.24  <TT></TT>LM_A_RETRY_COUNT, LM_A_RETRY_INTERVAL</h2>
<h3>Type</h3>
<p>
int<p>
<p>
Together, 
<TT>LM_A_RETRY_COUNT</TT> and 
<TT>LM_A_RETRY_INTERVAL</TT><I> 
</I>are used for 
automatic reconnection to a daemon. Once daemon failure is detected, the client 
library routines will attempt to re-connect to a daemon. If reconnection fails, then the 
reconnect will be re-attempted 
<TT>LM_A_RETRY_COUNT</TT><I> 
</I>times at intervals of 
<TT>LM_A_RETRY_INTERVAL</TT>. This timing will be done with the same timer that detects 
the daemon's failure. If no 
FLEXlm<I></I> timers (SIGALRM) are desired, set 
<TT>LM_A_RETRY_INTERVAL</TT><I> 
</I>to a negative value. The minimum value for 
<TT>LM_A_RETRY_INTERVAL</TT><I> 
</I>is 30 seconds.<p>
<p>
The default for<I> 
</I><TT>LM_A_RETRY_COUNT</TT><I> 
</I>is 5;<I> 
</I>the default for 
<TT>LM_A_RETRY_INTERVAL</TT><I> 
</I>is 60. 
<p>
<p>
If LM_A_RETRY_COUNT is set to -1, the application will attempt retrying forever - for applications desiring a more lenient policy, this is recommended. In addition, on 
Windows, it is not legal to set LM_A_RETRY_COUNT to anything other than -1 
without also setting LM_A_USER_EXITCALL, since there is no default behavior for 
exiting a Windows application.<p>
<h4>See also</h4>
<ul><li><a href="#21737: 1Head: 4.22 lc_heartbeat">Section 4.22, `lc_heartbeat,' on page 46</a><li><a href="#53814: 2head: 5.1.3 LM_A_CHECK_INTERVAL, LM_A_TIMER_TYPE">Section 5.3, `LM_A_CHECK_INTERVAL,' on page 73</a></ul><a name="_IX_334"></a><a name="42045: 1Head: 5.11 LM_A_SETITIMER, LM_A_SIGNAL"></a><a name="_IX_335"></a><a name="5.25"></a><h2>5.25  LM_A_SETITIMER, LM_A_SIGNAL (Unix only)</h2>
<h3>Type</h3>
<p>
Pointer to a function returning void.<p>
<p>
This option allows you to replace 
<a name="_IX_336"></a>setitimer()<I> 
</I>with a routine of your choice. This might 
be done, for example, if your application is written in 
<a name="_IX_337"></a>FORTRAN on Unix, where use 
of SIGALRM is not allowed.<p>
<p>
To disable SIGALRM, create a function that does nothing. and use a pointer to this 
function as the setting for both these attributes.<p>
<pre>	null_func() {}</pre>
<pre>	/* ... */</pre>
<pre>	lc_set_attr(job, LM_A_SETITIMER, (LM_A_VAL_TYPE)null_func);</pre>
<pre> 	lc_set_attr(<a name="_IX_338"></a>job, LM_A_SIGNAL, (LM_A_VAL_TYPE)null_func);</pre>
<h3>Default</h3>
<p>
<I>setitimer() 
</I>and 
<I>signal()</I>.<p>
<a name="_IX_339"></a><a name="5.26"></a><h2>5.26  <TT></TT>LM_A_TCP_TIMEOUT</h2>
<h3>Type</h3>
<p>
int<p>
<p>
If a 
<a name="_IX_340"></a>TCP client node crashes or the client node is disconnected from the network, the 
license will be automatically checked back in LM_A_TCP_TIMEOUT seconds later. 
0 means no timeout.<p>
<h3>Default</h3>
<p>
2 hours (60*60*2).<p>
<h3>Maximum</h3>
<p>
4 hours 15 minutes (15300 seconds). 0 means no TCP timeout.<p>
<h4>See also</h4>
<ul><li><a href="#21737: 1Head: 4.22 lc_heartbeat">Section 4.22, `lc_heartbeat,' on page 46</a><li><a href="#66148: 1head: 11.5 Communications Transport (TCP vs. UDP)">Section Chapter 11, `Communications Transport,' on page 145</a></ul><a name="85076: 2head: 5.1.32 LM_A_UDP_TIMEOUT"></a><a name="_IX_341"></a><a name="5.27"></a><h2>5.27  <TT></TT>LM_A_UDP_TIMEOUT</h2>
<h3>Type</h3>
<p>
int<p>
<p>
This sets the amount of time (in seconds) during which a client must communicate with 
the vendor daemon for the 
<a name="_IX_342"></a>UDP communications transport. If the client does not 
communicate within this interval (by calling 
lc_timer()), then the vendor daemon will 
release the license just as if an 
<a name="_IX_343"></a>lc_checkin() call had been made.<p>
<h3>Default</h3>
<p>
45 minutes (2700).<p>
<h4>See also</h4>
<ul><li><a href="#21737: 1Head: 4.22 lc_heartbeat">Section 4.22, `lc_heartbeat,' on page 46</a><li><a href="#66148: 1head: 11.5 Communications Transport (TCP vs. UDP)">Section Chapter 11, `Communications Transport,' on page 145</a></ul><a name="_IX_344"></a><a name="26627: 2head: 5.1.34 LM_A_USER_EXITCALL"></a><a name="5.28"></a><h2>5.28  LM_A_USER_EXITCALL</h2>
<h3>Type</h3>
<p>
Pointer to a function returning int. Return value unused.<p>
<p>
The function pointer 
<TT>LM_A_USER_EXITCALL</TT> can be set to point to the routine that 
is to receive control if reconnection fails after 
<TT>LM_A_RETRY_COUNT</TT> attempts. If no 
routine is specified, then 
<I><a name="_IX_345"></a>lc_perror</I> is called, and the program will exit.   If the 
<TT>LM_A_USER_EXITCALL</TT> function returns control to its caller, program operation will 
continue as if no license had been checked out. The 
<TT>LM_A_USER_EXITCALL</TT> routine 
is called as follows:<p>
<pre><TT>(*exitcall)(</TT><I>feature</I><TT>)</TT></pre>
<h3>Default</h3>
<p>
No user exit handler (program exits).<p>
<p>
The<I> exitcall()</I> function will be called for 
<I>each feature</I> that the program had checked out, 
if that feature's license is lost. If the 
<I>exitcall()</I> function returns, it will be called again 
for the next feature. After it has been called for all features, control will return to the 
program at the point where detection of loss of licenses occurred.	<p>
<h4>See also</h4>
<ul><li><a name="_IX_346"></a><a href="#21737: 1Head: 4.22 lc_heartbeat">Section 4.22, `lc_heartbeat,' on page 46</a></ul><a name="_IX_347"></a><a name="37713: 1Head: 6.34 LM_A_USER_OVERRIDE"></a><a name="5.29"></a><h2>5.29  LM_A_USER_OVERRIDE</h2>
<h3>Type</h3>
<p>
(char *)<p>
<p>
This string, if specified, will be used to override the username as derived from the 
Unix<I></I> 
password file. On Windows, the username is set to the hostname, but can be overridden 
with this attribute.<p>
<p><hr>
Note:	This value cannot be changed after the initial connection to the vendor daemon.<hr><p>
<h3>Default</h3>
<p>
No override of username.<p>
<a name="_IX_348"></a><a name="_IX_349"></a><a name="_IX_350"></a><a name="32158: 2head: 5.1.36 LM_A_USER_RECONNECT"></a><a name="5.30"></a><h2>5.30  LM_A_USER_RECONNECT</h2>
<h3>Type:</h3>
<p>
Pointer to a function returning int. Return value unused.<p>
<p>
This reconnection routine is called each time just before a reconnection is attempted, 
either automatically as a result of the timer set by 
<a name="_IX_351"></a><TT>LM_A_CHECK_INTERVAL</TT>, or as a 
result of the application program calling 
<I><a name="_IX_352"></a>lc_timer</I>. 
<p>
<h3>Default</h3>
<p>
No user reconnection handler.<p>
<p>
The reconnection routine is called as follows:<p>
<pre>(*reconnect)(<I>feature</I>, <I>pass</I>, <I>total_attempts</I>, <I>interval</I>)</pre>
</ol></ul><p>
<p>
<dl><dt><TT>(char *) 
</TT><I>feature</I><TT><dd>Feature name.</TT><dt><TT>(int) 
</TT><I>pass</I><TT><dd>Current attempt #.</TT><dt><TT>(int) 
</TT><I>total_attempts</I><TT><dd>Maximum number of passes that will be attempted.</TT><dt><TT>(int) 
</TT><I>interval</I><TT><dd>Time in seconds between reconnection attempts.</TT></dl><p>
If 
<TT>LM_A_RETRY_COUNT</TT><I> 
</I>is set to a value &lt;=0, then the reconnect handler will not be 
called.<p>
<h4>See also 
</h4>
<ul><li><a href="#21737: 1Head: 4.22 lc_heartbeat">Section 4.22, `lc_heartbeat,' on page 46</a><li><a href="#53814: 2head: 5.1.3 LM_A_CHECK_INTERVAL, LM_A_TIMER_TYPE">Section 5.3, `LM_A_CHECK_INTERVAL,' on page 73</a></ul><a name="_IX_353"></a><a name="10195: 2head: 5.1.37 LM_A_USER_RECONNECT_DONE"></a><a name="5.31"></a><h2>5.31  LM_A_USER_RECONNECT_DONE</h2>
<h3>Type</h3>
<p>
Pointer to a function returning int. Return value unused.<p>
<p>
This function will be called when reconnection is successfully completed. 
<p>
<h3>Default</h3>
<p>
No user 
<I>reconnect_done</I> handler.<p>
<p>
The reconnection done handler is called as follows:<p>
<pre>(*reconnect_done)(<I>feature</I>, <I>tries</I>, <I>total_attempts</I>, <I>interval</I>)</pre>
</ol></ul><p>
<p>
<dl><dt>(char *) 
<I>feature</I><dd>feature name.<dt>(int) 
<I>tries</I> 
<dd>number of attempts that were required to re-connect for this 
feature.<dt>(int) 
<I>total_attempts</I><dd>maximum number of retry attempts that would be made.<dt>(int) 
<I>interval</I><dd>interval in seconds between reconnection attempts.</dl><a name="_IX_354"></a><a name="26661: 1Head: 5.18 LM_A_VD_GENERIC_INFO, LM_A_VD_FEATURE_INFO"></a><a name="_IX_355"></a><a name="5.32"></a><h2>5.32  LM_A_VD_GENERIC_INFO, LM_A_VD_FEATURE_INFO</h2>
<p>
<B>Type:</B> Pointer to 
<TT>LM_VD_GENERIC_INFO</TT> or pointer to 
<TT>LM_VD_FEATURE_INFO</TT><p>
<p>
Both attributes get information from your vendor daemon. 
<TT>LM_A_VD_GENERIC_INFO</TT> gets information which is not specific to a feature, and 
which is mostly found in 
<TT>lsvendor.c</TT>.<p>
<p>
<TT>LM_A_VD_FEATURE_INFO</TT> gets information about a particular feature, and provides 
an accurate count of licenses used, users queued, etc., and works correctly when a 
license file has more than one FEATURE or INCREMENT line for the same feature 
name. This will result in a LM_NOSERVSUPP error if the particular CONFIG struct 
has been merged with another CONFIG in the vendor daemon.<p>
<p>
These attributes will only work on your vendor daemon. If a request is made for a 
feature only served by a different vendor daemon, then 
the 
<TT><a name="_IX_356"></a>LM_NOADMINAPI 
</TT><TT>error 
results</TT>.<p>
<p>
A pointer to a struct is given as an argument to 
<I>lc_get_attr</I>, and upon successful return, 
this struct is filled with the appropriate information. The following example illustrates 
the use of both attributes:<p>
<pre>#include "lmclient.h"
#include "lm_code.h"
#include "lm_attr.h"
/* ... */
/* 
 * Print out GENERIC and FEATURE information for every
 * license file line for a given feature name
 */
void
vendor_daemon_info(job, feature)
LM_HANDLE *job; /* if you want to use lc_* functions instead */
char *feature;
{
  CONFIG *conf, *c;
  LM_VD_GENERIC_INFO gi;
  LM_VD_FEATURE_INFO fi;
  int first = 1;
		
	c = (CONFIG *)0; 

	for (conf = lc_next_conf(job, feature, &amp;c);conf; 
				conf=lc_next_conf(job, feature, &amp;c))
	{
		if (first)
		{
/* 
 * 			get generic daemon info
 */
			gi.feat = conf;
			if (lc_get_attr(job, LM_A_VD_GENERIC_INFO,
							(short *)&amp;gi))
			{
				lc_perror(job, "LM_A_VD_GENERIC_INFO");
			}
			else 
			{
				printf(" conn-timeout %d\n", 
						gi.conn_timeout);
				printf(" normal_hostid %d\n",
						gi.normal_hostid);
				printf(" minimum_user_timeout %d\n", 
					   	gi.minimum_user_timeout);
				printf(" min_lmremove %d\n", 
						gi.min_lmremove);
				printf(" use_featset %d\n", 
						gi.use_featset);
				printf(" dup_sel 0x%x\n", gi.dup_sel);
				printf(" use_all_feature_lines %d\n",
				    		gi.use_all_feature_lines);
				printf(" do_checkroot %d\n", 
						gi.do_checkroot);
				printf(" show_vendor_def %d\n", 
						gi.show_vendor_def);
			}
			first = 0;
		}
		fi.feat = conf;
		if (lc_get_attr(job, LM_A_VD_FEATURE_INFO, (short *)&amp;fi))
		{
			lc_perror(job, "LM_A_VD_FEATURE_INFO");
		}
		else
		{
/* 
 * 			get specific feature info
 */
		} printf("\nfeature s\n", conf-&gt;feature);
			printf("code %s\n", conf-&gt;code);
			printf("rev %d\n", fi.rev);
			printf("timeout %d\n", fi.timeout);
			printf("linger %d\n", fi.linger);
			printf("res %d\n", fi.res);
			printf("tot_lic_in_use %d\n",
				fi.tot_lic_in_use);
			printf("float_in_use %d\n", 
				fi.float_in_use);
			printf("user_cnt %d\n", fi.user_cnt);
			printf("num_lic %d\n", fi.num_lic);
			printf("queue_cnt %d\n", fi.queue_cnt);
			printf("overdraft %d\n", fi.overdraft
		}
	}</pre>
<h3>5.32.1	 Detecting 
<a name="_IX_357"></a>OVERDRAFT for 
<a name="_IX_358"></a>SUITEs</h3>
<p>
This is a special case for OVERDRAFT. With SUITEs, when you checkout a feature, 
you also silently checkout a token for the suite. Both the suite and feature token may 
be in the OVERDRAFT state, or only one, or neither. To detect suite overdraft, the code 
must get the parent/suite feature name, and then check for overdraft for this feature:<p>
<pre>	if ((conf-&gt;package_mask &amp; LM_LICENSE_PKG_COMPONENT)
		&amp;&amp; (conf-&gt;package_mask &amp; LM_LICENSE_PKG_SUITE))
	{
		fi.feat = conf-&gt;parent_feat;
		if (lc_get_attr(job, LM_A_VD_FEATURE_INFO, (short *)&amp;fi))
			lc_perror(job, "LM_A_VD_FEATURE_INFO");
		else
			printf("suite overdraft is %d\n", fi.overdraft);
	}</pre>
<a name="37404: 1Head: 6.38 LM_A_VENDOR_ID_DECLARE"></a><a name="_IX_359"></a><a name="5.33"></a><h2>5.33  LM_A_VENDOR_ID_DECLARE</h2>
<h3>Type</h3>
<p>
Pointer to 
<a name="_IX_360"></a>LM_VENDOR_HOSTID struct.<p>
<p>
This is for supporting vendor-defined hostid. The structure defines and declares the 
hostid to 
FLEXlm<I></I>.<p>
<h3>Default</h3>
<h4>None.</h4>
<h4>See also</h4>
<ul><li><a href="#66223: 1head: 9.5 Vendor-defined hostid">Section 6.8, `Vendor-defined hostid,' on page 115</a><li><TT>lmclient.h</TT> for LM_VENDOR_HOSTID definition.<li>examples/vendor_hostid directory</ul><a name="_IX_361"></a><a name="5.34"></a><h2>5.34  LM_A_VENDOR_GETHOSTID</h2>
<h3>Type</h3>
<p>
Pointer to function returning (HOSTID *).<p>
<p>
Obsolete. Use LM_A_VENDOR_ID_DECLARE instead. 
<p>
<p>
This function gets the hostid. It should call 
<I><a name="l_new_hostid"></a>l_new_hostid()</I> to get a pointer to a malloc'd 
HOSTID struct. The memory will be freed when no longer needed by 
FLEXlm<I></I>.<p>
<h3>Default</h3>
<h4>None.</h4>
<h4>See also</h4>
<ul><li><a href="#66223: 1head: 9.5 Vendor-defined hostid">Section 6.8, `Vendor-defined hostid,' on page 115</a><li><a href="#37404: 1Head: 6.38 LM_A_VENDOR_ID_DECLARE">Section 5.33, `LM_A_VENDOR_ID_DECLARE,' on page 86</a><li><TT>lmclient.h</TT> for HOSTID structure definition.</ul><a name="29254: 2head: 5.1.43 LM_A_VERSION"></a><a name="_IX_362"></a><a name="5.35"></a><h2>5.35  LM_A_VERSION and LM_A_REVISION</h2>
<h3>Type</h3>
<p>
short<p>
<p>
FLEXlm<I></I> version. Cannot be set. Only for use with 
lc_get_attr().<p>
<h3>Default</h3>
<p>
Version and revision of the libraries you have linked with.<p>
<a name="_IX_363"></a><a name="5.36"></a><h2>5.36  LM_A_WINDOWS_MODULE_HANDLE</h2>
<h3>Type</h3>
<p>
long<p>
<p>
This is only needed for a specific situation on Windows: You are building a DLL, and 
the 
FLEXlm<I></I> library (lmgr.lib) gets linked into your DLL. Or put another way, the 
FLEXlm<I></I> calls are not in a static binary, but only in a DLL. In this case, the DLL should 
make the following call before calling lc_checkout():<p>
<pre>	lc_set_attr(job, LM_A_WINDOWS_MODULE_HANDLE, 
		(LM_A_VAL_TYPE)GetModuleHandle(<I>dllname</I>));</pre>
</ol></ul><p>
where 
<I>dllname</I> is the name of the DLL. If this call is not made, windows dialogs and 
error messages do not work properly.<p>
<h3>Default</h3>
<p>
0<p>
<a name="Chapter 6"></a><hr><h1>Chapter 6 <a name="45129: ChapTitle: Chapter 9 The License File"></a>
License Models and the License File</h1>
<a name="Demo Licensing"></a><a name="6.1"></a><h2>6.1  Demo Licensing</h2>
<p>
There are many popular methods of handling demo licensing; this section discusses the 
most popular. However, many companies have unique needs, which may not be 
covered in this section.<p>
<h3>6.1.1	 Limited Time, Uncounted Demos</h3>
<p>
This is the most popular method. Advantages include:<p>
<ul><li>No special coding is required in the application<li>No license server is required<li>License installation is easy<li>License files are easy to distribute, since no end-user information is required.</ul><p>
The license file should look like:<p>
<pre>FEATURE f1 corp 1.0 1-jan-1999 uncounted AB0CC0C16807 HOSTID=DEMO ck=41</pre>
</ol></ul><p>
This indicates the expiration date and the fact that it's a demo license. The product is 
fully usable until January 1, 1999. FEATURE lines like this can be pre-printed with 
different expiration dates, and given to salespeople and distributors. For example, you 
may distribute the following file (the examples assume a vendor daemon named `corp' 
to avoid confusion):<p>
<pre>FEATURE f1 corp 1.0 1-jan-1998 uncounted AB1CC0916A06 HOSTID=DEMO ck=4
FEATURE f1 corp 1.0 1-feb-1998 uncounted ABDCC0116A06 HOSTID=DEMO ck=55
FEATURE f1 corp 1.0 1-mar-1998 uncounted BBDCA0D151ED HOSTID=DEMO ck=62
FEATURE f1 corp 1.0 1-apr-1998 uncoutned BBDCB0E155F1 HOSTID=DEMO ck=76
[...]</pre>
</ol></ul><p>
If the current date is February 1, 1998, then the salesperson would give an evaluator 
the third line, which expires in a month, March 1, 1998. The evaluator could simply 
save the FEATURE line in `license.dat' where the product was installed, and then the 
product will run for one month.<p>
<a name="_IX_364"></a><p>
PACKAGE can be used to make this even easier for multiple features. If a company 
ships features A through F, the company can initialize the license.dat file with:<p>
<pre>PACKAGE all corp 1.0 B0A0F011B491 COMPONENTS="A B C D E F"</pre>
</ol></ul><p>
Then appending a single demo FEATURE line can enable all these features:<p>
<pre>FEATURE all corp 1.0 1-jan-1998 uncounted AB1CC0916A06 HOSTID=DEMO ck=4</pre>
</ol></ul><p>
The FEATURE line must appear after the PACKAGE line to work correctly. 
<p>
<h3>6.1.2	 <a name="Limited Functionality Demos"></a>Limited Functionality Demos</h3>
<p>
FLEXlm<I></I> does do some security checks to prevent users from setting system dates back. 
However, for companies that are more concerned with security, it's a good idea to also 
disable some functionality. A classic example is a word processing program that alters 
saved files so that, when printed, the word `EVALUATION' is printed in large letters 
across every page. This allows evaluators full functionality, without reasonable utility.<p>
<p>
The application needs to detect that the HOSTID is DEMO for this type of evaluation, 
and 
<I><a name="lc_auth_data"></a>lc_auth_data()</I> is the correct function to use for this (not 
<I>lc_get_config()</I> or 
<I>lc_next_conf()</I>):<p>
<pre>CONFIG *conf;			/* outline of C source */
LM_HANDLE *job;

lc_new_job(...&amp;job);
rc = lc_checkout(job, feature ... );
if (rc) return rc; /* error handling */
conf = lc_auth_data(job, feature);
if (conf-&gt;idptr &amp;&amp; conf-&gt;idptr-&gt;type == HOSTID_DEMO)
	/* it's a demo license, disable some functionality... */</pre>
<h4>See also</h4>
<ul><li><a href="#79592: 2head: 9.1.3 FEATURE or INCREMENT Line">Section 6.3.4, `FEATURE or INCREMENT Line,' on page 96</a><li><a href="#PACKAGE">Section 6.3.6, `PACKAGE Line,' on page 103</a><li><a href="#20049: 1head: 9.4 Special Hostids">Section 6.7, `Special Hostids,' on page 114</a><li><a href="#60631: 2head: 3.3.2 lc_auth_data">Section 4.4, `lc_auth_data,' on page 27</a></ul><a name="_IX_365"></a><a name="_IX_366"></a><a name="_IX_367"></a><a name="6.2"></a><h2>6.2  Lenient Licensing: REPORTLOG and OVERDRAFT</h2>
<h3>6.2.1	 REPORTLOG</h3>
<p>
The REPORTLOG (which is enabled with 
<I>lmswitchr</I> and/or an end-user options file 
REPORTLOG entry) provides a relatively secure method of tracking end-user usage. 
More and more companies prefer licensing that does not deny usage. The 
REPORTLOG file can be used for billing customers for their usage. A common 
method for doing this is to provide a FEATURE line with an OVERDRAFT. 
OVERDRAFT usage is logged to the REPORTLOG file, which is then read by 
FLEXadmin<I></I>, from which an invoice can be generated. (FLEXadmin<I></I> is a separate 
product available from 
GLOBEtrotter Software<I></I>).<p>
<h4>Advantages</h4>
<p>
The advantages of this system include:<p>
<ul><li>The end-user is not denied usage during peak usage periods (within limits).<li>The vendor can gain additional revenue over traditional floating usage schemes.</ul><p>
A customer can limit their costs resulting from OVERDRAFT usage by including a 
<a name="_IX_368"></a>MAX_OVERDRAFT line in the options file.<p>
<h4>Limitations</h4>
<p>
The REPORTLOG file, while ASCII (so it can be easily e-mailed), is not human-readable. In addition, any modifications to the file are detected by 
FLEXadmin<I></I>. 
However, this does not mean that no tampering is possible. There are 3 conditions that 
must be considered:<p>
<p>
First, the customer may simply lose a file (either by accident or on purpose). Files are 
`ended' when a license server stops and starts, or an 
<TT>lmreread</TT> is performed. These 
sections can be lost without detecting a file modification, although the fact that a time 
period is missing 
<I>can</I> be detected. 
<p>
<p>
Second, a policy is needed for missing REPORTLOG periods. One example policy is: 
`More than 
<I>x 
</I>hours per month of missing REPORTLOG terminates the licensing 
contract.'<p>
<p>
Finally, a similar policy will be needed for files that have been altered.<p>
<h3>6.2.2	 OVERDRAFT detection</h3>
<p>
Applications may want to inform users when they're in overdraft state. This can be 
done with 
<I>lc_auth_data()</I> and 
<I>lc_get_attr</I>(... LM_A_VD_FEATINFO...). 
<I>lc_auth_data()</I> gives the CONFIG struct for the license that has been used for the 
checkout call, and LM_A_VD_FEATINFO returns that actual OVERDRAFT state in 
the server.<p>
<pre>CONFIG *conf;			/* outline of C source */
LM_HANDLE *job;
LM_VD_FEATURE_INFO fi;

if (rc = lc_new_job(...&amp;job)) return rc; /* error */
if (rc = lc_checkout(job, feature ... )) return rc; /* error */
if (!(fi.conf = = lc_auth_data(job, feature))) /* report error */;
else
{
	if (rc = lc_get_attr(job, LM_A_VD_FEATURE_INFO, (short *)&amp;fi))
		/* report this error */;
	else if (fc.lic_in_use &gt; fi.lic_avail - fi.overdraft)
	printf("%s Number of overdraft uses: %d\n", feature,
			fi.lic_in_use - (fi.lic_avail - fi.overdraft));</pre>
<pre>}</pre>
<h4>See also</h4>
<ul><li><a href="#79592: 2head: 9.1.3 FEATURE or INCREMENT Line">Section 6.3.4, `FEATURE or INCREMENT Line,' on page 96</a><li><a href="#26661: 1Head: 5.18 LM_A_VD_GENERIC_INFO, LM_A_VD_FEATURE_INFO">Section 5.32, `LM_A_VD_GENERIC_INFO, LM_A_VD_FEATURE_INFO,' 
on page 84</a></ul><a name="26348: 1Head: 10.1 Format of the License File"></a><a name="6.3"></a><h2>6.3  Format of the License File</h2>
<p>
Please refer first to the license file description in the 
FLEXlm Programmers Guide<I></I> 
 - especially the license file examples. This gives an overview of the license file. The 
following is a detailed description of every license file attribute. Most companies need 
only use a small portion of the capabilities of the license file.<p>
<p>
A license file consists of the following sections:<p>
<ol><li>Optional license server section, with information about node where the SERVER 
(or redundant SERVERs) are running, along with a list of all VENDOR daemon(s) 
that the SERVER needs to run. This section is required if any features are 
<I>counted</I>.<li>USE_SERVER section, indicating that client applications should not process 
anything except preceding SERVER lines in the license file, and should checkout 
the license directly from the server.<li>Features section, consisting of any combination of FEATURE, INCREMENT, 
UPGRADE or PACKAGE lines. This section is required.<li>Optional FEATURESET section, consisting of at most one FEATURESET line 
per VENDOR line in the file. This section is required for vendor daemons that use 
FEATURESET, but is rarely used or needed.<li>Comments. The convention is to begin comments with a '#' character. However, 
in practice all lines not beginning with a 
FLEXlm<I></I> reserved keyword are 
considered comments.</ol>
<p><hr>
Note:	See the 
FLEXlm Programmers Guide<I></I> for information on 
<TT>lmcrypt</TT> and 
<TT>makekey</TT>, the 
license generation utilities. Also see 
<a href="#33883: 2head: 3.4.8 lc_cryptstr">Section 4.10, `lc_cryptstr,' on page 36</a> for 
generating licenses with a C function call.<hr><p>
<p>
Vendors and license administrators will read the license file to understand how the 
licensing will behave: what features are licensed, for how many users, whether these 
features are node-locked, if the features are demo or regular, etc. The options are very 
broad for what can be specified in a license file.<p>
<p>
End-users often need to edit this file. Nearly all of the file is authenticated; if these 
portions are edited by the license administrator, a 
<TT>LM_BADCODE</TT> error will result. 
However, license administrators often must edit the license file for the following 
reasons:<p>
<ul><li>To change the 
<a name="_IX_369"></a>SERVER nodename<li>To change the (optional) SERVER TCP/IP 
<a name="_IX_370"></a>port address<li>To change the path to the vendor daemon</ul><p>
Any amount of white space can separate the components of license file lines, and the 
data can be entered via any text editor. Vendors can therefore distribute license data via 
<I>Fax</I> or telephone.<p>
<p>
Only five data items in the license file are editable by the end-user:<p>
<ul><li>hostnames on SERVER lines<li>(optional) port-numbers (TCP/IP) on SERVER lines<li>pathnames on VENDOR lines<li>options file pathnames on VENDOR lines<li>Decnet object numbers (VMS) or port numbers (Unix, Windows) on VENDOR 
lines</ul><p><hr>
Note:	The SERVER hostid(s) and everything on the FEATURE line (except the daemon 
name) is input to the authentication algorithm to generate the 
<a name="_IX_371"></a>license key for that 
FEATURE.<hr><p>
<h3>6.3.1	 <a name="_IX_372"></a><a name="53802: 2head: 10.1.1 SERVER Line"></a>SERVER Line</h3>
<p>
A SERVER line specifies the node on which a license server process can run. If a 
license file has three SERVER lines, then two of the three servers must be running in 
order for the licensing system to operate. The SERVER node name in the license file 
can be any network alias for the node.<p>
<pre>SERVER <I>nodename</I> <I>hostid [optional-port-number]</I></pre>
</ol></ul><p>
<p>
<dl><dt><I>nodename</I> 
<dd>string returned by the 
Unix<I></I> 
<TT>hostname</TT> or 
<TT>uname -n</TT> 
commands, or an IP address in ###.###.###.### format (v5 
or later). This can be edited by the license administrator. IP 
address is recommended for sites where NIS or DNS have 
trouble resolving a hostname, or if the server node has 
multiple network interfaces, and hence multiple 
hostnames.
`this_host' can be used when the hostname is unknown. 
This allows the product to be installed and start the servers. 
Clients on the same host as the server will work fine. 
Clients on other nodes will need to set 
LM_LICENSE_FILE or VENDOR_LICENSE_FILE to 
<I>port@host</I> or @<I>host</I> to find the license-server, or 
`this_host' can simply be edited to the real hostname. Note 
that lminstall and lc_convert() will automatically change 
`this_host' to the real hostname when appropriate.<dt><I>hostid</I><dd>string returned by the 
<TT>lmhostid</TT> command. (Case 
insensitive). Alternate special hostids can also be specified 
here, including 
<TT>ANY</TT>, 
<TT>HOSTNAME</TT>=<I>hostname</I>, etc. This can 
be a list of hostids; if so, the server will run on any of the 
hostids in the list. Hostid lists are space-separated, and 
enclosed in quotes, e.g.,
  "12345678 FLEXID=87654321 HOSTNAME=speedy".
Note that a hostid list on the SERVER line not supported.<dt><I>optional-port-number</I> 
<dd>TCP port number to use. This can be edited by the license 
administrator. If not specified, 
FLEXlm<I></I> will automatically 
use the next available port number in the range 27000-27009. Applications, when connecting to a server, try all 
numbers in the range 27000-27009. The port number is 
required if the license is a 3-server redundant license, or if 
the vendor daemon or clients are older than 
FLEXlm<I></I> 
version 6. Using a port number in the range 27000-27009 
is recommended when specifying a port number, since v6 
utilities and clients can then use 
<I>@host</I> to find the server.</dl>The SERVER line must apply to all lines in the license file. It is permitted to 
combine license files from different vendors, but this only works if the SERVER 
hostids are identical in all files that are to be combined.On 
VMS, the server node name can be entered with the trailing `::', if desired, as 
is the practice of many 
VMS system administrators.<h4>See also</h4>
<ul><li><a href="#42751: 1head: 9.3 Host Ids for FLEXlm Supported Machines">Section 6.6, `Hostids for FLEXlm Supported Machines,' on page 111</a><li><a href="#20049: 1head: 9.4 Special Hostids">Section 6.7, `Special Hostids,' on page 114</a></ul><h3>6.3.2	 <a name="_IX_373"></a>VENDOR Line<a name="_IX_374"></a></h3>
<p>
The VENDOR line specifies the name and location of a vendor daemon, as well as the 
location of the end-user's options file.<p>
<p><hr>
Note:	Previous to version 6, this was called a DAEMON line. DAEMON is still recognized, 
and DAEMON is required for lmgrds and vendor daemons older than version 6.<hr><p>
<h4>Unix<I></I> and Windows/NT Platforms Syntax</h4>
<pre><TT>VENDOR </TT><I>daemon-name</I><I> [</I><I>path]</I><I> </I>[<TT> [options=]</TT><I>options-file</I>] [[<TT>port=</TT>]<I>port-number</I>]</pre>
</ol></ul><p>
<p>
<dl><dt><I>daemon-name</I> 
<dd>Name of the daemon used to serve some feature(s) in the 
file.<dt><I>path</I><dd>Pathname to the executable code for this daemon. If blank, 
the $PATH environment variable, plus the current directory, 
is used by lmgrd to start the daemon process. Prior to 
version 6, this path field was required.<dt><I>options-file</I><dd>Pathname of the (optional) license administrator specified 
options file for this daemon.
If unspecified, the vendor daemon will also look for a file 
called 
<I>vendor</I>.opt (where vendor is the vendor daemon 
name) in the same directories where the license files were 
located. If found, this file is used for the end-user options 
file. This feature in new in v6, and older vendor daemons 
will not use 
<I>vendor</I>.opt.<dt><I>port-number</I><dd>Sites with Internet firewalls need to specify the port number 
the daemon uses. The default, if this 
<I>port-number</I> is not 
specified, is chosen by the system at run-time.</dl><h4>Example 
Unix<I></I></h4>
<pre>	VENDOR xyzd /etc/xyzd</pre>
<pre>	VENDOR xyzd /etc/xyzd /usr/local/flexlm/options/xyz.opts</pre>
<h4>Example 
<a name="_IX_375"></a>Windows/NT</h4>
<pre>	VENDOR xyzd c:\windows\system\xyzd.exe</pre>
<pre>	VENDOR xyzd c:\windows\system\xyzd.exe c:\opts\xyz.opts</pre>
<h4><a name="_IX_376"></a>VMS Platforms Syntax</h4>
<p>
The syntax for a DAEMON line on 
VMS is:<p>
<pre>DAEMON <I>daemon-name path</I><I> </I>[<I>object</I>] [<I>options_file</I>]</pre>
</ol></ul><p>
<p>
<dl><dt><I>object</I> 
<dd>DECnet object number: 0 - daemon uses object number 0, 
task name is `name' from the DAEMON line. 

128-255 - daemon uses this object number. [<B>Default</B>: 0]</dl><h4>Examples (VMS)</h4>
<pre>	DAEMON xyzd du:[xyz]xyzd.exe 200</pre>
<pre>	DAEMON xyzd du:[xyz]xyzd.exe 0 [xyz]xyz.opts</pre>
<p><hr>
Note:	If an options file is specified, the object number must be specified.<hr><p>
<h3>6.3.3	 <a name="USE_SERVER"></a>USE_SERVER line</h3>
<p>
USE_SERVER takes no arguments. It has no impact on the server. When the client sees 
a USE_SERVER line, it ignores everything except the preceding SERVER lines in the 
license file. Thus, the USE_SERVER line should be placed after all SERVER lines in 
the license file. In effect, USE_SERVER forces the application to behave as though 
LM_LICENSE_FILE were set to 
<I>port@host</I> or 
<I>@host</I>. The advantages to 
USE_SERVER are:<p>
<ul><li>The client's license file does not need to match the one the server uses.<li>The client's license file only requires SERVER and USE_SERVER lines.</ul><p>
For this reason, the USE_SERVER line is recommended.<p>
<h3>6.3.4	 <a name="79592: 2head: 9.1.3 FEATURE or INCREMENT Line"></a><a name="_IX_377"></a>FEATURE or 
<a name="_IX_378"></a>INCREMENT Line</h3>
<p>
A FEATURE line describes the license to use a product. An INCREMENT line can be 
used in place of a FEATURE line, as well as to add licenses to a prior FEATURE or 
INCREMENT line in the license file.<p>
<p>
If the vendor daemon has 
<I>ls_use_all_feature_lines</I> set in 
<I>lsvendor.c</I>, then 
FEATURE lines function as INCREMENT lines, and the behavior of a FEATURE line 
is unavailable to that application. 
GLOBEtrotter Software<I></I> STRONGLY discourages 
the use of 
<I>ls_use_all_feature_lines</I>.<p>
<p>
Only one FEATURE line for a given feature will be processed by the vendor daemon. 
If you want to have additional copies of the same feature (for example, to have multiple 
node-locked, counted features), then you must use multiple INCREMENT lines. 
INCREMENT lines form license groups, or 
<I>pools</I>, based on the feature name, version, 
node-lock hostid, USER_BASED, HOST_BASED, and CAPACITY. If 2 lines differ 
by any of these fields, they are counted separately in separate 
<I>pools</I>. A FEATURE line 
does not give an additional number of licenses, whereas an INCREMENT line 
ALWAYS gives an additional number of licenses.<p>
<p>
There are two formats for FEATURE; pre-v3.0 and current. The old format is still 
understood and correct with new clients and servers, but the new format is more 
flexible. The syntax of FEATURE and INCREMENT lines in 
FLEXlm<I></I> pre-v3.0 is:<p>
<pre>FEATURE|INCREMENT <I>name</I> <I>daemon</I> <I>version</I> <I>exp_date</I> <I>#lic key</I> \</pre>
<pre>"<I>vendor_string</I>" [<I>hostid</I>]</pre>
</ol></ul><p>
The current syntax of FEATURE and INCREMENT lines (FLEXlm<I></I> v6.1) is:<p>
<pre>FEATURE|INCREMENT <I>name</I> <I>daemon</I> <I>version</I> <I>exp_date</I> <I>#lic key [options...]</I></pre>
<dl><dt><I><a name="_IX_379"></a>name</I><dd>name given to the feature. Legal feature names in 
FLEXlm<I></I> 
must contain only letters, numbers, and underscore 
characters.<dt><I><a name="_IX_380"></a>vendor</I><dd>vendor -name from a VENDOR line. The specified vendor 
daemon serves this feature.<dt><I><a name="_IX_381"></a>version</I><dd>latest (highest-numbered) version of this feature that is 
supported. (floating point format, 10 character maximum).<dt><I><a name="_IX_382"></a>exp_date</I><dd>expiration date in the format: 

        {dd-mmm-yy[yy] | permanent}
For example, 22-mar-2000. For no expiration, use 
`permanent', or an expiration date with the year as 0, e.g., 
1-jan-0. 2-digit years are assumed to be 19<I>xx</I> and are valid 
up till 1999. For years 2000 and later, you 
<I>must</I> use 4 digits. 
1-jan-0 = 1-jan-00 = 1-jan-0000 = permanent. 
FLEXlm<I></I><I> 
fully supports dates beyond 
<a name="Year 2000"></a><a name="2000, year"></a>2000. 
</I><I>Prior to version 6, 
`permanent' was not supported</I><I>.</I><dt><I><a name="_IX_383"></a>#lic</I> 
<dd>number of licenses for this feature. Use `uncounted' or 0, 
for unlimited, node-locked licenses. Prior to version 6, the 
keyword `uncounted' was not recognized.<dt><I>key</I><dd><a name="_IX_384"></a>license key for this feature line. The key is produced by 
<I>lc_crypstr</I> in 
<TT>lmcrypt or makekey, 
</TT>or a vendor-defined 
routine. (Case insensitive). 
<dt><dd>The start date is encoded into the key; thus identical keys 
created with different start dates will be different. 
<dt><dd>The key field can be made case sensitive by calling 
</dl><pre>			lc_set_attr(<a name="_IX_385"></a><TT>LM_A_CRYPT_CASE_SENSITIVE</TT>, 1). </pre>
<dl><dt><dd>Remember to select the `case sensitive' option when 
building your daemon, if you use a case sensitive 
<a name="_IX_386"></a>license 
key comparison.<dt><I>`<a name="vendor-string"></a>vendor-string'</I> 
<dd>Vendor-defined string, enclosed in double quotes. This 
string can contain any characters except a quote. White 
space will be ignored when ciphering this string in the 
<I>key</I>. 
The application can retrieve this string by calling 
lc_auth_data(). In the pre-v3.0 format, this is required, 
although it can be empty. In v3.0+, it's optional.</dl><p>
The following fields are all optional, and must appear after all required fields, but can 
appear in any order. For optional fields, if the field 
<I>name</I> is lowercase, its value can be 
modified and the license will remain valid.<p>
<dl><a name="_IX_387"></a><dt>HOSTID=<I>hostid(s)</I><dd>Strings returned by 
<TT>lmhostid</TT>. Use if this feature is to be 
bound to a particular host or hosts, whether its use is 
counted or not. (Case insensitive). If the number of licenses 
is 0, then this field is required. If hostid is 
<a name="_IX_388"></a>DEMO, the 
license is valid on any system. If DEMO, the application 
can determine this is a demo license by calling 
lc_auth_data() and noting the hostid type. All other 
<I>special</I> 
hostids are supported: DEMO, INTERNET=<I>n.n.n.n</I>, etc. 
This can be a list of hostid in v5 or later using space-separator and quotes, e.g.,</dl><pre>			HOSTID="12345678 FLEXID=876321 HOSTNAME=joe"</pre>
<dl><dt><dd>If a list of hostids, the feature is granted if the client is on 
any one of the hostids in the list.<a name="CAPACITY"></a><dt>CAPACITY<dd>This is used in conjunction with the LM_A_CAPACITY 
attribute to lc_set_attr(), available in the FLEXible 
API.The most common purpose of CAPACITY is to charge 
more for a more powerful system. For example, with 
CAPACITY, you could automatically checkout more 
licenses on a Unix system than on a PC, thereby effectively 
charging more for the more powerful system. CAPACITY 
is a checkout multiplier 
 -  if 
<I>lc_checkout</I> requests 1 
license, and LM_A_CAPACITY is set to 3, 3 licenses will 
be checked out. CAPACITY is set by adding the 
CAPACITY keyword to the FEATURE line and setting 
LM_A_CAPACITY in the application with:</dl><pre>			lc_set_attr(job,LM_A_CAPACITY,(LM_A_VAL_TYPE)i);</pre>
<dl><dt><dd>If CAPACITY is missing from the FEATURE line, the 
attribute setting in the code will have no effect. Similarly, if 
CAPACITY is on the FEATURE line, but there is no call to 
<I>lc_set_attr</I>(...LM_A_CAPACITY), it will have no effect.<dt><dd>The attribute must be set before the first connection to the 
server (usually lc_checkout), and cannot be reset once set. 
If an INCREMENT appears where some licenses are 
CAPACITY and some are not, the vendor daemon tracks 
these in separate license pools.<a name="DUP_GROUP="></a><dt>DUP_GROUP=<I>...</I><dd>You can specify the Duplicate Grouping parameter in the 
license in 
FLEXlm<I></I> v4.0 or later. If DUP_GROUP is 
specified in the license, this parameter overrides the 
dup_group parameter in the 
lc_checkout() call. If not 
specified in the license, the dup_group parameter from 
lc_checkout() will be used. The syntax is:</dl><pre>			DUP_GROUP=NONE|SITE|[UHDV]</pre>
<pre>				U = DUP_USER</pre>
<pre>				H = DUP_HOST</pre>
<pre>				D = DUP_DISPLAY</pre>
<pre>				V = DUP_VENDOR_DEF</pre>
<dl><dt><dd>Any combination of UHDV is allowed, and the 
DUP_MASK is the OR of the combination. For example 
`DUP_GROUP=UHD' means the duplicate grouping is 
(DUP_USER | DUP_HOST | DUP_DISPLAY), so a user 
on the same host and display will have additional uses of a 
feature not consume additional licenses.<a name="HOST_BASED"></a><dt>HOST_BASED[=<I>n</I>]<dd>If HOST_BASED appears, then licenses can only be used 
by hosts INCLUDEd for this feature in the end-user options 
file. The purpose is to limit the use to a particular number 
of hosts, but allow the end-user to determine which hosts. 
If `=<I>n'</I> is specified, then the number of hosts which can be 
INCLUDEd is limited to 
<I>n</I>. Otherwise, the limit is the 
<I>#lic</I> 
field. If an INCREMENT appears where some licenses are 
HOST_BASED and some are not, the vendor daemon 
tracks these in separate license pools.<a name="ISSUED"></a><dt>ISSUED=<I>dd-mmm-yyyy<dd></I>Date issued. Can be used in conjunction with 
SUPERSEDE.<dt>I<a name="ISSUER='...'"></a>SSUER<I>='...'</I><dd>Issuer of the license.<a name="MINIMUM"></a><dt>MINIMUM=<I>n<dd></I>If in 
<I>lc_checkout</I>(...<I>nlic</I>...), 
<I>nlic</I> is less than 
<I>n</I>, then the 
server will checkout 
<I>n</I> licenses.<a name="NOTICE="></a><dt>N<a name="NOTICE='...'"></a>OTICE<I>='...'</I><dd>A field for intellectual property notices.<a name="OVERDRAFT="></a><dt>OVERDRAFT=<I>nnn</I><dd>The OVERDRAFT policy allows you to specify a number 
of additional licenses which your end user will be allowed 
to use, in addition to the licenses they have purchased. This 
is useful if you want to allow your customers to not be 
denied service when in a `temporary overdraft' state. 
Usage above the licensed limit will be reported by the 
FLEXadmin<I></I> reporting tool. In addition, you can determine 
if you are currently in an overdraft condition by calling 
<I>lc_get_attr(job, 
</I><I>LM_A_VD_FEATURE_INFO</I><I>, ...</I><TT>)</TT>. The 
returned structure has, among others, three members of 
interest: 
<I>lic_in_use</I>, 
<I>lic_avail</I>, and 
<I>overdraft</I>. If</dl><pre>			lic_in_use &gt; lic_avail - overdraft</pre>
<dl><dt><dd>then you are in an `overdraft state'.<a name="_IX_389"></a><dt>PLATFORMS='<I>plat1</I>...<I>platn</I>'
<a name="_IX_390"></a>This allows you to restrict usage to particular hardware 
platforms. The platforms are defined as the same platforms 
that are used to license 
FLEXlm<I></I> itself: sun4_u4, i86_n3, 
etc. The names can be found in the Platform Specific Notes 
section. Note that the platform name can be overridden 
with</dl><pre>			lc_set_attr(job, LM_A_PLATFORM_OVERRIDE,
				(LM_A_VAL_TYPE)str);</pre>
<dl><dt><dd>Note that the trailing digit in the platform name is ignored, 
and can be optionally left off in the name.<dt><dd>If the platform list differs in any way for 2 INCREMENT 
lines for the same feature-name, they're are pooled 
separately and counted separately.<dt><dd>Examples:</dl><pre>                        FEATURE f1 ... PLATFORMS=sun4_u4</pre>
<pre>                        INCREMENT f2 ... 1 PLATFORMS='i86_w alpha_u'</pre>
<pre>                        INCREMENT f2 ... 1 PLATFORMS='i86_w'</pre>
<dl><dt><dd>f1 can be used on any sparc station running SunOS or 
Solaris.<dt><dd>f2 can be used on a PC running Windows (not NT) and Dec 
Alpha running OSF1 or DEC-Unix. There's 1 license that 
can be shared between all Windows and Alpha-Unix 
systems, and 1 more license just for Windows. That is, at 
most 1 f2 can be used on the Alpha-Unix systems, but at 
most 2 f2s can be used by Windows systems.<dt><dd>If the checkout fails because it's on the wrong platform, the 
error returned is LM_PLATNOTLIC: `This platform not 
authorized by license'.<dt>SN=<I>serial-number<dd></I>Useful for differentiating otherwise identical 
INCREMENT lines. Its only use by 
FLEXlm<I></I> is to be 
encrypted in the 
<I>license key</I>. Similar to HOSTID=<a name="_IX_391"></a>ID=<I>n.</I><a name="_IX_392"></a><dt>START=<I>dd-mmm-yyyy</I><dd>Optional start date.<a name="_IX_393"></a><dt>SUITE_DUP_GROUP=...<dd>Similar to DUP_GROUP, but affects only the enabling 
FEATURE for a PACKAGE SUITE. Note: If 
SUITE_DUP_GROUP is not specified, the parent will have 
the same duplicate grouping as the components.<a name="_IX_394"></a><dt>SUPERSEDE[='<I>feat1</I> ... 
<I>featn</I>']
<dd>Replaces existing lines in a license file. Without the 
optional list of features, allows vendors to sum up a set of 
INCREMENT lines in a single, new FEATURE (or 
INCREMENT) line, which supersedes all INCREMENT 
lines for the same feature name with previous 
<I>start dates 
</I>or<I> 
ISSUED</I> dates. With the optional list of features, it replaces 
all previously issued lines for 
<I>feat1</I> through<I> featn</I>.<dt><dd>Note that the start date is the one field which is not readable 
in the license file, and is part of the 
<a name="_IX_395"></a>license key. 
<dt><dd>The ISSUED=<I>date</I> field makes this more readable. (e.g., 
ISSUED=1-jan-1996). If the ISSUED date is set, then 
SUPERSEDE uses it, otherwise it uses the 
<I>start date</I>.<dt><dd>For example</dl><pre>			INCREMENT f1 ... 1 ... ISSUED=1-jan-1995</pre>
<pre>			INCREMENT f1 ... 4 ... SUPERSEDE ISSUED=1-jan-1999</pre>
<dl><dt><dd>The second line supersedes the first, and causes 
FLEXlm<I></I> to 
ignore the first line.</dl><pre>			FEATURE f1 ... 1 ... ISSUED=1-jan-1999</pre>
<pre>			FEATURE f2 ... 1 ... ISSUED=1-jan-1999</pre>
<pre>			FEATURE f3 ... 4 ... SUPERSEDE='f1 f2' \</pre>
<pre>				ISSUED=2-jan-1999</pre>
<dl><dt><dd>f3 supersedes f1 and f2, and causes 
FLEXlm<I></I> to support 
only f3.<a name="_IX_396"></a><dt>USER_BASED[=<I>n</I>]<dd>If USER_BASED appears, then licenses can only be used 
by people INCLUDEd for this feature in the end-user 
options file. The purpose is to limit the use to a particular 
number of users, but allow the end-user to determine which 
users. If `=<I>n'</I> is specified, then the number of users which 
can be INCLUDEd is limited to 
<I>n</I>. Otherwise, the limit is 
the 
<I>#lic</I> field. If an INCREMENT appears where some 
licenses are USER_BASED and some are not, the vendor 
daemon tracks these in separate license 
<I>pools</I>.<a name="_IX_397"></a><dt>VENDOR_STRING=<I>'...'
</I><dd>Vendor-defined license data (same as `vendor-string' in the 
old format, above). If checkout is to be conditioned by 
what's in the vendor-string, then 
<a name="_IX_398"></a>LM_A_CHECKOUTFILTER is the best way to do this.
See 
<a href="#32537: 1Head: 5.3 LM_A_CHECKOUTFILTER">Section 5.5, `LM_A_CHECKOUTFILTER,' on 
page 74</a>.<a name="asset_info="></a><dt>asset_info<I>='...'</I><dd>Additional information provided by the software end-user's 
system administrator for asset management. Not encrypted 
into the feature's license key or checksum (ck=<I>n</I>).<a name="ck="></a><dt>ck=<I>nnn</I><dd>A checksum, useful with the 
<TT>lmcksum</TT> utility, which will 
verify that the license has been entered correctly by the 
license administrator. Not encrypted. When using 
<TT>lmcrypt</TT>, 
put ck=0 on each FEATURE line, and lmcrypt will replace 
the 0 with the correct checksum.<a name="dist_info="></a><dt>dist_info<I>='...'</I><dd>Additional information provided by the software 
distributor. Not encrypted into the feature's license key or 
checksum (ck=<I>n</I>).<a name="user_info="></a><dt>user_info<I>='...'</I><dd>Additional information provided by the software end-user's 
system administrator. Not encrypted into the feature's 
license key or checksum (ck=<I>n</I>).<dt><TT></TT><a name="vendor_info="></a>vendor_info<I>='...'</I><dd>Additional information provided by the software vendor. 
Not encrypted into the feature's license key or checksum 
(ck=<I>n</I>).</dl><h4>Examples</h4>
<p>
To illustrate INCREMENT, the two feature lines:<p>
<pre>	FEATURE f1 demo 1.0 permanent 4 ....</pre>
<pre>	FEATURE f1 demo 2.0 permanent 5 ....</pre>
</ol></ul><p>
would only result in 4 licenses for v1 
<I>or 
</I>5 licenses for v2, depending on their order in 
the file, whereas:<p>
<pre>	INCREMENT f1 demo 1.0 permanent 4 ....</pre>
<pre>	INCREMENT f1 demo 2.0 permanent 5 ....</pre>
</ol></ul><p>
would result in 4 licenses for v1 
<I>and</I> 5 licenses for v2 being available, giving a total of 
9 licenses for f1.<p>
<p>
To illustrate counted vs. uncounted licenses, the following FEATURE line<p>
<pre>	FEATURE f1 demo 1.0 1-jan-1995 uncounted 123456789012 HOSTID=DEMO</pre>
</ol></ul><p>
has unlimited usage on any hostid, requires no license<TT> 
</TT>servers (no SERVER or 
VENDOR lines) and is therefore a complete license file by itself. This FEATURE line 
also happens to be an `expiring' license and will not allow use of the FEATURE after 
1-jan-1995.<p>
<p>
In contrast the following FEATURE line requires a vendor daemon named `demo' 
(and naturally a SERVER and VENDOR as well) and<p>
<pre>	FEATURE f1 demo 1.0 permanent 5 123456789012 		\</pre>
<pre>		HOSTID=INTERNET=195.186.*.*</pre>
</ol></ul><p>
is limited to 5 users on any host with an internet IP address matching 195.186.*.*, and 
never expires. 
<p>
<h4>	See also</h4>
<ul><li><a href="#53119: 2head: 6.3.22 ls_use_all_feature_lines">Section 8.3.24, `ls_use_all_feature_lines,' on page 132</a><li><a href="#10539: 2head: 6.3.3 ls_allow_borrow">Section 8.3.7, `ls_compare_vendor_on_increment,' on page 129</a><li><a href="#34313: 2head: 5.1.9 LM_A_CRYPT_CASE_SENSITIVE">Section E.5, `LM_A_CRYPT_CASE_SENSITIVE,' on page 199</a><li><a href="#20049: 1head: 9.4 Special Hostids">Section 6.7, `Special Hostids,' on page 114</a></ul><h3>6.3.5	 <a name="57505: 2head: 9.1.4 UPGRADE Line"></a><a name="_IX_399"></a>UPGRADE Line</h3>
<pre>UPGRADE <I>name daemon fromversion version</I> <I>exp_date</I> <I>#lic code</I> <TT>[ ... ]</TT></pre>
</ol></ul><p>
All the data is the same as for a FEATURE or INCREMENT line, with the addition of 
the 
<I>fromversion</I> field. An UPGRADE line removes up to the number of licenses 
specified from any old version (&gt;= 
<I>fromversion</I>) and creates a new version with that 
same number of licenses.<p>
<p>
For example, the two lines:<p>
<pre>	INCREMENT f1 demo 1.0 1-jan-1994 5 9BFAC03164ED ck=3</pre>
<pre>	UPGRADE f1 demo 1.0 2.0 1-jan-1994 2 1B9A30316207 ck=23</pre>
</ol></ul><p>
would result in 3 licenses of v1.0 of f1 and 2 licenses of v2.0 of f1.<p>
<p>
UPGRADE will operate on the most recent FEATURE or INCREMENT line (i.e., 
closest preceding FEATURE or INCREMENT line) with a version number that is &gt;= 
fromversion, and &lt; version.<p>
<h3>6.3.6	 <a name="PACKAGE"></a>PACKAGE Line</h3>
<p>
The purpose of the PACKAGE line is to support two different licensing needs:<p>
<ol><li>to license a product SUITE, or<li>to provide a more efficient way of distributing a license file that has a large number 
of features, which largely share the same FEATURE line parameters.</ol>
<p>
A PACKAGE line, by itself, does not license anything - it requires a matching 
FEATURE/INCREMENT line to license the whole PACKAGE. A PACKAGE line can 
be shipped with a product, independent of any licenses. Later, you can issue one or 
more corresponding FEATURE/INCREMENT licenses that will enable the 
PACKAGE. It may be more convenient for everyone to keep PACKAGE lines in a 
separate file, which is supported as of 
FLEXlm<I></I> version 6. The path to the PACKAGE 
file should be specified in the application to support this transparently, via 
LM_A_LICENSE_DEFAULT.<p>
<pre>PACKAGE <I>pkg_name vendor pkg_version pkg_key</I> <a name="_IX_400"></a>COMPONENTS=<I>pkg_list</I> \</pre>
<pre>			[ OPTIONS=<I>pkg_options</I> ]</pre>
</ol></ul><p>
<p>
<dl><dt><I>pkg_name</I><dd>name of the PACKAGE. The corresponding 
FEATURE/INCREMENT line must have the same name.<dt><I>vendor</I><dd>name of the vendor daemon that supports this PACKAGE 
(<TT>VENDOR_NAME</TT> in lm_code.h).<dt><I>pkg_version</I><dd>version of the PACKAGE. The corresponding 
FEATURE/INCREMENT line must have the same version.<dt><I>pkg_key</I><dd>key generated by one of the license generators: 
<TT>makepkg</TT>, 
<TT>lmcrypt</TT>, or the vendor's customized license generator.<a name="_IX_401"></a><dt>COMPONENTS<I>=pkg_list</I><dd><dt><dd>the space separated list of components. The format of each 
component is:</dl><pre>	<TT>			</TT>feature<TT>[:</TT><I>version</I><TT>[:</TT><I>count</I><TT>]]</TT></pre>
<dl><dt><dd>The PACKAGE must consist of at least one 
COMPONENT. 
<I>version</I> and 
<I>count</I> are optional, and if left 
out, their values come from the corresponding 
FEATURE/INCREMENT line. 
<I>Count</I> is only legal if 
OPTIONS=SUITE is not set - in this case the resulting 
number of licenses will be the count on the 
COMPONENTS line multiplied by the number of licenses 
in the FEATURE/INCREMENT line. Examples:</dl><pre>			COMPONENTS="comp1 comp2 comp3 comp4"</pre>
<pre>			COMPONENTS="comp1:1.5 comp1 comp1:2.0:4"	</pre>
<dl><a name="_IX_402"></a><dt>OPTIONS=<I>pkg_options</I><dd>Currently the only legal option is 
<a name="SUITE"></a>SUITE. This is what 
distinguishes a SUITE PACKAGE from a PACKAGE used 
to ease distribution.<dt><dd>With OPTIONS=SUITE, the 
<I>pkg_name</I> FEATURE is 
checked out in addition to the component feature being 
checked out.<dt><dd>If OPTIONS=SUITE is not set, then the FEATURE of the 
same name as the package is removed once the PACKAGE 
is turned on, and it also is not checked out when a 
component feature is checked out.</dl><h4>Examples</h4>
<p>
Example 1:<p>
<pre>	PACKAGE office demo 1.0 20CHARCODEXXXXXXXXXX\</pre>
<pre>		COMPONENTS="comp1 comp2" OPTIONS=SUITE</pre>
<pre>	FEATURE office demo 1.0 permanent 5 20CHARCODEXXXXXXXXXX</pre>
</ol></ul><p>
This is a typical SUITE example. The user will have 2 features: comp1 and comp2, 
which are each version 1.0, with 5 non-expiring licenses available. When comp1 or 
comp2 are checked out, `office' will also be checked out. The vendor will most likely 
want to turn on DUP_GROUP (either through the FEATURE line, or 
<I>lc_checkout</I>) so 
that the same user can use comp1 and comp2 while using only one license of the 
<I>office</I> 
FEATURE.<p>
<p>
Example 2:<p>
<pre>	PACKAGE office demo 1.0 271FA0F72594\</pre>
<pre>                        COMPONENTS="comp1 comp2 comp3 comp4 comp5"</pre>
<pre>	INCREMENT office demo 1.0 permanent 1 1B3147ADBC94\
			HOSTID=12345678</pre>
<pre>	INCREMENT office demo 1.0 permanent 1 68B82E55A417\
			HOSTID=87654321</pre>
</ol></ul><p>
This is a good way to distribute multiple node-locked, counted licenses. Rather than 
requiring 5 INCREMENT lines per node, only one INCREMENT line is required per 
node, and the features are indicated in the PACKAGE line.<p>
<p>
Example 3:<p>
<pre>	PACKAGE office demo 1.0 A30483555898\
		COMPONENTS="comp1:1.5:2 comp2:3.0:4 comp3"</pre>
<pre>	FEATURE office demo 1.0 1-jan-1995 32C817A5100D8 ISSUER=distrib1</pre>
</ol></ul><p>
The component versions override the FEATURE versions, and the number of licenses 
available for any component is the product of the 3 licenses for office and the number 
of licenses of that component. The result is equivalent to:<p>
<pre>	FEATURE comp1 demo 1.5 1-jan-1995 6 7649CFAF16DB ISSUER=distrib1</pre>
<pre>	FEATURE comp2 demo 3.0 1-jan-1995 12 63992D55345B ISSUER=distrib1</pre>
<pre>	FEATURE comp3 demo 1.0 1-jan-1995 3 0D037EACC547 ISSUER=distrib1</pre>
<h4>See also</h4>
<ul><li><a href="#12939: 1Head: 9.18 LM_A_LICENSE_DEFAULT">Section 5.15, `LM_A_LICENSE_DEFAULT,' on page 78</a></ul><h3>6.3.7	 <a name="69035: 2head: 8.1.5 FEATURESET Line"></a><a name="FEATURESET"></a>FEATURESET Line</h3>
<p>
The FEATURESET line is required if 
<I>ls_use_featset</I> is set in 
<I>lsvendor.c</I>. 
Otherwise, FEATURESET is unused.<p>
<pre>FEATURESET <I>daemon-name key</I></pre>
</ol></ul><p>
<p>
<dl><dt><I>daemon-name</I> 
<dd>Name of the daemon used to serve some feature(s) in the 
file.<dt><I>key</I><dd><a name="_IX_403"></a>License key for this FEATURESET line. This key encrypts 
the keys of all FEATUREs that this daemon supports, so 
that no FEATURE lines can be removed or added to this 
license file.</dl><p>
The FEATURESET line allows the vendor to bind together the entire list of FEATURE 
lines supported by one daemon. If a FEATURESET line is used, then 
<I>all</I> the FEATURE 
lines must be present 
<I>in the same order</I> in the customer's license file. This is used, for 
example, to insure that a customer uses a complete update as supplied, without adding 
old FEATURE lines from the vendor.<p>
The use of FEATURESET is discouraged.The SERVER hostid(s) and everything on the FEATURE line (except the daemon 
name) is input to the authentication algorithm to generate the code for that 
FEATURE.<h4>See also</h4>
<ul><li>	<a href="#13021: 2head: 6.3.20 ls_use_featset">Section 8.3.23, `ls_use_featset,' on page 132</a><li><a href="#26348: 1Head: 10.1 Format of the License File">Section 6.3, `Format of the License File,' on page 92</a></ul><h3>6.3.8	 <a name="Comments"></a>Comments</h3>
<p>
Comment lines can begin with a '#'. Currently, all lines not beginning with a 
<a name="_IX_404"></a>license 
keyword are comment lines. Therefore, typically, license files can be sent as e-mail 
messages.<p>
<h3>6.3.9	 <a name="Continued Lines"></a>Continued Lines</h3>
<p>
Lines can be continued with a `\' character.<p>
<h3>6.3.10	 Example 
<a name="_IX_405"></a>License File</h3>
<p>
This example illustrates the license file for single vendor with two features, and a set 
of three server nodes, any two of which must be running for the system to function.<p>
<pre>SERVER pat 17003456 27009</pre>
<pre>SERVER lee 17004355 27009</pre>
<pre>SERVER terry 17007ea8 27009</pre>
<pre>VENDOR demo</pre>
<pre>FEATURE f1 demo 1.0 1-jan-1999 10 1AEEFC8F9003</pre>
<pre>FEATURE f2 demo 1.0 1-jan-1999 10 0A7E8C4F561F</pre>
<a name="_IX_406"></a><a name="6.4"></a><h2>6.4  Decimal Format Licenses</h2>
<p>
Licenses can be represented in decimal format, to make license delivery easier for 
customers without access to e-mail. Decimal has the advantage that it's simpler to type 
in, and often the licenses are much shorter. There are notable exceptions, however, 
which are explained below.<p>
<p>
To generate a decimal format license, use the 
<I>-decimal</I> arg for 
<TT>lmcrypt</TT> or 
<TT>makekey.</TT><p>
<p>
To convert an existing license to decimal, use 
<I>lmcrypt -decimal</I>, or<p>
<pre>	% lminstall -i <I>infile </I>-o <I>outfile</I> -odecimal</pre>
</ol></ul><p>
If needed, decimal lines can be mixed with readable format lines.<p>
<p>
End-users will normally use the lminstall command to install decimal format licenses. 
Note that lminstall converts the decimal lines to readable format. lminstall does not, 
however, know where your application expects to find the license file. You will need to 
make the license file location clear to the user.<p>
<h3>6.4.1	 Decimal Format Limitations</h3>
<p>
PACKAGE lines cannot be represented in decimal format. These can be shipped 
separately, in the decimal file in normal PACKAGE format, or preferably will be pre-installed as part of the normal application installation. PACKAGE lines are not 
available in decimal format because they would be excessively long, since they consist 
mostly of component names.<p>
<p>
FEATURESET, which is normally discouraged, also cannot be represented in decimal 
format.<p>
<p>
Very long FEATURE lines will be extremely long in decimal format. If a license is very 
long in the normal format (say &gt; 100 characters), it would be much longer (up to three 
times longer) in the decimal format, defeating the purpose of a decimal format, which 
is to make licenses easier to type in. 
<p>
<p>
FEATURE names including '-' cannot be represented in decimal format. These are 
technically unsupported characters, although some companies have used them.<p>
<h3>6.4.2	 Example decimal licenses:</h3>
<h4>Counted license:</h4>
<pre>	SERVER this_host 12345678
	VENDOR demo
	FEATURE f0 demo 1.0 permanent 1 A7F6DFD8C65E
	FEATURE f1 demo 1.0 permanent 1 AA8BD581EE6
</pre>
</ol></ul><p>
Decimal:<p>
<pre>	demo-f0-49473-46846-62783-50738-57369-53593-728
	demo-f1-02369-24236-07508-18291-8</pre>
</ol></ul><p>
Note that the first decimal line includes the SERVER/VENDOR information, and 
the 2nd (and any subsequent lines) are much shorter.<p>
<h4>Demo license:</h4>
<pre>	FEATURE f2 demo 1.0 1-jun-1998 uncounted 6E06CC47D2AB HOSTID=DEMO</pre>
</ol></ul><p>
Decimal:<p>
<pre>	demo-f2-02753-41313-52979-22534-1299</pre>
<h3>6.4.3	 Format of a Decimal License</h3>
<p>
Decimal format licenses have a fixed format which is easy to recognize:<p>
<pre>	<I>vendor-feature-#####-#####-</I>[...]</pre>
<dl><dt><I>vendor</I> 
<dd>is the vendor daemon name<dt><I>feature</I> 
<dd>is the feature name<dt><I>##### 
</I><dd>Groups of 5 decimal numbers (0-9) followed by a hyphen. 
The last group may be less than 5 digits.</dl><p>
The line includes a checksum, which can detect all single-digit errors and most multi-digit errors in lines that are typed in incorrectly.<p>
<h3>6.4.4	 Hints on Using the Decimal Format</h3>
<p>
There are some `tricks' that are used internally to make decimal lines short. 
Knowledge of these can be useful when designing feature lines.<p>
<h4>Text in optional attributes</h4>
<p>
Text in the optional feature attributes are normally three times longer in the decimal 
format than in the `normal' format. For example: VENDOR_STRING="limit 3" 
would require about 21 characters in the decimal version. There's a trick to making this 
shorter: If the text portion is a decimal or hex number, then it's stored compressed in 
the decimal version, and the conversion is about 1:1 instead of 1:3.<p>
<p>
For example: VENDOR_STRING=12345 consumes about 5 characters in the decimal 
format. VENDOR_STRING=abcd (valid hex characters) will also consume about 5 
characters in the decimal format. Knowing this, you might choose to `encode' 
information in the VENDOR_STRING in a numeric format. This enhancement only 
applies to numbers &lt;= 0xffffffff. For example, VENDOR_STRING=12345678901234 
will require about 14*3 = 42 characters in the decimal format.<p>
<p><hr>
Note:	Note: Mixed case hex characters will not be stored efficiently. 
VENDOR_STRING=abcD will take about 12 decimal characters, instead of 5.<hr><p>
<h4>Feature names</h4>
<p>
Avoid underscore '_' in feature names; it's hard to distinguish from a hyphen '-'. For 
example:<p>
<pre>	demo-prod_1a-10449-31786-63556-56877-09398-10373-137</pre>
</ol></ul><p>
This is hard to read, and if the user mixes up the '-' and '_', the license will be invalid. 
Since you also can't use '-' in a feature name, this means that feature names won't have 
any kind of separator.   Therefore, in the example, we suggest simply `prod1a'.<p>
<h4>ck=</h4>
<p>
Leave this optional attribute off. The decimal format has its own built-in checksum. 
This attribute will only make the decimal format longer.<p>
<h4>Expiration dates</h4>
<p>
For non-expiring licenses, use `permanent' or 1-jan-0 as the expiration date. Some 
older format, but still valid expiration dates are not supported in the decimal format. 
For example: 3-mar-0 is functionally identical to permanent, but since the decimal 
format supports only `permanent' or `1-jan-0', 3-mar-0 is unsupported. Dates farther 
in the future require many decimals to represent. Therefore 1-jan-9999 takes about 14 
characters while permanent requires about 1. 
<p>
<h4>See Also</h4>
<ul><li>lminstall, in the 
FLEXlm<I></I> Programmer's Guide or End-User Manual</ul><a name="35936: 1head: 9.2 Locating the License File"></a><a name="_IX_407"></a><a name="6.5"></a><h2>6.5  Locating the License File</h2>
<p>
	The rules for finding the license file are:<p>
<ol><li>Look in the default location:<pre>	/usr/local/flexlm/licenses/license.dat (Unix)</pre>
<pre>	C:\FLEXLM\LICENSE.DAT (Windows)</pre>
<pre>	SYS:\FLEXLM\LICENSE.DAT (Netware)</pre>
<pre>	SYS$COMMON:[SYSMGR]flexlm.dat (VMS)</pre>
<li>If either $LM_LICENSE_FILE or $<I>VENDOR</I>_LICENSE_FILE environment 
variables is set, these are used instead of the default location. Note that 
environment variables can also be set in the registry (Windows) or in ~/.flexlmrc 
(Unix). If set in both locations, both are used.<li>If both $<I>VENDOR</I>_LICENSE_FILE and $LM_LICENSE_FILE are set, both are 
used instead of the default location, with $<I>VENDOR</I>_LICENSE_FILE used first. 
<li>If application sets lc_set_attr(..., LM_A_DISABLE_ENV...), then environment 
variables are ignored. (Not recommended except in special circumstances).<li>The license location(s) can be set in the application with             
LM_A_LICENSE_FILE or LM_A_LICENSE_FILE_PTR or             
LM_LICENSE_DEFAULT. If any of these are set, the default location is ignored. 
LM_A_LICENSE_DEFAULT is normally recommended, since it automatically 
recognizes the environment variables plus the indicated license path(s).              
LM_A_LICENSE_FILE and LM_A_LICENSE_FILE_PTR will set the             
path if the environment variable is either not set or is disabled. 
<li>In the FLEXible API, the license file location cannot be changed once the license 
file is read. The license file is not read until one of the following functions is 
called: 
lc_checkout, 
<I>lc_get_config</I>, 
<I>lc_next_conf</I>, 
<I>lc_userlist. 
</I>The only way to 
effectively change the license file once it has been read, is to start a new job (with 
<I>lc_new_job()</I>. That new job will read the new or modified license when required 
to.<li>Calling any of lc_set_attr(..., LM_A_LICENSE_*, ...) more than once overrides 
the previous setting. For example, 
<pre>	lc_set_attr(..., LM_A_LICENSE_DEFAULT, <I>licensepath1</I>);
	lc_set_attr(..., LM_A_LICENSE_DEFAULT, <I>licensepath2</I>);</pre>
</ol></ul><p>
		Only 
<I>licensepath2</I> is used.<p>
<pre>	lc_set_attr(..., LM_A_LICENSE_FILE, <I>licensepath1</I>);
	lc_set_attr(..., LM_A_LICENSE_DEFAULT, <I>licensepath2</I>);</pre>
</ol></ul><p>
Again, only 
<I>licensepath2</I> is used.<p>
<li>For the Simple and Trivial APIs, the rules are the same, with the rule that the 
license-path argument behaves like LM_A_LICENSE_DEFAULT.<li>The 
<TT>-c</TT> option will override the setting of 
<TT>LM_LICENSE_FILE</TT> for all 
FLEXlm<I></I> 
utilities such as: 
<TT>lmgrd</TT><I></I><TT></TT>, 
<I>lmdown</I>, 
<I>lmstat</I> etc.</ol>
<h3>6.5.1	 License specification</h3>
<p>
Wherever a license path can be specified, it can consist of<p>
<ul><li>a single file<li>a list of files, separated by a colon on Unix, a semi-colon on Windows, or a space 
on VMS.When assigning a license file path on VMS, use a command similar to 
the following:
           $ assign "file_1 file_2 file_3" lm_license_file.
where the quotes around all the license file names are required.<li>a directory, where 
<I>dir</I>/*.lic are used in alphabetical order, as if specified like a 
license file list. On Windows, case doesn't matter and *.LIC files are also 
recognized. On Unix, case does matter and only *.LIC files are not recognized.<li><a name="_IX_408"></a>@<I>host</I>, where 
<I>host</I> is the hostname of the license server, when the SERVER has 
no port number, or the port number is between 27000 and 27009. (<I>New</I> in v6 - unsupported in older versions.) 

@localhost will always work if the server is running on the same system as the 
client.<li><I><a name="_IX_409"></a>port</I>@<I>host</I>, where port is the port number and hostname come from the SERVER 
line<li><I>port</I>@<I>host</I>,<I>port</I>@<I>host</I>,<I>port</I>@<I>host</I>, when a 3-server redundant server is being 
used.<li>The actual license file text, with `<a name="_IX_410"></a>START_LICENSE\n' as a prefix, and 
`\<a name="_IX_411"></a>nEND_LICENSE' as suffix, where the embedded newlines are required.</ul><h3>6.5.2	 Using License File List for Convenience and Redundancy</h3>
<p>
Client programs can process a series of license files, for example, by setting 
<TT>LM_LICENSE_FILE</TT> to a path, as in:<p>
<pre>	% setenv LM_LICENSE_FILE file1:file2:..:dir1:..:filen</pre>
</ol></ul><p>
Client programs will then try using 
<I>file1</I>; if it fails, 
<I>file2</I> will be tried, etc. Directories 
are automatically expanded to use all files matching *.lic in that directory as part of the 
list.<p>
<p>
Aside from being convenient, this is an important method of redundancy, and has many 
advantages over the more formal 3-server redundancy. It can also be used in 
combination with 3-server redundant systems.<p>
<p>
A non-redundant server would have only a single<a name="_IX_412"></a> 
<I>@host</I>, whereas redundant servers 
could be specified as 3 sets of 
<I>port@host*</I>, separated by commas. For example, if you 
have a single server node named `serverhost', and you are running 
FLEXlm<I></I> on port 
27000, you could specify your `license file' as:<p>
<pre>	@serverhost</pre>
</ol></ul><p>
or 
	<p>
<pre>	27000@serverhost</pre>
</ol></ul><p>
You could have a license file path which looked like the following:<p>
<pre>@serverhost:/usr/local/license.dat:/myprod/licensedir:27000@shost2</pre>
</ol></ul><p>
or, if the second server was a set of 3 redundant servers, the path might look like this:<p>
<pre>	@serverhost:1700@host1,1700@host2,1700@host3:27000@shost2</pre>
</ol></ul><p>
In this last example, the `<TT>1700@host1</TT>,<TT>1700@host2</TT>,<TT>1700@host3</TT>' part specifies a set 
of 3 redundant servers.<p>
<p><hr>
Note:		Both the client and server need to be reading the SAME license file, since the client 
passes the 
<a name="_IX_413"></a>license key from the FEATURE line to the vendor daemon. However, 
<I>@host</I>, 
<I>port@host</I> or USE_SERVER solve this problem, since the client never reads 
the license file features in these cases.<hr><p>
<h4>See Also</h4>
<ul><li><a href="#43831: 2head: 3.3.30 lc_set_attr">Section 4.30, `lc_set_attr,' on page 53</a><li><a href="#16570: ChapTitle: Chapter 9 Redundant License Servers">Chapter 9, `Redundant License Servers' on page 137</a></ul><a name="42751: 1head: 9.3 Host Ids for FLEXlm Supported Machines"></a><a name="_IX_414"></a><a name="6.6"></a><h2>6.6  Hostids for FLEXlm<I></I> Supported Machines</h2>
<p>
FLEXlm<I></I> uses different machine identifications for different machine architectures. For 
example, all Sun Microsystems machines have a unique integer 
<a name="_IX_415"></a>hostid, whereas all 
DEC machines do not. For this reason, the Ethernet address is used on some machine 
architectures as the `Hostid'. An Ethernet address is a 6-byte quantity with each byte 
specified as two hex digits. Specify all 12 hex digits when using an Ethernet address 
as a hostid. For example, if the Ethernet address is 8:0:20:0:5:ac, specify 
`0800200005AC' as the hostid.<p>
<p>
Integer hostids (used on Sun, SGI, HP, etc.) are normally hexadecimal numbers. 
However, a license file can take a decimal number if the hostid has a `#' prefix. Certain 
systems, notably HP uname and SGI, return decimal numbers by default, and this can 
make license file distribution easier, since you don't have to convert to hex. Note that 
whenever a 
FLEXlm<I></I> utility prints such a hostid, it always prints a hexadecimal number.<p>
<p>
The default hostid for 
Windows and Window NT systems is the ethernet address of the 
system. 
FLEXlm<I></I> also supports several other hostids as well as hardware keys available 
from 
GLOBEtrotter Software<I></I>. For more details, see 
<a href="#60608: 2head: 14.10.9 Node Lock and Host ID for Standalone PCs">Section 13.7, `Node Lock and 
Hostid for Standalone PCs,' on page 157</a>.<p>
<p>
The 
VMS version of 
FLEXlm<I></I> includes support for certain specified devices. For more 
information, see 
<a href="#42247: 2head: 14.9.4 VMS supported ethernet devices">Section 12.8.4, `VMS Ethernet Device Support,' on page 152</a>.<p>
<p>
The program 
<TT><a name="lmhostid"></a></TT><TT>lmhostid</TT> will print the exact hostid that 
FLEXlm<I></I> expects to use on any 
given machine. The following table lists alternate methods to obtain the required hostid 
for each machine architecture:<p>

<table border>

<tr><td align=left><a name="Apollo hostid"></a><dt>Apollo<td align=left><dt>20-bit node 
ID<td align=left><dt><TT>lcnode -me</TT><td align=left><dt>BE70
<tr><td align=left><dt>Alpha Dec Unix<td align=left><dt>ethernet 
address<td align=left><dt><TT>netstat -i. Use Address 
column, and remove ':'</TT><td align=left><dt>08002be5a721
<tr><td align=left><a name="HP hostid"></a><dt>HP<td align=left><dt>32-bit hostid<td align=left><dt><TT>echo 'uname -i' 16o p | dc</TT><td align=left><dt>778DA450
<tr><td align=left><td align=left><dt>ethernet 
address 
<td align=left><dt><TT>lanscan 
</TT>(use station address 
without leading `0x')<td align=left><dt>0000F0050185
<tr><td align=left><dt>Linux<td align=left><dt>Ethernet<td align=left><dt>/sbin/ifconfig eth0. Use 
HWaddr, and remove 
colons, e.g., 
00:40:05:16:E5:25 becomes 
00400516e525<td align=left><dt>00400516e525
<tr><td align=left><a name="RS/6000 hostid"></a><dt>RS/6000 - PPC 
running AIX<td align=left><dt>32-bit hostid<td align=left><dt><TT>uname -m</TT> (returns 
000276513100), then 
remove last 2 digits, and use 
remaining last 8 digits<td align=left><dt>02765131
<tr><td align=left><a name="SCO hostid"></a><dt>SCO (v3 and 
later)<td align=left><dt>Hostid String<td align=left><dt>uname -x (returns 
SCO00354), then prefix 
with 
"ID_STRING="<td align=left><dt>ID_STRING=SCO00354
<tr><td align=left><dt>SCO 
(FLEXlm<I></I> pre-
v.3.0)<td align=left><td align=left><dt>uname -x (returns 
SCO00354), then remove 
any non-hex proceeding 
letters from the serial 
number<td align=left><dt>00354
<tr><td align=left><a name="SGI hostid"></a><dt>SGI<td align=left><dt>32-bit hostid<td align=left><dt><TT>echo '/etc/sysinfo -s' 16o p | 
dc</TT><td align=left><dt>69022F72
<tr><td align=left><a name="SUN hostid"></a><dt>SUN<td align=left><dt>32-bit hostid<td align=left><dt><TT>hostid</TT><td align=left><dt>170a3472
<tr><td align=left><a name="VAX hostid"></a><a name="_IX_1"></a><dt>VAX/VMS<a name="_IX_2"></a><dt>Alpha/OpenVMS<td align=left><dt>ethernet 
address<td align=left><dt><TT>ncp</TT><td align=left><dt>0800200055327
<tr><td align=left><a name="_IX_3"></a><dt>Windows<td align=left><dt>ethernet<td align=left><dt>lmutil lmhostid<td align=left><dt>0800200055327
<tr><td align=left><td align=left><dt>DISK_SERIAL_NUM - 32-bit hostid<td align=left><dt>DIR C:\ 
(look for 
`Volume Serial Number is', 
and remove '-')<td align=left><a name="_IX_4"></a><dt>DISK_SERIAL_NUM=1CA25283
<tr><td align=left><td align=left><dt>FLEXid 
dongles<td align=left><dt><TT>lmutil lmhostid 
-flexid</TT><dt>(Also printed on the dongle)<td align=left><dt>FLEXID=7-B2850003
<tr><td align=left><td align=left><dt>Intel Pentium 
III+ CPUID 
(FLEXlm 
v7.0d+) 
<td align=left><dt>lmhostid -cpu[32|64|96]<dt><td align=left><dt>1B34-A0E3-8AFA-6199-9C93-2B2C (96-bit)
8AFA-6199-9C93-2B2C 
(64-bit)
9C93-2B2C (64-bit)
</table>
<h4><B>See also</B></h4>
<ul><li><a href="#60608: 2head: 14.10.9 Node Lock and Host ID for Standalone PCs">Section 13.7, `Node Lock and Hostid for Standalone PCs,' on page 157</a><li><a href="#39426: 1Head: 4.21 lc_free_hostid">Section 4.17, `lc_free_hostid,' on page 43</a><li><a href="#11229: 1Head: 4.3 l_new_hostid">Section 4.3, `l_new_hostid,' on page 26</a><li><a href="#42751: 1head: 9.3 Host Ids for FLEXlm Supported Machines">Section 6.6, `Hostids for FLEXlm Supported Machines,' on page 111</a><li><a href="#19898: 1Head: 6.9 Intel Pentium III+ Hostid">Section 6.9, `Intel Pentium III+ Hostid,' on page 116</a></ul><a name="20049: 1head: 9.4 Special Hostids"></a><a name="6.7"></a><h2>6.7  Special Hostids</h2>
<p>
FLEXlm<I></I> contains a number of `special' hostid types which apply to all platforms. 
These hostid types can be used on either a 
<a name="SERVER"></a>SERVER line or a FEATURE line, wherever 
a hostid is required. These are:<p>
<dl><a name="ANY"></a><dt>ANY<dd>Locks the software to any node (i.e., does not lock 
anything).<a name="DEMO"></a><dt>DEMO<dd>Similar to ANY, but only for use with uncounted 
FEATURE lines<a name="DISK_SERIAL_NUM="></a><dt>DISK_SERIAL_NUM=<I>sn</I> 
<dd>Locks the software to a PC with C drive serial number 
<I>sn</I>. 
(Windows and NT only).<a name="DISPLAY="></a><dt>DISPLAY=<I>disp</I><dd>Locks the software to display `<I>disp</I>'.<a name="_IX_416"></a><dt>FLEXID=<I>sn</I> 
<dd>Locks the software to a PC with a hardware key (dongle) of 
serial number 
<I>sn</I>. (Windows and NT only).<a name="HOSTNAME="></a><dt>HOSTNAME=<I>node</I><dd>Locks the software to computer hostname `<I>node</I>'.<a name="_IX_417"></a><dt>ID=n<dd>functionally equivalent to the `ANY' hostid -- it will run on 
any node. The difference is that the license is unique and 
can be used to identify the customer. This hostid can be 
used to lock the license server (on the SERVER line) or the 
client node (on the FEATURE/INCREMENT line) - anywhere a hostid can be used. The number can have 
dashes included for readability - the dashes are ignored.<dt><dd>Examples:</dl><pre>                                ID=12345678 is the same as</pre>
<pre>                                ID=1234-5678 is the same as</pre>
<pre>                                ID=1-2-3-4-5-6-7-8</pre>
<dl><a name="_IX_418"></a><dt>ID_STRING=<I>string<dd></I>Used on 
<a name="_IX_419"></a>SCO systems for hostid.<a name="INTERNET="></a><dt>INTERNET=<I>nnn.nnn.nnn.nnn</I><dd><dt><dd>Locks the software to an Internet IP address, or group of IP 
addresses. Wildcards are allowed. For example, 
198.156.*.* means any host with a matching internet IP 
address. The main use is to limit usage access by subnet, 
implying geographic area. For this purpose, it would be 
used on the FEATURE/INCREMENT line, as a hostid 
lock.<dt><dd><B>WARNING</B>: The Internet hostid can be used on the 
SERVER line, as a hostid to lock the vendor daemon. In 
this case, the wildcards should not be used, otherwise the 
customer could easily start license managers on more than 
one node and obtain `extra' licenses.<a name="USER="></a><dt>USER=<I>name</I><dd>Locks the software to username 
<I>`name</I>'.</dl><h4>Examples</h4>
<pre>	FEATURE f1 demo 1.0 1-jan-1999 uncounted AB28E0011DA1 \</pre>
<pre>		HOSTID=HOSTNAME=globes</pre>
</ol></ul><p>
or<p>
<pre>	FEATURE f1 demo 1.0 1-jan-1999 uncounted EB78201163B0 \
		HOSTID=USER=joe</pre>
<h4><B>See also</B></h4>
<ul><li><a href="#42751: 1head: 9.3 Host Ids for FLEXlm Supported Machines">Section 6.6, `Hostids for FLEXlm Supported Machines,' on page 111</a><li><a href="#79592: 2head: 9.1.3 FEATURE or INCREMENT Line">Section 6.3.4, `FEATURE or INCREMENT Line,' on page 96</a><li><a href="#53802: 2head: 10.1.1 SERVER Line">Section 6.3.1, `SERVER Line,' on page 93</a><li><a href="#60608: 2head: 14.10.9 Node Lock and Host ID for Standalone PCs">Section 13.7, `Node Lock and Hostid for Standalone PCs,' on page 157</a></ul><a name="66223: 1head: 9.5 Vendor-defined hostid"></a><a name="_IX_420"></a><a name="6.8"></a><h2>6.8  Vendor-defined hostid</h2>
<p>
FLEXlm<I></I> allows you to specify your own vendor-defined hostid types. In order to do 
this, follow these steps: (See examples/vendor_hostid/)<p>
<ol><li>Write a C source file similar to this example (<TT>hostids.c</TT>):<pre>#include "lmclient.h"
#include "lm_attr.h"
#include "string.h"

extern LM_HANDLE *lm_job; 	/* This must be the current job! */

#define OURTYPE HOSTID_VENDOR+1
#define OURSTRING "EXAMPLE_HOSTID"
#define OUR_FIXED_ID "1234"		/* This example returns only 1 hostid */


/*
 *      x_flexlm_gethostid() - Callback to get the vendor-defined hostid.
 *		(Sorry about all the windows types for this function...)
 *
 */
 
HOSTID * LM_CALLBACK_TYPE
/*
 *	IMPORTANT NOTE:  This function MUST call l_new_hostid() for
 *			a hostid struct on each call.
 *			If more than one hostid of a type is
 *			found, then call 	l_new_hostid	 for each 
 *			and make into a list using the 'next' field.
 */
x_flexlm_gethostid(idtype)
short idtype;
{
  HOSTID *h = l_new_hostid();
 
        if (idtype == OURTYPE)
        {
		h-&gt;type = OURTYPE;
 
		strncpy(h-&gt;id.vendor, OUR_FIXED_ID, MAX_HOSTID_LEN);
		h-&gt;id.vendor[MAX_HOSTID_LEN] = 0;
		return(h);
        }
        return((HOSTID *) NULL);
}


void
x_flexlm_newid(id)
HOSTID *id;
{
  LM_VENDOR_HOSTID h;

	memset(&amp;h, 0, sizeof (h));
	h.label = OURSTRING;
	h.hostid_num = OURTYPE;
	h.case_sensitive = 0;
	h.get_vendor_id = x_flexlm_gethostid;
	if (lc_set_attr(lm_job, LM_A_VENDOR_ID_DECLARE, 
					(LM_A_VAL_TYPE) &amp;h))
		 lc_perror( lm_job, "LM_A_VENDOR_ID_DECLARE FAILED");
}
</pre>
<li>Register your hostid in the client application, and license generators (lmcrypt, 
makekey, etc.)<pre>	LM_HANDLE *lm_job;
	...
	lc_new_job(..., &amp;lm_job); /* lc_init() in license generator */
	x_flexlm_newid();
	...</pre>
<li>Modify 
<TT>machind/lsvendor.c</TT> thus:<pre>	...</pre>
<pre>	ls_user_init1 = x_flexlm_newid;</pre>
<pre>	...</pre>
<li>Modify vendor daemon and application makefiles to include 
<TT>hostids.c 
</TT><TT>(the above 
example)</TT><TT>.</TT></ol>
<a name="19898: 1Head: 6.9 Intel Pentium III+ Hostid"></a><a name="_IX_421"></a><a name="_IX_422"></a><a name="6.9"></a><h2>6.9  Intel Pentium III+ Hostid (HOSTID_INTEL)</h2>
<h4>Requirements: 
</h4>
<ul><li>FLEXlm<I></I> v7.0d+<li>Windows<li>CPU hostid must be enabled.</ul><h3>6.9.1	 Enabling the CPU Hostid</h3>
<p>
On most systems, this is enabled in the BIOS Setup, which you usually enter by 
pressing the DEL key when the system is first booting up. If this is unavailable, it likely 
means that the system is not a Pentium III or higher.<p>
<h3>6.9.2	 Hostid length</h3>
<p>
The true CPUID is a 96-bit value, in the format 
<p>
<pre>	XXXX-XXXX-XXXX-XXXX-XXXX-XXXX</pre>
</ol></ul><p>
where the X's are uppercase hex characters. According to Intel, all 96-bits (24 hex 
characters) are required to acheive a `nearly' unique hostid. It is likely, however, that 
using the last 16 or 8 hex characters are very nearly unique. Therefore, we recommend 
that unless absolute uniqueness is required, the 32-bit format should normally be used 
so that the license file is shorter and more readable. The 64-bit version can be a 
compromise between the two.<p>
<p>
The required length is determined by what's put in the license file. So if you want to 
use 96-bit CPUID, then that's what should go in the license.<p>
<h3>6.9.3	 Converting from 96-bit to 32-bit</h3>
<p>
The 32-bit hostid is simply the last 9 characters from the 96-bit version. Similarly, the 
64-bit is the last 19 characters:<p>
<dl><dt>length<dd>example<dt>96-bit<dd>1B34-A0E3-8AFA-6199-9C93-2B2C<dt>64-bit<dd>8AFA-6199-9C93-2B2C<dt>32-bit<dd>9C93-2B2C</dl><h3>6.9.4	 lmtools and lmhostid</h3>
<p>
lmhostid takes the following arguments:<p>
<dl><dt>-cpu 
<dd>32-bit hostid<dt>-cpu32<dd>32-bit hostid<dt>-cpu64<dd>64-bit hostid<dt>-cpu96<dd>96-bit hostid</dl><h3>6.9.5	 Security issues</h3>
<p>
Where available, this is the preferred hostid, since it is likely to be the most secure 
hostid. We have taken extra precautions in the applications and vendor daemons to 
make this hostid extra secure.<p>
<p>
We do not believe that cpuid length is important to security. We have every reason to 
believe that a duplicate 32-bit or 64-bit hostid will be so rare as to be insignificant, 
although only time will tell.<p>
<a name="license file"></a><a name="6.10"></a><h2>6.10  <TT></TT>Types of License Files</h2>
<p>
Depending on the information in this file, the contents will be interpreted differently 
by 
FLEXlm<I></I>. The license file supports network licensing, node locking, network 
licensing on a limited set of hosts, and demo/evaluation software. See the 
FLEXlm Programmers Guide<I></I> and 
<TT>examples/licenses</TT> for examples of different types of license 
files.<p>
<a name="6.11"></a><h2>6.11  License Key Length and Start Date</h2>
<p>
The license key is the set of hex digits which appear on every 
FEATURE/INCREMENT/UPGRADE/PACKAGE line and authenticates the text, 
making the line secure.<p>
<p>
        For example:<p>
<pre>        FEATURE f2 demo 1.0 permanent uncounted <I>6E06CC47D2AB</I> HOSTID=1234</pre>
<pre>						  ^^^^^^^^^^^^</pre>
<pre>						  license key</pre>
</ol></ul><p>
Previous to version 6, license keys were always 20 characters. The 
<a name="_IX_423"></a>license key is now 
12 characters instead of 20 by default, but 20-character keys can still be used. 20-character license keys are always accepted while shorter license keys can be 
disallowed, via 
<p>
<ul><li>lc_set_attr(job, LM_A_LKEY_LONG, (LM_A_VAL_TYPE)1), or<li>lc_set_attr(job, LM_A_BEHAVIOR_VER, (LM_A_VAL_TYPE) 
<I>behavior</I>); 

where 
<I>behavior</I> is LM_BEHAVIOR_V5_1 or less, or<li>Setting LM_VER_BEHAVIOR in machind/lm_code.h to 
LM_BEHAVIOR_V5_1 or less.</ul><p>
Shorter license keys are preferred where acceptable, since they're easier to type in, 
convert to much shorter decimal format keys, and provide sufficient security for most 
ISVs.<p>
<p>
Shorter license keys impact licensing in 2 ways:<p>
<ol><li>Instead of a 64-bit security key on each feature line, there's a 48-bit security key. 
<li>The 20-character license key included 4 characters for the license `start date'. 
This is now optional, and is turned off by default in v6. 
</ol>
<p>
We believe that a start date has little practical application for most companies and was 
rarely used. However, those desiring a start date can now get one in 2 ways:<p>
<ol><li>There is now an optional `START=' attribute for 
FEATURE/INCREMENT/UPGRADE lines. This is the preferred method for a 
start date.<li>You can continue to use a start date in the license key. However, we have imposed 
the requirement that a start date in the license key 
<I>must</I> be accompanied by a 64-bit license key. (This is to remove any ambiguity about what the key contains.)</ol>
<h3>6.11.1	 Changing license key behavior</h3>
<p>
Here's how to turn on long license keys and/or license key start dates in applications, 
license generators and vendor daemons:<p>
<h4>Application and license generators:</h4>
<p>
long license keys:<p>
<pre>	lc_set_attr(job, LM_A_LKEY_LONG, (LM_A_VAL_TYPE) 1);</pre>
</ol></ul><p>
hidden start dates:<p>
<pre>	lc_set_attr(job, LM_A_LKEY_START_DATE, (LM_A_VAL_TYPE) 1);</pre>
</ol></ul><p>
For lmcrypt and makekey, modify the source in the machind directory.<p>
<p>
Vendor daemon (lsvendor.c in machind directory):<p>
<pre>	ls_a_lkey_long = 1;             /* long license keys */</pre>
<pre>	ls_a_lkey_start_date = 1;       /* hidden start dates */</pre>
<h3>6.11.2	 Compatibility Issues</h3>
<ul><li>V6 applications (even those accepting short license keys) will accept licenses 
with long license keys.<li>Pre-v6 applications will not accept licenses with short license keys.<li>License generators (lmcrypt, makekey) will issue long license keys when verfmt 
is set to a version less than 6.<li>LM_BEHAVIOR_V5_1 (or older) in lm_code.h will set license keys to be long 
and start dates in the license keys. However, this can be overridden in the code 
with lc_set_attr(job, LM_A_LKEY_LONG, 0) and lc_set_attr(job, 
LM_A_LKEY_START_DATE, 0), which must be set in the application, license 
generator and vendor daemon.</ul><p>
Existing companies can successfully use short license keys (and may very well want 
to), but must obey the following rules:<p>
<ul><li>If a site wants to use older products, then you must use `-verfmt ...' to create a 
license with long keys. Both old and new products will accept these licenses.<li>If a site is completely converting to products using 
FLEXlm<I></I> v6, licenses with 
short keys can be shipped.<li>New customers can receive licenses with short keys.</ul><a name="6.12"></a><h2>6.12  License in a buffer</h2>
<p>
The license file does not need to be located on disk - it can be specified in the program 
itself. Any place a license path can be set can be a license file instead., or lp_checkout 
can specify the actual license, as in this example:<p>
<pre>lc_set_attr(job, LM_A_LICENSE_DEFAULT, (LM_A_VAL_TYPE)
	"START_LICENSE\n\
	FEATURE f1 demo 1.0 permanent \
	uncounted 50A35101C0F3 HOSTID=ANY \
	VENDOR_STRING='Acme Inc"\n\
	END_LICENSE');</pre>
</ol></ul><p>
Note that the license begins with `START_LICENSE\n' and ends with 
`\nEND_LICENSE'. The embedded newlines are required. A license like this can be 
specified in place of a license-path wherever a license-path is valid. This can also be a 
license-file-list; as in the following example:<p>
<pre>lc_set_attr(job, LM_A_LICENSE_DEFAULT,(LM_A_VAL_TYPE)
	"path/to/license.dat:\
	START_LICENSE\n\
	FEATURE f1 demo 1.0 permanent \
	uncounted 50A35101C0F3 HOSTID=ANY \
	VENDOR_STRING='Acme Inc'\n\
	END_LICENSE"</pre>
</ol></ul><p>
In this example, `path/to/license.dat' is first in the list, followed by the license in the 

string.<p>
<p>
License in a buffer is particularly useful when selling libraries, and end-user royalties 
are not required. Since all end-users for a particular ISV will have the same license file, 
it's convenient to store it in a character buffer in the program, rather than in a license 
file, which would require the ISV to distribute an extra file and which might get 
misplaced.<p>
<p>
For example, a library may be used to read a particular format file. If the file included 
the name of the company that generated the data, a license could guarantee that only 
files generated by this company can be read by the library, by matching the name in the 
VENDOR_STRING="" field, (in conjunction with using 
<I>lc_auth_data()</I>, or 
<I>LM_A_CHECKOUTFILTER</I>).<p>
<a name="6.13"></a><h2>6.13  E-mailing licenses</h2>
<p>
E-mailers can and do alter license files. We attempt to accommodate most e-mailer 
alterations, but not all are accommodated.<p>
<h3>6.13.1	 Newline additions</h3>
<p>
E-mailers often insert newlines into text, such as a license file. With v7+, this is okay 
and will not cause a problem. However, because of this enhancement, with v7+ it is 
now important that comments that appear between license file lines are prefixed with 
'#'. Comments appearing before or after all lines do not require this (except the first 
line after the last FEATURE or INCREMENT line). Therefore, emails can be saved 
with e-mail headers intact, and this is a good way to recommend saving a license file.<p>
<h3>6.13.2	 Adding `.txt' to the license file name</h3>
<p>
When saving a text file, either in the emailer, or with notepad on windows, it's common 
that a `.txt' ending is appended, often with no notice or warning to the user.<p>
<p>
Version 7+ FLEXlm ignores this suffix. That is, if a file called `demo.lic' is in the 
license path, and `demo.lic.txt' is found, this will be used. If both demo.lic and 
demo.lic.txt exist, both are used<p>
<h3>6.13.3	 Other transformations</h3>
<h4>quotes</h4>
<p>
Ascii quote marks are sometimes substituted with other special characters. v7+ handles 
this correctly.<p>
<h4>Word format, Rich text, etc.</h4>
<p>
If the license is not saved as ascii text, but turned into Word, or Rich text, or any other 
similar encoding, FLEXlm will not recognize the license file, and should be avoided.<p>
<a name="6.14"></a><h2>6.14  Order of lines in license file</h2>
<p>
In some cases, the order of FEATURE and INCREMENT lines in a license file can 
matter. The order of the other lines (VENDOR, SERVER, PACKAGE) do not matter.<p>
<p>
The application will attempt a checkout with each FEATURE/INCREMENT line that 
matches the feature name. For example:<p>
<pre>FEATURE f1 xyzd 1.0 permanent uncounted 707042C8BEB9 
		HOSTID=08002b32b161
FEATURE f1 xyzd 1.0 permanent 5 707042C8BEB9 </pre>
</ol></ul><p>
In this example, the uncounted, node-locked license will be attempted before the 
counted, floating license. This is preferable: if the user is on host 08002b32b161, it's 
better to not consume any of the counted licenses. If the licenses were in the reverse 
order, the uncounted licenses would only get used when all the floating licenses were 
used. If a user on host 08002b32b161 were using a floating licenses, then users on 
other hosts would get denied licenses unnecessarily.<p>
<p>
For this reason, in v7+, licenses are, internally, automatically sorted so that many of the 
most common license order problems are avoided. The sort is as follows: 
<p>
<ol><li>License file. This means that the automatic sorting does not occur between files in 
a license-file list.<li>Feature name<li>FEATURE before INCREMENT<li>Uncounted before counted<li>Version, lower versions before higher versions.<li>Issued date, in reverse order, newest first. The date is taken from any of these 3 
dates: ISSUED=, START=, hidden start-date in license-key.</ol>
<a name="6.15"></a><h2>6.15  sort=<I>nnn</I></h2>
<p>
This order can be overridden by adding the 
<TT>sort=</TT><TT>nnn</TT> attribute to any or all 
FEATURE/INCREMENT lines. The default is 100. Lines less than 100 are sorted 
before all lines without this attribute, and lines greater than 100 appear after all 
unmarked lines. All lines with the same number are sorted as they appear in the file. 
Therefore, to turn off automatic ordering, add 
<TT>sort=nnn</TT>, where 
<I>nnn</I> is the same on 
all lines.<p>
<a name="Chapter 7"></a><hr><h1>Chapter 7 
<a name="_IX_424"></a>lmgrd</h1>
<a name="lmgrd"></a><a name="7.1"></a><h2>7.1  lmgrd - The License Daemon</h2>
<p>
The purpose of 
<TT>lmgrd</TT> is to:<p>
<ul><li>start and maintain all the vendor daemons listed in the VENDOR lines of the 
license file, and 
<li>refer application checkout (or other) requests to the correct vendor daemon.</ul><p>
<TT>lmgrd</TT> is a standard component of 
FLEXlm<I></I> that neither requires nor allows for vendor 
customization. The license daemon does allow the license file location and the server-to-server connection timeout interval to be set by the end-user. These options are set by 
command line arguments when starting 
<TT>lmgrd</TT>. The command line for 
<TT>lmgrd</TT> is:<p>
<pre>lmgrd [-app] [-2 -p] [-c <I>license_file_list</I>] <TT></TT>[-l <I>logfile</I>]
  [-s <I>timestamp_interval</I>] [-t <I>timeout_interval</I>] [-x lmdown|lmremove ]</pre>
<pre>  [-v] [-z]</pre>
</ol></ul><p>
<p>
<dl><dt>-app (Windows only)<dd>32-bit Windows (NT and 95) only - to run 
<TT>lmgrd</TT>.<TT>exe</TT> in a 
DOS window or console.<dt>-p -2 (Unix only)<dd>Restricts usage of 
<TT>lmdown</TT>, 
<I><a name="_IX_425"></a></I><TT>lmreread</TT>, and 
<TT>lmremove</TT> to a 
FLEXlm<I></I> administrator who is by default root. If there is a 
Unix<I></I> group called `<a name="_IX_426"></a>lmadmin' then use is restricted to only 
members of that group. If root is not a member of this 
group, then root does not have permission to use any of the 
above utilities. (Default: no license administrator required). 
Note that all Windows and VMS users are automatically 
considered part of the lmadmin group.<dt><I>-c 
</I><I>license_file_path</I><dd>license file or directory path(s). (default: 
<TT>/usr/local/flexlm/licenses/license.dat</TT> on 
Unix<I></I> systems, or 
<TT>C:\FLEXLM\LICENSE.DAT</TT> on 
Windows and 
Windows NT systems). If a directory is specified, all files 
matching 
<I>*.lic</I> are used. This list is colon-separated on 
Unix, and semi-colon separated on Windows. If redundant 
servers, must be a single file. Server line hostids for all files 
must apply to the same host, but the hostids need not be 
identical.<dt><TT></TT>-l<I> 
<a name="_IX_427"></a>logfile</I><dd><a name="_IX_428"></a>Debug log file produced by the daemons. (default: stdout).<dt>-s<I> 
</I><I>timestamp_interval</I><dd>logfile time stamp interval, in minutes (default: 
360 minutes).<dt><I>-t 
</I><I>timeout_interval</I><dd>time interval (in seconds) during which daemons must 
complete connections to each other. The default value is 10 
seconds. A longer value may be desirable if the daemons 
are being run on busy systems and/or a very heavily loaded 
network.<dt>-x 
<a name="_IX_429"></a>lmdown |<a name="_IX_430"></a> lmremove<dd>disable 
<TT>lmdown</TT> or 
<TT>lmremove</TT> commands.<dt>-z<dd><dd>Run in the foreground. 
<TT>lmgrd</TT> runs in the background by 
default.<dt>-v<dd>Prints 
<TT>lmgrd</TT>'s version number and copyright, then exit.</dl><p><hr>
Note:	The license file pathname can also be specified by setting the environment variable 
<TT><a name="_IX_431"></a>LM_LICENSE_FILE</TT> to the file's pathname. The 
<I>-c</I> path specification will override 
the setting of 
<TT>LM_LICENSE_FILE</TT>.<hr><p>
<h3>7.1.1	 No lmgrd on 
<a name="_IX_432"></a>VMS or 
<a name="_IX_433"></a>Netware</h3>
<p>
Neither 
VMS nor Netware versions of 
FLEXlm<I></I> use 
<TT>lmgrd</TT>, so clients connect directly 
with the vendor daemons. This implies that each vendor daemon is started 
independently as described in the next two sections. 
<p>
<h3>7.1.2	 Starting vendor daemons on VMS</h3>
<p>
The command line for starting a daemon is:<p>
<pre>daemon_name [-c <I>license_file_path</I>] [-l <I>log_file_path</I>]</pre>
</ol></ul><p>
<p>
<dl><dt><I>daemon_name</I> 
<dd>name of the daemon.<dt><I>license_file_path</I> 
<dd>an alternate license file, if the 
<TT>LM_LICENSE_FILE</TT> 
environment variable is not set or if you want to override 
the setting of 
<TT>LM_LICENSE_FILE</TT>.<dt><I>log_file_path</I> 
<dd>an optional log file name. If this option is not selected, the 
logging information will be written to the screen.</dl><p>
The default license file on 
VMS is 
<TT>SYS$COMMON:[SYSMGR]flexlm.dat</TT>. You can set 
a new default in the vendor daemon by editing 
<TT>lsvendor.c</TT> and changing the value of the 
(char *) variable 
<I>default_license_file</I> to be the pathname you wish for the default 
license file for your daemon. The end-user's license administrator can still override this 
setting with either the `-c' command-line option, or by setting the 
<TT>LM_LICENSE_FILE</TT> logical name.<p>
<p><hr>
Note:	On 
VMS, the SYSNAM and SYSLCK privileges are required to run the daemons.<hr><p>
<h3>7.1.3	 Starting Vendor Daemons on 
<a name="_IX_434"></a>Netware</h3>
<p>
Your vendor daemon can be started at the Netware console by loading it:<p>
<pre>	&gt; load vendor.nlm</pre>
</ol></ul><p>
assuming your vendor daemon was named 
<TT>vendor</TT>.<p>
<p>
You can have it automatically start at power up by including a reference to it in the 
<TT>AUTOEXEC.CNF</TT><p>
<h3>7.1.4	 Starting lmgrd on 
<a name="_IX_435"></a>Windows NT 
</h3>
<p>
lmgrd can be started as an application from the 
Windows NT console with the 
-<TT>app</TT> 
option. For example:<p>
<pre>	D:\flexlm&gt; lmgrd -app -c my_lic.dat</pre>
</ol></ul><p>
Alternatively, lmgrd can be installed as a service on a 
Windows NT system so that it 
can be managed from the control panel on NT. You can use the 
FLEXlm<I></I> Control Panel 
(described in the 
FLEXlm<I></I> Programmers Guide) to install lmgrd as a service. This is 
the recommended technique. If you prefer to do a more manual installation of lmgrd 
as a service, the remainder of this section describes how to accomplish this.<p>
<p>
To install lmgrd as a service manually (rather than using the supplied 
FLEXlm<I></I> Control 
Panel), use the 
<TT>INSTALL.EXE</TT> command provided by 
FLEXlm<I></I>. For example:<p>
<pre>	D:\flexlm&gt; install d:\flexlm\lmgrd.exe</pre>
</ol></ul><p>
Note that the full pathname to 
<TT>lmgrd.exe</TT> must follow the install command. You must 
also make sure that the full path name including drive letter for your vendor daemon is 
specified correctly in your license file, 
<TT>c:\flexlm\license.dat</TT>.<p>
<p>
After 
<TT>INSTALL.EXE</TT> is run successfully, lmgrd is installed as a 
Windows NT service 
and will be started automatically each time your system is booted. To start lmgrd right 
after running 
<TT>INSTALL.EXE</TT> without rebooting your system, you may use the Service 
Icon from the 
Windows NT control panel. Look for 
<I>FLEXlm Licensing Service</I> from 
the dialogue box after you double click on the Service icon.<p>
<p>
To remove lmgrd from the registered service list, simple type<I> install remove. 
</I>If you 
wish to customize the 
<TT>INSTALL</TT> program, the source code and makefile for 
<TT>INSTALL.EXE</TT> is included in the 
<TT>UTILS</TT> directory.<p>
<p>
When lmgrd.exe is installed as a service on your system, you may use the following 
procedure to set the license file path for 
lmgrd<I></I> by updating the system registry:<p>
<ol><li>Install 
<TT>lmgrd.exe</TT> as a service as described previously.<li>Run Registry Editor, 
<TT>system32\regedt32.exe</TT></ol>
Select 
<TT>HKEY_LOCAL_MACHINE:SYSTEM:
CurrentControlSet:Control:Session Manager:Environment</TT>From the menu bar, select Edit and then 'Add Value'When the Add Value dialog box is displayed, enter LM_LICENSE_FILE as 
Value Name, and select REG_SZ as Data Type. Click OK.At this point, the String Editor dialog box should appear, enter the full path to the 
license file that you wish to select. Click OK.Exit Registry Editor.<li>Shutdown your system and restart. 
<TT>lmgrd.exe</TT> should now be using the selected 
license file. To verify this, you can view 
<TT>lmgrd.log</TT> in the system32 directory.</ol>
<h3>7.1.5	 Pre 
FLEXlm<I></I> v2.0 Startup Arguments</h3>
<p>
The startup arguments for vendor daemons changed between 
FLEXlm<I></I> v1.x and v2.0. 
If you are running a configuration with a mixture of v1.x and v2.x vendor daemons, 
then you will need to use the 
<TT>-b</TT> option (<B>Note:</B> this is the default in 
FLEXlm<I></I> v3.0 and 
later). Note that it is very rare to encounter 
FLEXlm<I></I> v1.x daemons.<p>
<h3>7.1.6	 <TT></TT><a name="95659: 2head: 6.1.2 Privileged license administration commands"></a>Privileged License Administration Commands</h3>
<p>
If the `-2 -p' startup argument is used to 
<TT>lmgrd</TT>, then the user who issues an 
<TT>lmdown</TT>, 
<TT>lmreread</TT>, or lmremove command must be a `license administrator'. A license 
administrator is:<p>
<ul><li>a member of the `lmadmin' group, or, if no 
<a name="_IX_436"></a>lmadmin group exists,<li>a member of group 0.<B></B></ul><a name="Chapter 8"></a><hr><h1>Chapter 8 
<a name="84465: 1head: 4.3 Configuring Your Vendor Daemon"></a>Configuring Your <a name="_IX_437"></a>Vendor Daemon</h1>
<p>
<TT>The normal installation program (install_flexlm.ftp on Unix, or setup on Windows) 
builds your vendor daemon. The vendor daemon can be modified, via variables in 
mac</TT><TT>hind/lsvendor.c</TT><TT>, but these are normally not suggested or required. Most of the 
variables in this file appear for historic and compatibility reasons, and should 
</TT><I>not</I><TT> be 
used except where required for compatibility reasons.</TT><p>
<p>
When you have completed the necessary edits to 
<TT><a name="_IX_438"></a>lsvendor.c</TT>, the makefile will create 
<TT>lmrandom</TT> and then run the 
<TT>lmrandom</TT> program to randomize your daemon 
configuration information (for additional security), then it builds your vendor daemon. 
A temporary file 
<TT>lsr_vendor.c</TT> is created with the randomized data. One of the functions 
of 
<TT><a name="_IX_439"></a>lmrandom</TT> is to remove the vendor name from the daemon executable file; the 
daemon name is constructed at run-time.<p>
<p><hr>
Note:	You can use the CONFIG_DAEMON -x script to automate editing the 
<TT>lsvendor.c 
</TT>file, 
although we recommend editing the file with a text editor.<hr><p>
<a name="_IX_440"></a><a name="8.1"></a><h2>8.1  Building Your Vendor Daemon - VMS Systems</h2>
<p>
To build your 
<a name="_IX_441"></a>vendor daemon (assuming the 
FLEXlm<I></I> kit is in<I> 
</I><TT>[lmgr]):</TT><p>
<pre><TT>	$ set def [lmgr]</TT></pre>
</ol></ul><p>
	edit 
<TT>lsvendor.c</TT> and 
<I>lm_code.h</I> to select your options and enter your vendor keys and 
encryption seeds.<p>
<pre><TT>	$ @make</TT></pre>
</ol></ul><p>
If you have added initialization or callback routines, you can edit 
<TT>make.com</TT> to add your 
new object files.<p>
<a name="8.2"></a><h2>8.2  Building Your Vendor Daemon - Windows NT Systems</h2>
<p>
build.bat will build your vendor daemon. If you want to build it `by hand' use the 
following commands (assuming the 
FLEXlm<I></I> kit is in 
<TT>C:\flex_sdk</TT>):<p>
<pre>	C:&gt; cd \flex_sdk\i86_n3 (for Intel NT)</pre>
<pre>	C:&gt; nmake /f lmrandom.mak</pre>
<pre>	C:&gt; lmrandom &lt; lsvendor.c &gt; lsr_vend.c</pre>
<pre>	C:&gt; nmake /f demo.mak</pre>
<pre>	C:&gt; ren demo.exe your_vendor_daemon_name.exe</pre>
<a name="_IX_442"></a><a name="8.3"></a><h2>8.3  lsvendor.c variables</h2>
<p>
Instead of using 
<TT>CONFIG_DAEMON -x</TT>, you can edit 
<TT>lsvendor.c.</TT> We do not 
recommend modifying any of these variables. Under nearly all conditions, this file 
should be left as-is. Most of the variables exist for historic reasons.<p>
<h3>8.3.1	 <a name="_IX_443"></a>default_license_file (VMS only)</h3>
<p>
This variable is set to the pathname of the (new) default license file, if the software 
vendor desires to override the 
FLEXlm<I></I> default of:<p>
<pre>	SYS$COMMON:[SYSMGR]FLEXLM.DAT.</pre>
<h3>8.3.2	 ls_a_behavior_ver</h3>
<p>
This can be set to LM_BEHAVIOR_V<I>x</I>, where 
<I>x</I> is 2, 3, 4, 5, 5_1 or 6. The default (0) 
is LM_BEHAVIOR_CURRENT, which is V6 in Version 6.<p>
<h4>See also</h4>
<ul><li><a href="#16715: 1Head: 5.1 LM_A_BEHAVIOR_VER">Section 5.1, `LM_A_BEHAVIOR_VER,' on page 72</a></ul><h3>8.3.3	 <a name="13656: 2Head: 8.3.3 ls_a_check_baddate"></a>ls_a_check_baddate</h3>
<p>
Default is 0. If 1, and the license that would authorize a checkout is expiring, a check 
is made to see if the system date has been set back. If the failure is due to detection of 
system date tampering, the checkout error will be LM_BADSYSDATE.<p>
<h4>See also</h4>
<ul><li><a href="#36879: 1Head: 5.2 LM_A_CHECK_BADDATE">Section 5.2, `LM_A_CHECK_BADDATE,' on page 72</a></ul><h3>8.3.4	 ls_a_license_case_sensitive</h3>
<p>
If 1, licenses are case-sensitive. Default is 0, not case-sensitive.<p>
<h4>See also</h4>
<ul><li><a href="#28127: 1Head: 5.8 LM_A_LICENSE_CASE_SENSITIVE">Section 5.14, `LM_A_LICENSE_CASE_SENSITIVE,' on page 77</a><li></ul><h3>8.3.5	 ls_a_lkey_long</h3>
<p>
If 1, license keys in the license file are 64-bit. Default is 0, short, 48-bit license keys.<p>
<h4>See also</h4>
<ul><li><a href="#19845: 1Head: 5.11 LM_A_LKEY_LONG">Section 5.18, `LM_A_LKEY_LONG,' on page 79</a></ul><h3>8.3.6	 ls_a_lkey_start_date</h3>
<p>
If 1, license keys contain a hidden start-date, and are 4-characters longer. Default is 0, 
no hidden start-date.<p>
<h4>See also</h4>
<ul><li><a href="#14771: 1Head: 5.12 LM_A_LKEY_START_DATE">Section 5.19, `LM_A_LKEY_START_DATE,' on page 79</a></ul><h3>8.3.7	 <a name="10539: 2head: 6.3.3 ls_allow_borrow"></a><TT></TT><a name="_IX_444"></a>ls_compare_vendor_on_increment</h3>
<pre>int ls_compare_vendor_on_increment = 0; /* Compare vendor-defined */</pre>
</ol></ul><p>
INCREMENT lines are combined if the following is true:<p>
<ul><li>The feature names match<li>The feature versions match<li>Any node-lock hostid, if present, matches<li>USER_BASED, HOST_BASED, and CAPACITY matches<li>Optionally, the vendor-defined strings match</ul><p>
ls_compare_vendor_on_increment gives you control over whether an INCREMENT 
line will require the vendor string to match in order to pool its licenses. If set to a non-zero value, then the vendor string must match; if 0, then no comparison is done on the 
vendor string.<p>
<h4>See also</h4>
<ul><li><a href="#79592: 2head: 9.1.3 FEATURE or INCREMENT Line">Section 6.3.4, `FEATURE or INCREMENT Line,' on page 96</a></ul><h3>8.3.8	 <a name="_IX_445"></a>ls_compare_vendor_on_upgrade</h3>
<pre>int ls_compare_vendor_on_upgrade = 0; /* Compare vendor-def fields */</pre>
</ol></ul><p>
<I>ls_compare_vendor_on_upgrade</I> gives you control over whether an UPGRADE line 
will require the vendor string to match in order to upgrade another license. If set to a 
non-zero value, then the vendor string must match; if 0, then no comparison is done on 
the vendor string.<p>
<h4>See also</h4>
<ul><li><a href="#57505: 2head: 9.1.4 UPGRADE Line">Section 6.3.5, `UPGRADE Line,' on page 102</a></ul><h3>8.3.9	 <a name="_IX_446"></a>ls_conn_timeout</h3>
<pre>int ls_conn_timeout = MASTER_WAIT; /* How long to wait for a connection */</pre>
</ol></ul><p>
<I>ls_conn_timeout</I> is the amount of time (in seconds) that vendor daemons will wait for 
connections from vendor daemons on other nodes when using 
<a name="_IX_447"></a>redundant servers. It 
should normally not be changed. This parameter has no effect on 
VMS or Netware 
versions of 
FLEXlm<I></I>.<p>
<h3>8.3.10	 <a name="_IX_448"></a>ls_crypt_case_sensitive</h3>
<pre>int ls_crypt_case_sensitive = 0; /* Is <a name="_IX_449"></a>license key case-sensitive? */</pre>
</ol></ul><p>
If you have written your own authentication routine, and the output code from it is 
case-sensitive, set 
<I>ls_crypt_case_sensitive</I> to a non-zero value.<p>
<h4>See also</h4>
<ul><li><a href="#37464: 2head: 5.1.34 LM_A_USER_CRYPT">Section E.16, `LM_A_USER_CRYPT,' on page 203</a></ul><h3>8.3.11	 <a name="_IX_450"></a>ls_daemon_periodic</h3>
<pre>void (*ls_daemon_periodic)() = 0; /* Vendor-defined periodic call in daemon */</pre>
</ol></ul><p>
If you set the function pointer `ls_daemon_periodic' in 
<TT>lsvendor.c</TT> to one of your 
functions, this function will be called approximately once per minute in the vendor 
daemon's main processing loop. You must ensure that the .o file for this routine is 
linked into your vendor daemon.<p>
<h3>8.3.12	 <a name="_IX_451"></a><a name="24917: 2Head: 7.4.8 ls_do_checkroot"></a>ls_do_checkroot (Unix only)</h3>
<pre>int ls_do_checkroot = 0; /* Perform check that we are running on the real root */</pre>
</ol></ul><p>
To require that your vendor daemon be running on a filesystem which has its root 
directory as the `real' root directory of the disk, set this option. This prevents an end-user from cloning part of the 
Unix<I></I> file hierarchy and executing the daemon with a 
<TT><a name="_IX_452"></a>chroot</TT> command. If this were done, the vendor daemon locking would be bypassed and 
the user could run as many copies of your vendor daemon as he desired.<p>
<p>
Theft by using 
<TT>chroot</TT> is considered to be an obscure, difficult kind of theft. The user 
has to have root permission, and setting up a phony / directory is a non-trivial task. It 
requires that the necessary parts of the OS from 
<TT>/etc</TT>, 
<TT>/dev</TT>, 
<TT>/bin</TT>, etc. be copied into this 
phony 
<TT>/</TT> directory, and is an ongoing administrative hassle.<p>
<p><hr>
Note:	The check performed by 
<I>ls_do_checkroot</I> will FAIL on a diskless node. This prevents 
diskless nodes from acting as license servers. 
GLOBEtrotter Software<I></I> does NOT 
recommend running license daemons on diskless nodes, but if you choose to support 
this, you will need to set ls_do_checkroot to 0. For complete security, set 
<I>ls_do_checkroot</I> to 1. For minimization of confusion and support calls when your 
customers are running on diskless nodes, set 
<I>ls_do_checkroot</I> to 0.<hr><p>
<h3>8.3.13	 <a name="_IX_453"></a>ls_dump_send_data</h3>
<pre>int ls_dump_send_data = 0; /* Set to non-zero value for debug output */</pre>
</ol></ul><p>
This variable controls the debug output of transmitted daemon data. It should normally 
be left set to 0.<p>
<h3>8.3.14	 <a name="_IX_454"></a>ls_enforce_startdate</h3>
<pre>int ls_enforce_startdate = 1; /* Enforce start date in features */</pre>
</ol></ul><p>
To use the start date present in the feature line, set 
<I>ls_enforce_startdate</I> to a non-zero 
value.<p>
<h3>8.3.15	 <TT></TT><a name="_IX_455"></a>ls_infilter</h3>
<pre>int (*ls_infilter)() = 0;</pre>
</ol></ul><p>
To install a vendor-defined 
<a name="_IX_456"></a>checkin filtering routine, initialize 
<I>ls_infilter</I> with a pointer 
to your routine. The checkin filter is called with no parameters. If it returns 0, the 
current checkin is aborted; a return of 1 allows the current checkin to continue. If the 
filter aborts the operation (returns 0), then it should set the error code, via 
<I>lc_set_errno(lm_job, errno)</I>, appropriately. 
<p>
<p>
To obtain the parameters of the current checkin call, use the 
ls_get_attr() call described 
in 
<a href="#92354: 1head: 4.5 Vendor daemon support routines">Section 8.4, `Vendor Daemon Support Routines,' on page 135</a>.<p>
<h3>8.3.16	 <a name="_IX_457"></a>ls_incallback</h3>
<pre>int (*ls_incallback)() = 0;</pre>
</ol></ul><p>
To install a vendor-defined c<a name="_IX_458"></a>heckin callback routine, initialize 
<I>ls_incallback</I> with a 
pointer to your routine. The checkin callback is called with no parameters, and the 
return value is unused. The checkin callback routine is called after the checkin is 
performed.<p>
<p>
To obtain the parameters of the current checkin call, use the 
ls_get_attr() call described 
in 
<a href="#92354: 1head: 4.5 Vendor daemon support routines">Section 8.4, `Vendor Daemon Support Routines,' on page 135</a>.<p>
<h3>8.3.17	 <a name="66148: 2head: 6.3.14 ls_min_lmremove"></a>ls_min_lmremove</h3>
<pre>int ls_min_lmremove = 120; /* Minimum amount of time (seconds) that a...</pre>
</ol></ul><p>
The 
<TT>lmremove</TT> utility could be used to bypass the license count for a feature if an end-user were to run 
<TT>lmremove</TT> on each user as soon as he had checked out a license. 
<I>ls_min_lmremove</I> makes the 
<TT>lmremove</TT> utility ineffective for a certain period of time 
after a user connects to the daemon (120 seconds by default). 
<p>
<h3>8.3.18	 <a name="52105: 2head: 6.3.17 ls_minimum_user_timeout"></a>ls_minimum_user_timeout</h3>
<pre>int ls_minimum_user_timeout = 900; /* Minimum user inactivity timeout (seconds)</pre>
</ol></ul><p>
This is the minimum value (in seconds) that an end-user can set the feature's 
TIMEOUT value. An attempt to set a 
<a name="_IX_459"></a>timeout less than 
<I>ls_minimum_timeout</I> will result 
in the minimum value being set. If 
l<I>s_minimum_user_timeout</I> is set to 0, then the user 
TIMEOUT option is disabled.<p>
<h3>8.3.19	 <a name="_IX_460"></a>ls_read_wait</h3>
<pre>int ls_read_wait = 10; /* How long to wait for solicited reads */</pre>
</ol></ul><p>
This variable controls how long the vendor daemon will wait for a connection to be 
completed with another vendor daemon. The default is 10 seconds. If your daemon 
supports a large number of features, you may need to increase this value, since the 
remote daemon's feature initialization can happen during this timeout interval.<p>
<h3>8.3.20	 <a name="_IX_461"></a>ls_outfilter</h3>
<pre>int (*ls_outfilter)() = 0;</pre>
</ol></ul><p>
To install a vendor-defined c<a name="_IX_462"></a>heckout filtering routine, initialize 
<I>ls_outfilter</I> with a 
pointer to your routine. The checkout filter is called with no parameters. If it returns 0, 
your routine has either checked out the feature, or rejected the checkout request. If it 
returns 1, then the normal server checkout occurs<p>
<p>
If 0 is returned and the checkout fails, set the error code appropriately with 
lc_set_errno().<p>
<p>
To obtain the parameters of the current checkout call, use the 
ls_get_attr()<I> 
</I>call 
described in 
<a href="#92354: 1head: 4.5 Vendor daemon support routines">Section 8.4, `Vendor Daemon Support Routines,' on page 135</a>.<p>
<p><hr>
Note:	Please contact Globetrotter support before using ls_outfilter. Callbacks in this area 
are rarely needed, and we're happy to provide assistance when they are.<hr><p>
<h3>8.3.21	 <a name="_IX_463"></a>ls_show_vendor_def</h3>
<pre>int ls_show_vendor_def = 0; /* If non-zero, the vendor daemon will send...</pre>
</ol></ul><p>
Your client can send a vendor-defined checkout string to the daemon on each checkout 
request. If 
<I>ls_show_vendor_def</I> is non-zero, this data will appear in 
lc_userlist() calls, 
and hence, in 
<TT>lmstat</TT> output. If you use this vendor-defined checkout data and wish for 
your users to be able to view it with 
<TT>lmstat</TT>, then set 
<I>ls_show_vendor_def</I> to 1.<p>
<h3>8.3.22	 <a name="_IX_464"></a>ls_tell_startdate</h3>
<pre>int ls_tell_startdate = 1; /* Tell the user if it is earlier than start date */</pre>
</ol></ul><p>
To inform the user that a feature's start date is later than the system date, set 
<I>ls_tell_startdate</I> to a non-zero value. If 
<I>ls_tell_startdate</I> is 0, then the feature will not 
be enabled in the daemon, and no warning message will appear in the log file.<p>
<h3>8.3.23	 <a name="13021: 2head: 6.3.20 ls_use_featset"></a>ls_use_featset</h3>
<pre>int ls_use_featset = 0; /* Use the FEATURESET line from the license file */</pre>
</ol></ul><p>
To require the 
<a name="_IX_465"></a>FEATURESET line in the license file, set 
<I>ls_use_featset</I> to a non-zero 
value.<p>
<h4>See also</h4>
<ul><li><a href="#69035: 2head: 8.1.5 FEATURESET Line">Section 6.3.7, `FEATURESET Line,' on page 105</a></ul><h3>8.3.24	 <a name="_IX_466"></a><a name="53119: 2head: 6.3.22 ls_use_all_feature_lines"></a>ls_use_all_feature_lines</h3>
<pre>int ls_use_all_feature_lines = 0; /* Use ALL copies of feature lines that are...</pre>
<p><hr>
Note:	GLOBEtrotter Software<I></I> strongly discourages your use of this option, which has been 
made unnecessary and obsolete by the 
<a name="_IX_467"></a>INCREMENT and 
<a name="_IX_468"></a>UPGRADE features. The 
ls_use_all_feature_lines option will cause your vendor daemon to process every 
FEATURE line in the license file as INCREMENT lines. 
<hr><p>
<p>
With 
ls_use_all_feature_lines set to a non-zero value, any old feature lines which you 
may have shipped will now be `legal', so, for example, if you had shipped a customer 
a feature line with a count of 5, then upgraded them with a new line with a count of 7, 
they would now be able to use 12 licenses.<p>
<h4><TT></TT>See also</h4>
<ul><li><a href="#79592: 2head: 9.1.3 FEATURE or INCREMENT Line">Section 6.3.4, `FEATURE or INCREMENT Line,' on page 96</a></ul><h3>8.3.25	 <a name="_IX_469"></a>ls_user_init1</h3>
<pre>void (*ls_user_init1)() = 0;</pre>
</ol></ul><p>
To install an initialization routine that runs before normal vendor daemon initialization, 
initialize 
<I>ls_user_init1</I> with a pointer to your routine.<p>
<h3>8.3.26	 <a name="_IX_470"></a>ls_user_init2</h3>
<pre>void (*ls_user_init2)() = 0;</pre>
</ol></ul><p>
To install an initialization routine that runs after normal vendor daemon initialization, 
initialize 
<I>ls_user_init2</I> with a pointer to your routine and make sure an object file with 
this function is linked with your vendor daemon.<p>
<h3>8.3.27	 <a name="73612: 2head: 6.3.24 ls_vendor_msg"></a>ls_vendor_msg</h3>
<pre>char *(*ls_vendor_msg)() = 0;</pre>
</ol></ul><p>
To add support for sending messages from your client code to the daemon (with 
<I><a name="_IX_471"></a>lc_vsend()</I>), initialize 
<I>ls_vendor_msg</I> with a pointer to your routine which will process 
the message and create the reply for the client. 
ls_vendor_msg()<I> 
</I>is called with a single 
parameter - the character string sent by the client. It should create a reply message and 
return a pointer to it. The message string will be unused the next time that 
ls_vendor_msg() is called, so the use of a single static char array in 
ls_vendor_msg() 
is appropriate. Make sure an object file with this routine is linked with your vendor 
daemon.<p>
<h4>See also</h4>
<ul><li><a href="#40445: 2head: 3.3.41 lc_vsend">Section 4.33, `lc_vsend,' on page 56</a></ul><h3>8.3.28	 <a name="_IX_472"></a><a name="34134: 2head: 7.4.24 ls_user_crypt"></a>ls_user_crypt</h3>
<pre>char *(*ls_user_crypt)() = 0;</pre>
</ol></ul><p>
To use your own authentication routine, initialize 
ls_user_crypt with a pointer to your 
routine, and make sure an object file with this routine is linked with your vendor 
daemon. This must be the same as 
<a name="_IX_473"></a>LM_A_USER_CRYPT.<p>
<h4>See also</h4>
<ul><li><a href="#33883: 2head: 3.4.8 lc_cryptstr">Section 4.10, `lc_cryptstr,' on page 36</a><li><a href="#37464: 2head: 5.1.34 LM_A_USER_CRYPT">Section E.16, `LM_A_USER_CRYPT,' on page 203</a></ul><h3>8.3.29	 <a name="_IX_474"></a>ls_user_lockfile</h3>
<pre>char *user_lockfile = (char *)NULL;</pre>
</ol></ul><p>
The vendor daemons use a lock file to prevent multiple copies from running on a server 
host. The lockfile names are (where 
<I>daemon</I> is the vendor daemon name, as on the 
VENDOR line in the license file):<p>
<dl><dt>Unix<dd>/usr/tmp/lock<I>daemon</I>. On some newer systems, including 
DEC Alpha, the location is /usr/tmp/.flexlm/.lock<I>daemon.</I><dt>Windows (32-bit)<dd>C:\FLEXLM\<I>daemon</I><dt>Netware<dd>SYS:\\FLEXLM\<I>daemon</I><dt>VMS<dd>Unused in VMS, since the VMS lock manager is used.<dt>If 
<I>ls_user_lockfile</I> is NULL, or points to a null string, the default lock file will be used.</dl><p>
The date on the lock file is updated every 6 hours to make it less likely that cron jobs 
will remove it.<p>
<p>
If you wish to change the location of the lock file, set 
<I>ls_user_lockfile 
</I>to the new 
location. Be sure to use a full pathname for this file (i.e. on Unix the pathname should 
start with `/') otherwise, multiple vendor daemons could be run from different 
directories.<p>
<h3>8.3.30	 <a name="_IX_475"></a>Vendorkeys and Vendor 
<a name="_IX_476"></a>Encryption Seeds</h3>
<pre>VENDORCODE vendorkeys[] =.....</pre>
</ol></ul><p>
Example from 
<TT>lm_code.h</TT>:<p>
<pre>/*</pre>
<pre>* 	VENDOR's private encryption seeds  -  must be changed by vendor</pre>
<pre>* 	vendor should make up two unique 32-bit hex numbers.</pre>
<pre>*/ </pre>
<pre>#define ENCRYPTION_SEED1 0x87654321</pre>
<pre>#define ENCRYPTION_SEED2 0x12345678</pre>
<pre>/*</pre>
<pre> *      FLEXlm vendor keys</pre>
<pre> */ </pre>
<pre>#define VENDOR_KEY1 0xe7503c03</pre>
<pre>#define VENDOR_KEY2 0x75811bed</pre>
<pre>#define VENDOR_KEY3 0xb8ea89c8</pre>
<pre>#define VENDOR_KEY4 0xc9a1b6d3</pre>
<pre>#define VENDOR_KEY5 0xc5dda903</pre>
</ol></ul><p>
The ENCRYPTION_SEEDs are to be made up by the 
FLEXlm<I></I> developer; the 
VENDOR_KEYS are supplied by 
GLOBEtrotter Software<I></I> when you purchase or 
upgrade 
FLEXlm<I></I>.<p>
<p>
<TT><a name="_IX_477"></a>CONFIG_DAEMON</TT> edits lm_code.h (or you can edit it manually) with the encryption 
seeds and vendor keys that you specified for your daemon. When your vendor daemon 
comes up, it checks all feature lines that specify its daemon name. If the license key in 
the license file is valid for any feature lines that the daemon checks, and the hostid is 
correct, then the vendor daemon sets the number of licenses to the value in the license 
file. All components of 
FLEXlm<I></I> must share the same lm_code.h, where the 
VENDORCODE is specified. 
<I>This encryption seed is the unique part of your daemon</I>, 
so it is wise to<p>
<ul><li>keep it confidential<li>make sure the encryption seeds are unique numbers you have made up.</ul><p>
Each entry in the VENDORCODE array consist of a pair of 32-bit vendor-defined 
encryption seed values and a set of five 32-bit 
GLOBEtrotter Software<I></I> supplied 
FLEXlm<I></I> Vendor Keys. The two 32-bit vendor-defined encryption seeds should be set 
to any values that do not contain long strings of either 0 or 1 bits (e.g. do not use 0x5 
or 0xffffff3f). The 
FLEXlm<I></I> Vendor Keys supplied by 
GLOBEtrotter Software<I></I> enable 
various portions of the 
FLEXlm<I></I> software to run. Both the first set of vendor-defined 
encryption seeds and the 
FLEXlm<I></I> Vendor Keys will be defined in the include file 
<TT><a name="_IX_478"></a></TT>lm_code.h by 
<TT>CONFIG_DAEMON</TT>.<p>
<p><hr>
Note:	Only the encryption seeds, which you define, affect the licenses you create. The 
FLEXlm<I></I> vendor keys have no effect on the license files you create.<hr><p>
<a name="92354: 1head: 4.5 Vendor daemon support routines"></a><a name="8.4"></a><h2>8.4  Vendor Daemon Support Routines</h2>
<p>
ls_get_attr is required for applications using the 
<I>ls_outfilter()</I> callback:<p>
<pre>	<a name="_IX_479"></a>ls_get_attr(attr, &amp;value)</pre>
</ol></ul><p>
<p>
<dl><dt><I>attr</I><dd> an attribute specified in 
<TT><a name="_IX_480"></a>ls_attr.h</TT><dt><I>value</I><dd> (char *) - the value of the attribute.</dl><p>
ls_get_attr() operates in the same manner as 
lc_get_attr(). 
ls_get_attr() allows you to 
retrieve the values of the feature name, user, host, display, etc. for use in your filtering 
function.<p>
<p>
The 
ls_checkout() vendor daemon routine is available for use in daemon filter routines:<p>
<pre><TT>	ls_checkout(</TT><I>feature</I>, <I>ndesired</I>, <I>wait</I>, <I>who</I>, <I>version</I>, <I>server</I>, <I>dup_sel</I>, <I>linger</I>, <I>key,</I> 0,0);</pre>
</ol></ul><p>
<p>
<dl><dt>(char *) 
<I>feature</I><dd>feature desired<dt>(char *) 
<I>ndesired</I><dd>Number of licenses<dt>(char *) 
<I>wait</I><dd>`Wait until available' flag if (*wait == '1'), the request will 
be queued if a license is not available.<dt>(CLIENT_DATA *) who<dd>the user<dt>(char *) 
<I>version</I><dd>Feature's version number<dt>(SERVERNUM) 
<I>server</I><dd>Server requesting the checkout<dt>(char *) 
<I>dup_sel</I> 
<dd>Duplicate license selection criteria<dt>(char *) 
<I>linger</I><dd>How long license is to linger<dt>(char *) 
<I>key</I><dd>License key from feature line</dl><h3>Return</h3>
<p>
0 -&gt; checkout not available, &gt; 0 -&gt; checkout done, &lt; 0 -&gt; request queued<p>
<p><hr>
Note:		ls_get_attr() can be used to retrieve all the parameters that 
ls_checkout()<I> 
</I>requires.<hr><p>
<a name="Chapter 9"></a><hr><h1>Chapter 9 <a name="16570: ChapTitle: Chapter 9 Redundant License Servers"></a>
<a name="_IX_481"></a>Redundant License Servers</h1>
<p>
FLEXlm<I></I> supports two methods of redundancy: A set of three redundant license 
servers, and redundancy via a license file list in the $LM_LICENSE_FILE setting.<p>
<p>
With three-server redundancy, if any two of the three license servers are up and 
running, the system is functional and hands out its total complement of licenses (Two 
out of three license servers is referred to as a `quorum').<p>
<p>
With $LM_LICENSE_FILE, the application attempts a checkout from every server in 
the license file list. When used for redundancy, the ISV divides the licenses among any 
number of servers, and the end-user set $LM_LICENSE_FILE to address all the 
servers.<p>
<a name="9.1"></a><h2>9.1  Three-server redundancy</h2>
<h3>9.1.1	 Selecting Server Nodes</h3>
<a name="_IX_482"></a><a name="_IX_483"></a><p>
If all the end-user data is on a single file server, then there is no need for redundant 
servers, and 
GLOBEtrotter Software<I></I> recommends the use of a single server node for 
the 
FLEXlm<I></I> daemons. If the end-user's data is split among two or more server nodes 
and work is still possible when one of these nodes goes down or off the network, then 
multiple server nodes can be employed. In all cases, an effort should be made to select 
stable systems as server nodes; in other words, do not pick systems that are frequently 
rebooted or shut down for one reason or another.<p>
<p>
These three redundant servers should be on the same local-area network, and should 
have excellent communications. This form of redundancy requires that the servers 
exchange heartbeats periodically, and poor communications can cause performance 
problems.<p>
<h3>9.1.2	 Generating a license file for redundant servers.</h3>
<p>
To generate a license file that uses redundant servers, simply specify three servers 
when you create your license. Note that the use of two license servers is not 
recommended, since a license file with two servers would require that you always had 
both running.<p>
<p><hr>
Note:	The 
<a name="_IX_484"></a>VMS and 
<a name="_IX_485"></a>Netware versions of 
FLEXlm<I></I> do not support redundant servers.<hr><p>
<p>
When redundant servers are started, they elect a 
<I>master, 
</I>which performs all licensing 
operations. The other one or two servers are there to provide a secure licensing 
mechanism in the event of hardware failure or in case the server node needs to be 
rebooted. Should the master fail, if two servers are still running, one of the remaining 
two will be elected master, and licensing operations will continue.<p>
<p>
The order of 
<a name="_IX_486"></a>SERVER lines in the license file (for redundant servers) specifies the end-user's desired selection order for the master server node. If the order of these lines does 
not agree on all three server nodes, then 
FLEXlm<I></I> uses alphabetical order to determine 
the master, and the following messages are generated in the log file:<p>
<pre>	6/26 11:00 (lmgrd) License File SERVER line order mismatch.</pre>
<pre>	6/26 11:00 (lmgrd) Using alphabetical order </pre>
</ol></ul><p>
If the server order does not match, the daemons will come up initially, but reconnection 
in the event of server node failure may not work, depending on which node fails and 
who was the master before the failure. If the automatic failover in the event of node 
failure is important, please ensure that the order of the server lines is consistent in the 
license file on all server nodes.<p>
<p>
When only two of the three license server machines are up, it is possible for the client 
to experience a timeout before connecting to the license server. Specifically, if the first 
license server in the license file is down, the client will timeout before attempting to 
connect to the second server in the license file. This timeout is set to 10 seconds by 
default, so there will be a 10-second delay before the license is granted. If the first 
server is to be down for a while, the order of the SERVER lines in the license file which 
the client reads could be changed to avoid this timeout.<p>
<h3>9.1.3	 Sample three-server license file</h3>
<pre>SERVER pat 17003456 1700</pre>
<pre>SERVER lee 17004355 1700</pre>
<pre>SERVER terry 17007ea8 1700</pre>
<pre>VENDOR demo /etc/mydaemon</pre>
<pre>FEATURE f1 demo 1.0 1-jan-1999 10 1AEEFC8F9003</pre>
<pre>FEATURE f2 demo 1.0 1-jan-1999 10 0A7E8C4F5613</pre>
</ol></ul><p>
Note that there may need to be 3 separate versions of this file, identical, except for the 
path to the VENDOR, which may be different on nodes `pat,' `lee' and `terry.'<p>
<a name="_IX_487"></a><a name="9.2"></a><h2>9.2  Redundancy via License File List in $LM_LICENSE_FILE</h2>
<p>
This is best explained by example. In the previous license, there is a count of 10 for 
both f1 and f2. For redundancy, the ISV would issue 2 licenses with a count of 5 for f1 
and f2, and each license would have 1 server line. The server nodes (unlike three-server 
redundancy) can be physically distant. The license files would look like:<p>
<ul><li>License 1 for chicago</ul><pre>	SERVER chicago 17007ea8
	VENDOR demo 
	FEATURE f1 demo 1.0 1-jan-1999 5 26C7DD9CD665
	FEATURE f2 demo 1.0 1-jan-1999 5 0739D2F78CE4</pre>
<ul><li>License 2 for tokyo</ul><pre>	SERVER tokyo 17007ea8
	VENDOR demo 
	FEATURE f1 demo 1.0 1-jan-1999 5 16BE40E1DAEE
	FEATURE f2 demo 1.0 1-jan-1999 5 6DB6F3E40E61</pre>
</ol></ul><p>
The user in Chicago could set $LM_LICENSE_FILE to 
<p>
<pre>@chicago:@tokyo </pre>
</ol></ul><p>
the user in Tokyo could set $LM_LICENSE_FILE to 
<p>
<pre>@tokyo:@chicago</pre>
</ol></ul><p>
The application attempts the first server in the list, and if that fails for any reason, the 
second server is tried.<p>
<a name="9.3"></a><h2>9.3  Comparing three-server to License File List</h2>
<h4>Are there any drawbacks to using the license file list for redundancy?</h4>
<p>
Yes. By default, once a job (lc_new_job()) has successfully checked out a license from 
one host, all subsequent checkouts must be satisfied from the same host. If the 
application requires more than one FEATURE, then this could result in a license denial 
when the license may be available on another server. An application can bypass this 
restriction with the use of multiple 
FLEXlm<I></I> `license jobs'.<p>
<p>
If the application supports license queueing, all licenses are only queued from the first 
host on the list.<p>
<p>
Finally, if one server becomes unavailable, some licenses will be unavailable.<p>
<h4>When is it recommended to use a license file list for redundancy rather 
than true redundant servers? 
</h4>
<p>
When there's less system administration time available to monitor license servers, and 
when the applications are not mission-critical. The license file list has some other 
advantages: it's more forgiving if you lose quorum; it's not limited to 3 servers (any 
number will work); and for wide-area networks, you can make servers available 
locally, with remote servers available as backup.<p>
<a name="Chapter 10"></a><hr><h1>Chapter 10 
<a name="_IX_488"></a>Debugging Hints</h1>
<a name="10.1"></a><h2>10.1  Debugging Your Application Code</h2>
<p>
There are several issues to be aware of when debugging your 
FLEXlm<I></I> integrated 
application. Some of these are described in this chapter.<p>
<ul><li>If you are experiencing problems on only one platform (or if you run on only a 
single platform), please check the appropriate platform-specific notes in 
<a href="#17446: chap head: Chapter 11">Chapter 12, `Unix and VMS Platform-Specific Notes' on page 149</a> or 
<a href="#34811: ChapTitle: Chapter 15 Windows, Win32s, and Windows NT">Chapter 13, `Windows 95/98, and Windows NT' on page 155</a>.<li>FLEXlm<I></I> makes use of, and depends on, the C standard I/O library and system 
calls. If you redefine any of the section 2 or section 3 calls, 
<I>you will get 
unpredictable results</I>.<li>On Unix, the 
<I><a name="_IX_489"></a>sleep(3)</I>, 
<I><a name="_IX_490"></a>pclose(3)</I>, and 
<I><a name="_IX_491"></a>system(3)</I> calls often do not work with 
FLEXlm<I></I>'s default use of 
<a name="_IX_492"></a>SIGALRM. If you must use these calls, disable 
FLEXlm<I></I> 
timers with 
<TT>LM_A_CHECK_INTERVAL</TT> set to -1, and call 
<I><a name="_IX_493"></a>lc_timer()</I> 
periodically.<li>On Unix, 
FLEXlm<I></I> installs a handler for 
<a name="_IX_494"></a>SIGPIPE and SIGALRM. If your 
application uses 
FLEXlm<I></I> timers and forks/execs another process, these signals 
must be restored to the default before the fork/exec, and then re-restored in the 
parent process. See signal(3) for details. If you fail to do this, the child process 
will fail with a segmentation violation, since the signal handler will not exist in 
the child process. This is due to the fact that the child inherits the signal handler 
setting of the timer, but it does not inherit the signal handler code.<li>FLEXlm<I></I>, by default, uses SIGALRM to check the health of the connection. This 
cannot be tolerated by certain applications (for example, applications that use 
XView or FORTRAN). These applications should set the 
<I>LM_A_CHECK_INTERVAL and LM_A_RETRY_INTERVAL attributes</I> to -1 with 
lc_set_attr(). After checking out a license, the application must periodically call 
lc_timer() to keep checking the health of the connection.<li>If the daemon log file is missing, be sure that you are using bourne shell syntax 
in the startup file. In particular, do not use 
<I>csh</I>-style redirection 
<I>&gt;&amp;</I> in one of the 
<I>rc</I> startup files.</ul><p>
If the 
FLEXlm<I></I> timers are used to perform checking and/or reconnection, non-reentrant 
routines can possibly be called in the C run-time library. We have verified that the 
routines called by the timers are free of 
<I>malloc</I>/<I>free</I> reentrancy problems, since these 
are detectable by Purify, but there may be other, especially I/O or system routines 
which are not reentrant, but called by 
FLEXlm<I></I>. The only way to be certain to avoid this 
problem would be to disable the 
FLEXlm<I></I> timers and call 
lc_timer() directly.<p>
<h4>See also</h4>
<ul><li><a href="#21737: 1Head: 4.22 lc_heartbeat">Section 4.22, `lc_heartbeat,' on page 46</a></ul><a name="10.2"></a><h2>10.2  Solving Problems In The Field</h2>
<p>
The most important thing is to use 
<I>lc_errstring</I>, 
<I>lp_errstring</I> or 
<I>ERRSTRING</I> to present 
the correct error message to your user for diagnosis. Here are 2 common problems that 
occur in the field.<p>
<ul><li>`License server does not support this feature'</ul><p>
This indicates that the client and servers are reading 2 different copies of the 
license file. This can be remedied by inserting a USE_SERVER line after the 
SERVER line in the license file (v5 or later).<p>
<ul><li>`Encryption code in license file is inconsistent'</ul><p>
FLEXlm<I></I> will report the error `encryption code in license file is inconsistent' 
(<TT><a name="_IX_495"></a>LM_BADCODE</TT>, -8) in a number of situations.<p>
<p>
In general, the 
<TT>LM_BADCODE</TT> error occurs when:<p>
 - The license file has been mis-typed, or changed since it was created. - The encryption seeds in your application, vendor daemon, and license creation 
program differ.<p>
If you are beginning to integrate your application with 
FLEXlm<I></I>, this error is 
usually the result of not building all the software components with the same 
encryption seeds. Check 
<I>lmcrypt.c, makekey.c</I>, 
<I>lsvendor.c</I>, and your 
application code carefully to insure that they are all built with the same encryption 
seeds. If this is the case, you simply need to make sure that your application, 
<TT>lmcrypt, makekey</TT>, and your vendor daemon have all been re-built since the last 
time that you changed lm_code.h, and that there is only one lm_code.h file.<p>
<p>
If your customer has this error, use the 
<TT>lmcksum</TT> command to locate the line that 
was mis-typed.<p>
<p>
If you suspect that the license file has been generated incorrectly, here's how you 
can tell:<p>
<pre>	% lmcrypt -i <I>file</I> -f -o <I>tmp</I></pre>
<pre>	% diff <I>file tmp</I></pre>
</ol></ul><p>
			lmcrypt should regenerate an identical file. If not, the file is bad, and the new file, 
in this example 
<I>tmp</I>, is good.<p>
<a name="_IX_496"></a><a name="10.3"></a><h2>10.3  Multiple Vendors Using FLEXlm<I></I> At A Single End-User Site</h2>
<p>
In the case where multiple software vendors install 
FLEXlm<I></I>-based products at a single 
end-user site, the potential for license file location conflicts arises. This section 
summarizes strategies that allow for a minimum of end-user inconvenience.<p>
<p>
There are basically two cases involved at an end-user site when more than one software 
vendor installs products.<p>
<h4>Case 1</h4>
<p>
All products use the same license server node(s).<p>
<p>
In this case, there are two solutions:<p>
<ul><li>The end-user can keep both license files separate, running one lmgrd with a 

license-file list of both files. There are compatibility issues that may arise with 
this method if some vendor daemons and/or applications are older than version 6.<li>The end-user can keep both license files separate, running two 
<TT>lmgrds, one for 
each file. There are no drawbacks to this approach, since the lmgrd processes 
require few system resources.</TT></ul><p><hr>
Note:	When using 2 separate license files, make sure the port numbers are different, or 
leave them blank for 
FLEXlm<I></I> to automatically find an open port.<hr><p>
<ul><li>You can combine license files by taking the set of SERVER lines from any one 
license file, and add all the other lines (VENDOR, FEATURE, INCREMENT, 
PACKAGE, UPGRADE, and 
<a name="_IX_497"></a>FEATURESET lines) from all the license files. The 
combined license file can be located in the default location 
<TT>(/usr/local/flexlm/licenses/license.dat</TT> on 
Unix<I></I> platforms and 
<TT>C:\FLEXLM\LICENSE.DAT</TT> on 
Windows and 
Windows NT) or in any 
convenient location (with the end-user using the 
<TT>LM_LICENSE_FILE</TT> 
environment variable), or multiple copies can be located at fixed locations as 
required by the various software vendors. The user should leave a symbolic link 
to the original license file in the locations where each software package expects 
to find its license file.</ul><p>
In practice, sites that have experienced system administrators often prefer to combine 
license files. However, sites with relatively inexperienced users, and no system 
administrator, usually do better leaving the files separate.<p>
<h4>See Also</h4>
<ul><li><a href="#35936: 1head: 9.2 Locating the License File">Section 6.5, `Locating the License File,' on page 108</a></ul><h4>Case 2 
</h4>
<p>
The products use different license server node(s).<p>
<p>
In this case, separate license files will be required, one for each distinct set of license 
servers (where multiple software vendors use the same set of license server nodes, the 
technique described in case 1 above can be used to combine their license files).The 
resulting (multiple) license files can then be 
		installed in convenient locations, and the 
user's 
<a name="_IX_498"></a><TT>LM_LICENSE_FILE</TT> environment variable would be set as follows.<p>
<pre>%  setenv LM_LICENSE_FILE lfpath1:lfpath2:....:lfpathN</pre>
</ol></ul><p>
<p>
<pre>	lfpath1 - is the path to the first license file 			</pre>
<pre>	lfpath2 - is the path to the second license file. </pre>
<pre>	.</pre>
<pre>	.</pre>
<pre>	lfpathN - is the path to the last (Nth) license file 			</pre>
</ol></ul><p>
When products from different vendors use different versions of 
FLEXlm<I></I>, always use 
the latest versions of 
<TT>lmgrd</TT> and the 
<TT>lmutil</TT> utilities.<p>
<p>
The latest version of 
<TT>lmgrd</TT> will always support any 
FLEXlm<I></I> license. The end-user has 
to find out which 
<TT>lmgrd</TT> at their site is the latest version. This can be done using<I> lmgrd 
-v</I> to get the version. If an earlier version of 
<TT>lmgrd</TT> is used than the vendor daemon, then 
various errors may occur, especially `Vendor daemon can't talk to lmgrd (invalid 
returned data from license server).'<p>
<a name="10.4"></a><h2>10.4  FLEXlm<I></I> Version Compatibility</h2>
<p>
When an end-user has licensed products that incorporate various versions of 
FLEXlm<I></I>, 
care must be taken to insure that the correct versions of 
<TT>lmgrd</TT> and the 
FLEXlm<I></I> utilities 
are used. The rule is that the most recent (highest version number) 
<TT>lmgrd</TT> and utilities 
should be used.<p>
<p>
To determine the version of any 
FLEXlm<I></I>-based product, use the following command:<p>
<pre>	% lmver program_name</pre>
</ol></ul><p>
On Unix systems, you can also use:<p>
<pre>	% strings program_name | grep Copy</pre>
<a name="Chapter 11"></a><hr><h1>Chapter 11 <TT>
</TT><TT></TT><a name="66148: 1head: 11.5 Communications Transport (TCP vs. UDP)"></a><a name="_IX_499"></a>Communications Transport </h1>
<p>
FLEXlm<I></I> supports the UDP connectionless transport, in addition to the default TCP 
connection-based transport. Note that this does not apply to 
<a name="_IX_500"></a>VMS systems. See 
<a href="#42036: 2head: 14.9.1 Communications transport">Section 12.8.1, `Communications transport,' on page 151</a> for a discussion of 
VMS 
communications transport.<p>
<a name="_IX_501"></a><p>
TCP, the default, is recommended for the following reasons:<p>
<ul><li>With TCP, the server knows immediately when the client exits. It is therefore not 
essential that the client call CHECKIN.<li>In our tests, TCP and UDP behave identically with regards to speed.<li>The only drawback to TCP is that the vendor daemon process requires a file 
descriptor per client. On modern OSs, a single process can handle 1000 or more 
file descriptors by default, and this number can usually be increased with a kernel 
parameter. Therefore this is not usually a drawback of any consequence.</ul><a name="UDP"></a><a name="11.1"></a><h2>11.1  How to Select UDP Connections</h2>
<p>
UDP can be selected by the application or by the end-user, in the following ways:<p>
<ol><li>The application can call:<pre>	 lc_set_attr(<a name="LM_A_COMM_TRANSPORT"></a>LM_A_COMM_TRANSPORT, LM_UDP);</pre>
<li>The end-user can set the comm transport with the 
<a name="FLEXLM_COMM_TRANSPORT"></a><TT>FLEXLM_COMM_TRANSPORT</TT> environment variable:<pre>	% setenv FLEXLM_COMM_TRANSPORT UDP</pre>
<li>The comm transport can be selected in the daemon options file, with the line:<pre>	<a name="_IX_502"></a>TRANSPORT UDP</pre>
</ol></ul><p>
or<p>
<pre>	TRANSPORT TCP</pre>
</ol></ul><p>
The application can prevent the user from setting the 
<a name="TRANSPORT"></a>TRANSPORT mode via: 
<p>
<pre>	lc_set_attr(<a name="_IX_503"></a>LM_A_ALLOW_SET_TRANSPORT, 0);</pre>
</ol></ul><p>
The environment variable and options file settings are disabled with this call.<p>
<p>
FLEXlm<I></I> defaults to TCP, and all the above options can be set to TCP. The order of 
precedence is (higher number takes precedence over lower number):<p>
<ol><li>default TCP<li>Options file specified 
 -  
<TT><a name="_IX_504"></a>COMM_TRANSPORT</TT><li>Environment variable specified 
 -  
<TT><a name="_IX_505"></a>FLEXLM_COMM_TRANSPORT</TT><li><TT><a name="_IX_506"></a>LM_A_ALLOW_SET_TRANSPORT</TT> == false, Options file and Environment 
variable are disabled.<li>Set in application 
 -  
<TT><a name="_IX_507"></a>LM_A_COMM_TRANSPORT</TT><li>Vendor daemon is pre-v3.0 -  TCP only.</ol>
<h3>11.1.1	 <a name="_IX_508"></a>UDP Behavioral Differences</h3>
<ul><li>Servers that use UDP clients require a small, fixed number of sockets. This can 
be preferable on systems with limited resources and a large number of clients 
(500 or more). In addition, they never need to spawn additional vendor daemons, 
as TCP servers do when they use up the maximum number of file descriptors.<li>When a UDP client exits without doing a checkin, the server does not become 
immediately aware of this, but will time the license out. Therefore, applications 
should always call 
lc_checkin() before exiting. The default for a timeout is 45 
minutes, but can be set in the application via:</ul><pre>		lc_set_attr(LM_A_UDP_TIMEOUT, &lt;# seconds&gt;);</pre>
</ol></ul><p>
Therefore, a UDP client which does not, or is unable to, call 
lc_checkin(), will 
have a license checked out for 45 minutes (by default) after the program exits. This 
behavior will also be affected by 
<TT>LM_A_CHECK_INTERVAL</TT>. In particular, for 
UDP clients, 
<TT>LM_A_CHECK_INTERVAL</TT> must never be longer than 
<TT><a name="_IX_509"></a>LM_A_UDP_TIMEOUT</TT>, or the client will be timed out for no good reason. This 
is not normally fatal, but a client could lose a license to someone else in trying to 
retrieve it after being timed out.<p>
<p>
Applications that call 
<I>lc_timer</I> directly must ensure that they call it often enough 
to prevent being timed out.<p>
<ul><li>When a client has to reconnect to a server (which can happen for numerous 
reasons), the reconnection process requires 10 seconds for the client to timeout 
the read from a server which is down. With TCP, this recognition is instantaneous. 
The result is that a server's failure will cause a client using UDP to hang for a 
minimum of 10 seconds, while with a TCP client, this recognition is transparent.</ul><p>
In 
GLOBEtrotter Software<I></I>'s testing environment, we have found no discernible 
performance advantage in checking out licenses or getting status information via either 
TCP or UDP. 
<p>
<p>
Based on our test results, we find TCP to be a far superior mode of communication, 
and should be used wherever possible.<p>
<h4>See also</h4>
<ul><li><a href="#43831: 2head: 3.3.30 lc_set_attr">Section 4.30, `lc_set_attr,' on page 53</a><li><a href="#21737: 1Head: 4.22 lc_heartbeat">Section 4.22, `lc_heartbeat,' on page 46</a><li><a href="#10309: 2head: 5.1.2 LM_A_CHECK_INTERVAL, LM_A_TIMER_TYPE">Section E.1, `LM_A_ALLOW_SET_TRANSPORT,' on page 197</a><li><a href="#53814: 2head: 5.1.3 LM_A_CHECK_INTERVAL, LM_A_TIMER_TYPE">Section 5.3, `LM_A_CHECK_INTERVAL,' on page 73</a><li><a href="#20049: 1head: 9.4 Special Hostids">Section 6.7, `Special Hostids,' on page 114</a></ul><a name="Chapter 12"></a><hr><h1>Chapter 12 
Unix<I></I> and VMS <a name="17446: chap head: Chapter 11"></a>Platform-Specific Notes</h1>
<a name="_IX_510"></a><a name="12.1"></a><h2>12.1  Data General</h2>
<p>
On DG systems the daemon lockfile MUST be on a local filesystem (not NFS-mounted).<p>
<p>
On DG-Intel, the hostid is an ethernet address. To work, the /dev/net/* files must all be 
readable. For this reason we recommend that, as root, the following command be 
executed:<p>
<pre># chmod 644 /dev/net/*</pre>
</ol></ul><p>
We do not consider this a security problem, since any PC attached anywhere on the net 
has access to all the same network traffic.<p>
<a name="_IX_511"></a><a name="12.2"></a><h2>12.2  Hewlett Packard</h2>
<p>
The 
<TT>/dev/lan0</TT> device must be readable to obtain an ethernet 
<a name="hostid"></a>hostid. The 
<I>uname -i</I> hostid 
is preferable for this reason, and because ethernet is not always present.<p>
<p>
In version 2.4, 
<TT>/dev/lan0</TT> must have read and write permissions for everyone. Ethernet 
and FDDI are known to be supported devices, although earlier versions of HPUX had 
a bug with FDDI as hostid.<p>
<a name="_IX_512"></a><a name="12.3"></a><h2>12.3  IBM</h2>
<p>
On 
<a name="_IX_513"></a>RS/6000, 
<TT>lmgrd</TT> cannot be started in 
<TT>/etc/rc</TT>; this is because on that OS, the TCP/IP 
networking is started after 
<I>/</I><TT>etc/rc</TT> is run. 
<a name="IBM"></a>IBM has recommended that this be performed 
in the 
<TT>/etc/inittab</TT> file. Add a line like this to 
<TT>/etc/inittab</TT> after the lines which start 
networking:<p>
<pre>rclocal:2:wait:/etc/rc.local &gt; /dev/console 2&gt;&amp;1</pre>
</ol></ul><p>
	IBM changed the system call that returns the node id (uname) several times; most 
recently, in 
<a name="_IX_514"></a>AIX 3.1, the low-order decimal digit of the machine serial number was left 
off. The AIX 3003 version has a corrected system call which returns the entire serial 
number. This means that the hostid of your customer's 
<a name="_IX_515"></a>RS/6000 system CAN 
CHANGE when they upgrade OS revisions. We know of no workaround other than to 
re-issue licenses.<p>
<p>
We believe that this condition stabilized in AIX v3.1.<p>
<a name="_IX_516"></a><a name="12.4"></a><h2>12.4  NCR</h2>
<p>
Redundant servers are not supported on NCR systems, due to a bug in the 
accept() 
networking call on these platforms. 
<p>
<p>
The permissions on the 
<I><a name="_IX_517"></a>/dev/lan0 
</I>device must be readable to obtain a hostid.<p>
<a name="_IX_518"></a><a name="_IX_519"></a><a name="12.5"></a><h2>12.5  SGI</h2>
<p>
SGI has a variety of CPUs, operating systems and compiler switches which are 
mutually incompatible. To explain, it's useful to first understand the different CPUs, 
operating systems and switches:<p>
<h4>Operating Systems</h4>
<dl><dt>IRIX 5<dd>Started shipping early '90s; it is similar to SVR4, uses 
shared libraries, and is 32-bit. (o32 object files)<dt>IRIX 6<dd>64-bit OS, supports 64- and 32-bit applications.</dl><h4>MIPS Chips</h4>
<dl><dt>MIPS1<dd>First MIPS chip. The chip itself is no longer supported by 
SGI, but it's possible to generate binaries that run on this 
chip. R1000 systems(?).<dt>[Not much is known about MIPS2, and it's not relevant anyway]<dt>MIPS3<dd>32- and 64-bit binaries. R4000 and R6000 systems.<dt>MIPS4<dd>Improved 64-bit support. R8000 and R10000 systems.</dl><h4>Compiler Switches on IRIX 6</h4>
<dl><dt>-o32<dd>Native to IRIX 5, it is the `old 32-bit object' format.<dt>-n32<dd>Native to IRIX 6, it is the `new' 32-bit format.<dt>-64<dd>Native to IRIX 6; 64-bit.</dl><h4>Other Compiler Switches</h4>
<dl><dt>-xgot<dd>If your application exceeds 64,000 global variables, you 
must compile and link with objects that have this flag. if 
you need this, use the libraries with the `_xgot' suffix.</dl><p>
We provide 3 SGI directories:<p>
<dl><dt>sgi32_u5<dd>32-bit (-o32) IRIX-5, MIPS1. Requires 
FLEXlm<I></I> sgi vendor 
key.<dt>sgi32_u6<dd>32-bit (-n32) IRIX-6, MIPS3 and MIPS4. liblmgr.a is 
MIPS3 and liblmgr_n32mips4.a is MIPS4. Requires 
FLEXlm<I></I> sgi vendor key.<dt>sgi64_u6<dd>64-bit (-64) IRIX-6, MIPS3 and MIPS4. Requires 
FLEXlm<I></I> 
sgi64 vendor key. liblmgr.a is MIPS3 and 

liblmgr_64mips4.a is MIPS4.</dl><h4>FLEXlm<I></I> Vendor Keys for SGI</h4>
<dl><dt>sgi<dd>All SGI 32-bit applications, including sgi32_u*.<a name="_IX_520"></a><dt>sgi64<dd>All SGI 64-bit applications, including sgi64_u*.</dl><h4>SGI `Origin' systems</h4>
<p>
These `modular' systems can have more than one hostid. lmhostid will report all the 
hostids for these systems. 
<I>A license should be generated for only one of these hostids</I>.<p>
<a name="_IX_521"></a><a name="12.6"></a><h2>12.6  SCO</h2>
<p>
Part if the install_flexlm.ftp install scripts may fail on SCO systems. It is not difficult 
to install without the scripts. Edit the machind/lm_code.h file to put in the correct 
VENDOR_KEYs (obtained from 
GLOBEtrotter Software<I></I>) and 
ENCRYPTION_SEEDs (2 numbers you make up that make license files unique) and 
VENDOR_NAME. Then, if it's not an evaluation copy, in the sco_u3 directory, edit 
the makefile from `<TT>DAEMON = demo</TT>', replacing demo with your daemon name. Then 
type 
<TT>make</TT> in the sco_u3 directory.<p>
<p>
UDP communications are not supported because of an apparent flaw in the SCO OS.<p>
<a name="_IX_522"></a><a name="_IX_523"></a><a name="12.7"></a><h2>12.7  SVR4 Systems</h2>
<p>
All SVR4 systems, including Solaris 2.x, require linking with `-lsocket -lnsl'. Solaris 
2.x also requires -lintl. (OSF/1 does NOT require these link flags, although it is 
otherwise similar to SVR4).<p>
<a name="_IX_524"></a><a name="_IX_525"></a><a name="12.8"></a><h2>12.8  VMS</h2>
<p>
Redundant server hosts are not supported on 
VMS.<p>
<p>
FLEXlm<I></I> client routines continue to use SIGALRM and 
setitimer(), as they do on the 
Unix<I></I> version. The 
FLEXlm<I></I> implementation of 
setitimer() uses the 
alarm() call on 
VMS.<p>
<p>
On 
VMS, the SYSNAM and SYSLCK privileges are required to run the daemons.<p>
<p>
Vendor daemons support up to 255 clients each.<p>
<h3>12.8.1	 <a name="42036: 2head: 14.9.1 Communications transport"></a>Communications transport</h3>
<p>
The 
<a name="_IX_526"></a>VMS version of 
FLEXlm<I></I> uses 
<a name="DECnet"></a>DECnet as a transport, rather than TCP/IP. This 
means that 
VMS servers cannot serve 
Unix<I></I> clients, and 
Unix<I></I> servers cannot serve 
VMS clients.<p>
<h3>12.8.2	 Special AST Considerations</h3>
<p>
If you let 
FLEXlm<I></I> do its checking automatically, the check routine is implemented 
with signals (i.e., it runs at AST level). Therefore, if you use any of the following 
handler routines:<p>
<ul><li>	<a name="LM_A_USER_RECONNECT"></a><TT>LM_A_USER_RECONNECT</TT><li>	<a name="LM_A_RECONNECT_DONE"></a><TT>LM_A_RECONNECT_DONE</TT><li>	<a name="LM_A_USER_EXITCALL"></a><TT>LM_A_USER_EXITCALL</TT><li>	<a name="LM_A_PERIODIC_CALL"></a><TT>LM_A_PERIODIC_CALL</TT></ul><p>
you should be careful to code them such that they can work at AST level. Note that you 
can call any of the 
FLEXlm<I></I> client routines (routines that start with `lc_') from AST 
level.<p>
<p>
If you use your own authentication routine (the `crypt' member of the setup struct), 
this routine must be coded to work properly from AST level.<p>
<h3>12.8.3	 DECnet Logical Links</h3>
<p>
Each 
FLEXlm<I></I> client requires a pair of DECnet logical links. A typical default for the 
maximum # of logical links is 32, therefore, you will need to increase this parameter 
on the node that runs your vendor daemon(s). Do this with the following NCP 
command sequence.<p>
<pre>	$ mcr ncp</pre>
<pre>	NCP&gt; set exec links 100</pre>
</ol></ul><p>
To show how many logical links your system is configured for, do the following:<p>
<pre>	$ mcr ncp</pre>
<pre>	NCP&gt; show exec char</pre>
</ol></ul><p>
The result will be displayed as `MAXIMUM LINKS'.<p>
<p>
Setting the number of links to 100 should allow for 30 
FLEXlm<I></I> clients and a sufficient 
number of links for other uses. (If your current number of links is greater than 32, 
increase it accordingly).<p>
<h3>12.8.4	 <a name="42247: 2head: 14.9.4 VMS supported ethernet devices"></a>VMS Ethernet Device Support</h3>
<dl><b>VMS supported ethernet devices</b><dt>_xqa0:<dd>DELQA, DEQNA, DESQA<dt>_xea0:<dd>DEUNA, DELUA<dt>_esa0:<dd>DESVA<dt>_eta0:<dd>DEBNA<dt>_ewa0:<dd>Alpha<dt>_eza0:<dd>uVax 4000<dt>_exa0:<dd>Vax 9000</dl><p>
If your customer's device is not one of the supported devices, they can `add support' 
by doing an assign. The standard table includes the logical device names 
`flexlm_hostid0', `flexlm_hostid1', `flexlm_hostid2', and `flexlm_hostid3'. 
Assuming that your customer has ethernet device qqa0:, the following assign statement 
would add device qqa0:<p>
<pre>	$ assign _qqa0: flexlm_hostid0</pre>
</ol></ul><p>
This assignment would be done in the process that runs the daemon (for floating 
licenses) or the process that runs your application (for nodelocked licenses).<p>
<h3>12.8.5	 <a name="_IX_527"></a>lmswitch</h3>
<p>
The<B> 
</B><TT>lmswitch</TT> utility switches the debug log file for the daemon serving the specified 
feature while the daemon is running. 
<p>
<p>
Usage is:<p>
<pre>lmswitch <I>feature new-file</I></pre>
</ol></ul><p>
<p>
<dl><dt><I>feature</I><dd>any feature this daemon supports.<dt><I>new-file</I><dd>New file path.</dl><p>
Of course, for this syntax to work, 
<TT>lmswitch</TT> needs to be installed as a foreign 
command. 
<p>
<p>
The new logfile will be opened for write, rather than append, so it is possible to 
`switch' to the same filename in order to be able to view the old (previous version) log 
file.<p>
<a name="Chapter 13"></a><hr><h1>Chapter 13 <a name="34811: ChapTitle: Chapter 15 Windows, Win32s, and Windows NT"></a>
<a name="_IX_528"></a>Windows 95/98, and <a name="_IX_529"></a>Windows NT</h1>
<p>
FLEXlm<I></I> supports the Windows platforms using two sets of libraries 32-bit 
libraries(<TT>LMGR.LIB and LMGR327B.DLL</TT>). The 32-bit libraries supports clients and 
servers on Windows NT 3.5, 3.51, 4.0 and Windows 95/98.<p>
<a name="13.1"></a><h2>13.1  Supported Compilers</h2>
<p>
The 
FLEXlm<I></I> client library on 
Windows/NT is implemented as a 
<a name="_IX_530"></a>DLL or a static 
library. The DLL can interface with almost any compiler. However, to build your 
vendor daemon on a 
Windows NT or Windows 95 system, 
FLEXlm<I></I> supports only the 
Microsoft Visual C/C++ compiler 4.2 or greater).<p>
<p>
In order for 
FLEXlm<I></I> API include files to compile properly on 
Windows platforms, two 
compile time flags must be defined: 
<TT>PC</TT>, and 
<TT>_WINDOWS</TT>. On 
Windows NT systems, 
(32-bit) an additional compile time flag, 
<TT>WINNT</TT>, must be defined. This flag will be 
used to include proper macro definitions in 
<TT>lmclient.h</TT> for 
FLEXlm<I></I> on 
Windows and 
Windows NT systems. 
<p>
<a name="_IX_531"></a><a name="_IX_532"></a><a name="13.2"></a><h2>13.2  lc_new_job() and lc_free_job() Must Be Matched</h2>
<p>
When using the FLEXible API, 
lc_new_job() creates a license job, and 
lc_free_job() 
marks the end of the license job. 
FLEXlm<I></I> applications must match 
lc_free_job() with 
lc_new_job() perfectly to avoid unexpected system problems on 
Windows. The reason 
for this requirement is the following: 
FLEXlm<I></I> issues a 
Windows Socket 
<a name="_IX_533"></a>WSAStartup() 
call in 
lc_new_job(), and 
<a name="_IX_534"></a>WSACleanup() is issued by 
lc_free_job(). Failure to match 
lc_new_job() with 
lc_free_job() will cause unmatched 
WSAStartup() and 
WSACleanup(), which violates 
<a name="_IX_535"></a>the WinSock specification and often results in an 
unstable system. This is true to a lesser degree in NT.<p>
<p>
With the Trivial API, CHECKIN must match CHECKOUT; lp_checkin() calls must 
match lp_checkout().<p>
<a name="13.3"></a><h2>13.3  FLEXlm<I></I> Callback Routines</h2>
<p>
The 
FLEXlm<I></I> API supports application callbacks on various events such as lost of 
license and hostid acquisition. Like all 
Windows 
<a name="_IX_536"></a>SDK standard callback routines, 
FLEXlm<I></I> application callback routines need special attention depending upon the 
environment that you are using. The following code segments from the sample 
program demonstrates how this should be done:<p>
<pre>	void LM_CALLBACK_TYPE Quit(char * feature)</pre>
<a name="13.4"></a><h2>13.4  FLEXlm<I></I> exit() Callback</h2>
<p>
The default operation of 
FLEXlm<I></I> when the connection to the server is lost is to try 5 
times and then exit the program.<p>
<a name="13.5"></a><h2>13.5  Default License File</h2>
<p>
The default location for the license file on 
Windows and 
Windows NT is 
<TT>C:\FLEXLM\LICENSE.DAT</TT>.<p>
<a name="_IX_537"></a><a name="13.6"></a><h2>13.6  Time Zone Setting</h2>
<p>
An optional part of 
FLEXlm<I></I>'s client/server handshake procedure is to check the 
difference between their system time settings. The allowed difference in minutes is set 
by the client program using 
<TT>lc_set_attr(LM_A_MAX_TIMEDIFF, 
</TT><I>x</I><TT>)</TT>. On 
Windows, the 
FLEXlm<I></I> client library checks the time zone environment variable, 
<TT><a name="_IX_538"></a>TZ,</TT> to adjust local 
time (set by the DOS<TT> TIME</TT> command) to Universal Coordinated Time (UCT, the same 
as GMT) in order to communicate with the 
FLEXlm<I></I> server which may be anywhere in 
the world. On 
Windows NT systems, the user has to use the control panel to set the time 
and time zone correctly.<p>
<p>
Use the following DOS syntax to set the 
<TT>TZ</TT> environment variable:<p>
<pre>	set TZ=<I>tzn</I>[+|-]<I>hh</I>[:<I>mm</I>[:<I>ss</I>]][<I>dzn</I>]</pre>
<p><hr>
Note:	This is only required if you call 
<TT>lc_set_attr(LM_A_MAX_TIMEDIFF, *)</TT>.<hr><p>
<p>
The 
<I>tzn</I> must be a three-letter time-zone name, such as PST, followed by an optionally 
signed number, hh, giving the difference in hours between UCT and local time. To 
specify the exact local time, the hours can be followed by minutes (:mm), seconds (:ss), 
and a three-letter daylight savings time zone, dzn, such as PDT. Separate hours, 
minutes, and seconds with colons (:). If daylight savings time is never in effect, as is 
the case in certain states and localities, set TZ without a value for dzn. If the TZ value 
is not currently set, the default is PST8PDT, which corresponds to the Pacific time 
zone.<p>
<p>
For example, to set the TZ environment variable to correspond to the current time zone 
in Germany, you can use either one of the following forms:<p>
<pre>	set TZ=GST1GDT</pre>
<pre>	set TZ=GST+1GDT</pre>
</ol></ul><p>
This uses the letters GST to indicate German Standard Time, though you can use any 
combination of three letters. This syntax assumes that Germany is one hour ahead of 
UCT, and that this timezone uses daylight savings time.<p>
<a name="60608: 2head: 14.10.9 Node Lock and Host ID for Standalone PCs"></a><a name="13.7"></a><h2>13.7  Node Lock and Hostid for Standalone PCs                                   </h2>
<p>
FLEXlm<I></I> for 
Windows and 
Windows NT also supports node locking. Several important 
issues should be considered when designing a node- lock licensing scheme for 
Windows and 
Windows NT systems. One or more of the following four options can be 
adopted to implement the node locking scheme that best fits your products.<p>
<ol><li>Hostid implementation is essential to designing a node lock scheme, and the fact 
that PCs in general do not have a unique serial number is a problem. 
FLEXlm<I></I> for 
Windows and 
Windows NT can use the volume serial number on the 
<TT>C:</TT> drive as 
the hostid for the PC. Your end-user may issue a DIR command on 
<TT>C:</TT> to get the 
serial number. The serial number is presented by DOS in hex form, and this 
number can be used in the hostid field of a license file. Please note that when a 
disk serial number is to be used as a hostid, you must use the format 
<TT>DISK_SERIAL_NUM=xxxxxxxx</TT> where x is a hexadecimal number. 
<li>There are two disadvantages to the volume serial number solution. First, disk 
serial number is only supported by DOS version 4.0 and later. Second, hard disk 
serial numbers can be changed by software with a single DOS file system IOCTL 
call.   Therefore, 
FLEXlm<I></I> offers a hardware solution using an external hardware 
key available from 
GLOBEtrotter Software<I></I>. When a license file has a hostid of the 
form 
<TT>FLEXID=X-</TT><I>xxxxxxxx</I>, 
FLEXlm<I></I> assumes that a hardware key solution for 
hostid is desired.<li>Another method of obtaining a hostid is to retrieve the Ethernet address as a 
hostid. When generating license files for this type of node lock scheme, simply use 
the Ethernet address without any prefix. Since there is not a generalized method 
of obtaining this value, special requirements apply.<li>If none of the above solutions is satisfactory, 
FLEXlm<I></I> provides a set of callback 
routines for vendors to implement their private hostid.   An application may use 
<TT>lc_set_attr(LM_A_VENDOR_GETHOSTID</TT>, 
<I>x</I>) to integrate a private hostid 
scheme into 
FLEXlm<I></I>. The included sample program demonstrates how this can 
be done in 
<TT>WINTEVW.CPP</TT>.</ol>
<h4>See also</h4>
<ul><li><a href="#20049: 1head: 9.4 Special Hostids">Section 6.7, `Special Hostids,' on page 114</a></ul><a name="_IX_539"></a><a name="13.8"></a><h2>13.8  System Requirements for obtaining Ethernet Address</h2>
<p>
There does not exist a uniform method of obtaining Ethernet address across platforms, 
so the requirements vary depending on the platform. The most common example of not 
configuring the system correctly is obtaining FFFFFFFF as the hostid.<p>
<h3>13.8.1	 Windows 95</h3>
<p>
Windows 95 requires the loading of either the NETBEUI Transport Protocol, or the 
NW Link (IPX/SPX) Transport Protocol to obtain the ethernet address.<p>
<a name="_IX_540"></a><a name="13.9"></a><h2>13.9  Quick-Win/ 32 Bit Console Applications</h2>
<p>
On previous versions of 
FLEXlm<I></I> it has been necessary to provide your own timers 
when running a 32 bit Console application. This is no longer necessary.<p>
<p>
When running a Quick-Win application, the timers that are a part of Windows are not 
available. You will need to call 
<TT>lc_timer()</TT> on a periodic basis to ensure correct licensing 
operation.<p>
<a name="13.10"></a><h2>13.10  Networking Requirements</h2>
<p>
Networking software is not required to use 
FLEXlm<I></I> for nodelocked features. If you are 
running in a 32-bit mode, and you do not have WSOCK32.DLL in your path, and you 
are performing node-locked licensing, the correct operation will occur. If you are 
operating a laptop in portable mode, or have a dial up network connection that requires 
DNS, and you do not have DNS in your current mode of operation you can set the 
environment variable LM_NO_NETWORK to avoid lengthy DNS timeouts.<p>
<a name="_IX_541"></a><a name="13.11"></a><h2>13.11  Hardware Hostids (Dongles)</h2>
<h3>13.11.1	 General Information</h3>
<p>
The software for the various hardware based hostid's are stored in the FLEXID7 and 
FLEXID8 directories. Consult those locations for more details.<p>
<h3>13.11.2	 FLEXID</h3>
<p>
This indicates a dongle hostid, and have a prefix like `FLEXID=<I>n</I>-<I>xxxxxxxx</I>', where 
<I>n</I> 
indicates which dongle type is being used.<p>
<h4>`FLEXID=7-...'</h4>
<p>
In 16 bit modes, you will need to use 
<TT>SUPERPRO</TT>.<TT>DLL</TT> (4.032 bytes, dated 5-8-1995).<p>
<p>
For operating under NT, you will need to install a set of NT drivers, 
<TT>SENTTEMP</TT>.<TT>HLP</TT>, 
and 
<TT>SENTTEMP</TT>.<TT>SYS.</TT><p>
<h4>`FLEXID=8-...'</h4>
<p>
For use in 32 bit mode on Windows 95, 
<TT>VSAUTHD</TT>.<TT>386</TT> is required to be installed.<p>
<p>
For use on NT in 32-bit mode, the 
<TT>DS1410D</TT>.<TT>SYS</TT> driver must be installed.<p>
<a name="13.12"></a><h2>13.12  Environment Variables (32-bit Platforms)</h2>
<p>
When running Windows applications, it is sometimes difficult to set environment 
variables. On NT, since each user can have his own environment, it is sometimes 
confusing as to which variables are set. You can now either set environment variables 
in the traditional way, i.e. set command in autoexec.bat (windows), Control 
Panel/System/Environment (NT), or by using the registry. The priority is set to favor 
normal environment variables over registry entries. To set an environment variable 
using the registry, make an entry in HKEY_LOCAL_MACHINE-&gt;SOFTWARE-&gt;FLEXlm License Manager as a String Value. Any 
FLEXlm<I></I> application will then see 
this in its environment. This will be especially useful for setting the license file (if not 
using the default) using LM_LICENSE_FILE, or other parameters when the server is 
running as a Service (on NT).<p>
<p>
In 
FLEXlm<I></I> v6 a new function was added to simplify this procedure. The function is 
lc_set_registry(job, char * EnvironVarName, char* EnvironValue);<p>
<p>
This allows you to write into the registry (assuming your program has the appropriate 
security attributes). If you do not, the error returned is -68, LM_NOADMINGROUP.<p>
<a name="13.13"></a><h2>13.13  Special Syntax for Windows Version</h2>
<p>
When combining license files, use ';' instead of ':' for a list of license files in 
LM_LICENSE_FILE, e.g., file1;file2.<p>
<a name="13.14"></a><h2>13.14  Minimum Files Required for Customer Installation</h2>
<h3>13.14.1	 Client</h3>
<ul><li><TT>lmgr327b.dll (Not necessary if using Statically linked library)</TT></ul><h3>13.14.2	 Server</h3>
<ul><li><TT>lmgr327b.dll (Not necessary if using Statically linked library)</TT><li><TT>LMGRD.EXE</TT><li><TT>XXXX.EXE (Your Vendor Daemon)</TT></ul><a name="13.15"></a><h2>13.15  Build Notes</h2>
<p>
The lmgr327b.dll library is built using the multi-threaded statically linked C Run-time 
library.<p>
<a name="13.16"></a><h2>13.16  Linking to your Program</h2>
<p>
FLEXlm<I></I> can be linked into your application in two ways. The two methods are using 
a static library, or using a DLL. To enhance security, it is recommended to use the static 
library if possible. The static library is compiled with Microsoft VC++ 4.2, 32 bit, with 
Multi-threading enabled, static C Runtime Library (/MT). The static library is named 
LMGR.LIB. 
GLOBEtrotter Software<I></I> also provides a library compiled with /MD, 
multi-threaded, using the C Runtime Library as a DLL, called LMGR_MD.LIB<p>
<p>
Note there is no version information available in the static library at this time. You will 
need to use the date as your reference.<p>
<p>
If it is necessary to use the DLL version of 
FLEXlm<I></I>, please send email to 
support@globes.com, to get suggested enhancements to improve the security of your 
application. The DLL version is called LMGR327B.DLL with its associated import 
library LMGR327B.LIB.<p>
<a name="13.17"></a><h2>13.17  If your application is a DLL</h2>
<p>
If your application is a DLL and the 
FLEXlm<I></I> library is linked into this DLL, then you 
need to set one special attribute to allow the Windows context to be properly set:<p>
<pre>	lc_set_attr(job, LM_A_WINDOWS_MODULE_HANDLE, 
		(LM_A_VAL_TYPE)GetModuleHandle(<I>dllname</I>)); </pre>
</ol></ul><p>
where 
<I>dllname</I> is the name of your DLL.<p>
<a name="13.18"></a><h2>13.18  Special Operating Conditions</h2>
<p>
Normally, after the calling program finishes its use of the 
FLEXlm<I></I> library or DLL, the 
calling program exits. At this point, all handles, malloced memory, and threads are 
released or terminated. However some applications do not operate in this manner. To 
provide a method of cleaning up, 
FLEXlm<I></I> has added a new function, lc_cleanup. It can 
only be called after you have called lc_free_job for all jobs that you have used. This 
function will free all malloced memory, release all handles, and kill all threads that it 
has created. For normal programs, this call is optional. Only special drivers which 
reside dormant in memory require this call. Do not call any 
FLEXlm<I></I> functions after 
this call.<p>
<pre>	lc_cleanup();</pre>
<a name="13.19"></a><h2>13.19  Timers</h2>
<p>
Starting with 
FLEXlm<I></I> v6.0, the default timers included in 
FLEXlm<I></I> can be used for all 
applications, whether they are 32 bit console or WIN32 windows applications. You 
may still use your own timers by disabling the internal ones by calling:<p>
<pre>	lc_set_attr(lm_job, LM_A_CHECK_INTERVAL, (LM_A_VAL_TYPE)-1)</pre>
<a name="13.20"></a><h2>13.20  Ethernet Address for WIN32 Platform</h2>
<p>
Over time changes have been made to improve the detection of ethernet addresses. It 
is necessary to load a Protocol stack other than TCP/IP to obtain the ethernet address 
because there is no mechanism in TCP/IP (WINSOCK) to obtain the ethernet address, 
nor is there any OS calls to obtain it. 
GLOBEtrotter Software<I></I> has spent considerable 
time with Microsoft to resolve this issue, but as of yet has not obtained the information 
necessary to perform this task without any additional protocol stacks.<p>
<p>
First, if multiple ethernet cards are present, it will report all that it can detect. False 
Ethernet addresses (such as those generated from PPP stacks) have been filtered out. 
Do not issue a license for a ethernet address when the first four characters are `DEST' 
(44-45-53-54-00-00) and the rest are 0. Also certain cards will return a 0 or FFFFFFFF 
for a ethernet address, these are not valid addresses. Using the Nwlink (IPX/SPX) 
protocol to obtain the ethernet address will only result in one ethernet address being 
returned, instead of multiple ones if they are installed. This is due to problems inherent 
in the method of indirectly obtaining the ethernet address.<p>
<p>
The process for detecting the ethernet address goes through the following series of 
steps. When it detects a valid address using the first method that succeeds, it stops any 
further processing and returns with that value.<p>
<p>
First it checks if the LM_USE_SNMP environment variable/registry entry has been 
set. If so, it will attempt to obtain the ethernet address using SNMP protocol. This will 
only work if the SNMP service is installed on NT, and the service is running, and the 
customer has included the public trap in the Network SNMP control panel entries. 
SNMP on Windows 95 has not been tested.<p>
<p>
If the LM_USE_SNMP has not been set, it checks for the ethernet address using the 
Netbios (NETBEUI) stack, unless the LM_NO_SNMP variable/registry value has 
been set.<p>
<p>
Finally, if an ethernet address has not been detected up to this point, the code then 
checks for the ethernet address using the IPX/SPX (NWLINK) protocol stack. If this 
still doesn't succeed, it will return a -1 which will print out as FFFFFFFF.<p>
<p>
So to use the ethernet address as a hostid, you need to either load the SNMP service, 
the NETBIOS protocol, or the NWlink (IPX/SPX) protocol.<p>
<p>
If you are having a problem with a specific protocol, and you have more than one 
loaded, you can set an environment variable to disable a particular attempt to get the 
ethernet address using a specific protocol.<p>
<p>
Setting LM_USE_SNMP will enable using SNMP (If not set, 
FLEXlm<I></I> will not use 
SNMP), setting LM_NO_NETBIOS will disable using Netbios for obtaining the 
ethernet address.<p>
<a name="13.21"></a><h2>13.21  Operation on NEC NT machines</h2>
<p>
On certain models of NEC NT machines, the normal order of disk drives is reversed. 
In general on the NEC NT the boot hard-drive has the letter A as opposed to the normal 
C drive. When this is detected in 
FLEXlm<I></I>, it automatically changes the default location 
of standard files such as the license file, vendor daemon lock file, etc. to drive A.<p>
<p>
In previous versions, (4.0 and 5.0) the DISK VOLUME SERIAL NUMBER was 
always the one for disk C:. In later versions of 
FLEXlm<I></I>, (v5.12 and v6.0)the following 
algorithm is used to get the DISK VOLUME SERIAL NUMBER: starting at drive A 
and going until drive C, the first fixed drive found that is not a CD drive is the drive for 
which the DISK VOLUME SERIAL NUMBER will be returned.<p>
<a name="13.22"></a><h2>13.22  Networking</h2>
<p>
If 
FLEXlm<I></I> is being used in a node-locked mode and node locking hostids which are 
not using networking functions are being used, then there are no networking software 
or hardware requirements. Instances of HOSTID's that do not require networking are 
the disk volume serial number, demo licenses, serial number licenses, or vendor 
defined hostid (if you are not using networking functions as a part of it).<p>
<p>
If you are using floating (counted) licenses you will need to install TCP/IP and one of 
either NETBEUI, NWlink IPX/SPX, or SNMP.<p>
<a name="13.23"></a><h2>13.23  FLEXlm<I></I> TCP/IP Network Problem</h2>
<p>
The Microsoft TCP connect() behavior has an important bug for which there is no fix. 
The Microsoft TCP implementation does not allow the programmer any effective 
control over the duration of a connect call, timeouts, retry attempts, etc.<p>
<p>
The Microsoft TCP connect behavior causes needless delays under the following 
condition: when clients attempt to talk to a license server, and the server node is 
running, but lmgrd is not, there is a 1.5 second delay on Windows and Windows/NT, 
and this delay does not occur on other operating systems.<p>
<p>
In 
FLEXlm<I></I>, this is most notable when using LM_LICENSE_FILE set to @<I>host</I>, and 
<I>host</I> is up, but lmgrd is not running. This causes a delay up to 15 seconds, 1.5 seconds 
for the attempted connect to each of the 10 default ports, 27000-27009.<p>
<a name="13.24"></a><h2>13.24  FLEXlm<I></I> Utilities</h2>
<p>
In most of the other sections of the documentation, various 
FLEXlm<I></I> utilities are 
referred to like lmstat, lmdiag, and lminstall. On the PC platforms, you need to either 
copy the lmutil.exe file to the name of the utility required, or just precede the lmstat, 
etc. with lmutil. For example:<p>
<pre>lmutil lmstat -c mylicense.dat</pre>
</ol></ul><p>
On the WIN32 platforms, there is an additional program, LMTOOLS.EXE, which is a 
GUI front-end to lmutil with most of the same functionality.<p>
<a name="13.25"></a><h2>13.25  Servers and Services</h2>
<p>
In order to use counted licenses, a license server must be running. This consists of a 
lmgrd running with the proper vendor daemon. These programs are WIN32 console 
applications, and can be run in a DOS window. They are started by lmgrd -app -c 
<I>license_file.</I><p>
<p>
The problem with running a server this way is that it occupies a window on the screen, 
and may be difficult to start and stop. On the NT, and on Windows 95, it is possible to 
take advantage of a feature called Services. This is a interface that allows programs to 
be started and stopped through a common user interface, and run in the background. 
To get 
FLEXlm<I></I> to run as a service, you need to `install' it. Two methods are available, 
the 
FLEXlm<I></I> Control Panel, or a sample program, installs.c (located in the MACHIND 
directory).<p>
<a name="13.26"></a><h2>13.26  Control Panel and Multiple Lmgrd's</h2>
<p>
Problems have been experienced using previous versions of 
FLEXlm<I></I> and running 
multiple servers as services. On the NT operating system the preference is to run lmgrd 
as a service. Since there is a deficiency in allowing parameters to be passed to a service, 
it was necessary to set a global variable LM_LICENSE_FILE to pass the path to the 
license file. Since this was a single global, it was not possible to have multiple lmgrds 
run concurrently.<p>
<p>
As of version 5.12 and continuing through 6.1, several changes have been made to 
enhance the operation of multiple services. These architectural changes will allow 
several version 5.12, and 6.1 
FLEXlm<I></I> lmgrds to run concurrently each inheriting a 
separate set of License files and other parameters.<p>
<p>
First this information is stored in the registry in the following manner:<p>
<pre>	HKEY_LOCAL_MACHINE-&gt;SOFTWARE-&gt;FLEXlm License Manager-&gt;<I>sname</I></pre>
<pre>	LMGRD <I>path-to-lmgrd.exe
</I>	License <I>path-to-license
</I>	LMGRD_LOG_FILE <I>path-to-log-file</I></pre>
</ol></ul><p>
where 
<I>sname</I> is the name of the service that shows up when you access the Services 
Control panel.<p>
<p>
When the 
FLEXlm<I></I> service starts up, it obtains its name, and then looks up the 
parameters in the registry. Lmgrd then uses this information to read the appropriate 
license file, launch the appropriate vendor daemon, and pass this information to the 
vendor daemon. When properly configured, all of this is invisible to the user.<p>
<p>
The new version of install.c in version 6.1 (installs.c) will automatically write out these 
parameters in the registry, and also the new version of the 
FLEXlm<I></I> Control Panel will 
similarly read and write these values.<p>
<a name="13.27"></a><h2>13.27  WINDOWS 95 Multiple Servers</h2>
<p>
Windows 95 does not have the concept of Services as NT does. With version 5.12 and 
6.1, 
GLOBEtrotter Software<I></I> has simulated partially the operation of services to allow 
FLEXlm<I></I> to run multiple services, and not have them consume a console window on 
the display.<p>
<p>
To do this we are saving the information in the registry as for NT, but when the 
computer powers up, we use the Microsoft\\Windows\\CurrentVersion\\RunServices 
function that is documented in the MSDN information. The 
FLEXlm<I></I> Control panel 
when properly configured creates an entry in this registry location including a 
command line to be executed. This specifies the lmgrd95.exe program (which is 
assumed to be in the same directory as the lmgrd.exe that is going to be run) which 
inherits the values from the registry entries, which then specify the license file, log file, 
etc. This then starts the lmgrd in the background and starts the 
FLEXlm<I></I> server.<p>
<p>
As noted in the Microsoft documentation, after the server is started, if the user changes 
Users, or shuts down the system, the license manager will be stopped. This is why 
GLOBEtrotter Software<I></I> does not recommend using WIN95 for running license 
servers.<p>
<p>
The installs.c program in the MACHIND directory has been updated to automatically 
support this feature when run on a Windows 95 machine. It automatically detects the 
operating system and then installs the Pseudo service.<p>
<a name="13.28"></a><h2>13.28  Default Operation when Server connection is lost</h2>
<p>
The default operation of this version is now the same as UNIX. If you do not 
implement any reconnect callbacks, after trying to reconnect to the server for 5 times 
at 2 minute intervals, the program will exit. If this is not the desired operation of your 
product, either change the default parameters, register your own callbacks, or use the 
TRIVIAL or SIMPLE API and don't use LM_RETRY_RESTRICTIVE.<p>
<a name="13.29"></a><h2>13.29  Version Information</h2>
<p>
Starting in 5.12 and continuing in this version, in the lmgr327b.dll, 
GLOBEtrotter Software<I></I> has created a version resource. This will allow you to easily identify any 
current and future versions of the DLL. It is then possible to obtain the version by right 
clicking the mouse on the file and looking at the version tab. If your application uses 
the static library, lmgr.lib, run the lmutil lmver program to see which version of 
FLEXlm<I></I> is bound to your executable.<p>
<a name="13.30"></a><h2>13.30  Using languages other than `C'</h2>
<p>
There is a new API that is designed for non-C languages such as Visual Basic. It is 
designed to eliminate the usage of pointers. It is documented in the 
EXAMPLES/VB/VB4.0/VB.DOC file<p>
<a name="13.31"></a><h2>13.31  Server Environment Variables</h2>
<p>
Many aspects of 
FLEXlm<I></I> can be controlled using environment variables. These are 
mentioned in the Reference Manual. There are limitations to them depending on the 
platform. You can set these environment variables before entering Windows 95/98 in 
the autoexec.bat files. The NOVELL server does not have any environment variables.<p>
<p>
We have allowed an alternate way of setting environment variables, registry entries. 
When 
FLEXlm<I></I> looks for a environment variable, it first looks to the program's 
environment variables. If it does not find it, it then looks into the registry in:<p>
<p>
HKEY_LOCAL_MACHINE-&gt;SOFTWARE-&gt;FLEXlm License Manager -&gt; 
&lt;environment_variable&gt;<p>
<p>
where &lt;environment_variable&gt; is the environment variable.<p>
<p>
If it finds it, it uses that value as the value of the environment variable.<p>
<p>
In this version of 
FLEXlm<I></I> a new function was added to simplify this procedure. The 
function is lc_set_registry(job, char * env_var_name, char* environ_value);<p>
<p>
This allows you to write into the registry (assuming your program has the appropriate 
security attributes). If you do not, the error returned is -68, LM_NOADMINGROUP<p>
<p>
The Server software (lmgrd.exe and your vendor daemon) can also use registry values 
when they are started as a SERVICE on a NT system. The values they use are in a sub-key in the above 
FLEXlm<I></I> License Manager key. The following code snippet taken 
from installs.c shows how to create registry entries for the server programs.<p>
<pre>         // next write registry entries
       // Update the registry
        // Try creating/opening the registry key
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "SOFTWARE",
                     0,
                     KEY_WRITE,
                     &amp;hcpl) == ERROR_SUCCESS)
            {
            HKEY happ;
            DWORD dwDisp;
char new_name[120];
                sprintf(new_name,"FLEXlm License Manager\\%s", Service_Name);
            if (RegCreateKeyEx(hcpl,
                           new_name,
                           0,
                           "",
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &amp;happ,
                           &amp;dwDisp) == ERROR_SUCCESS)
                {
                    RegSetValueEx(happ,
                          "Lmgrd",
                          0,
                          REG_SZ,
                          Lmgrd_Path,
                          strlen(Lmgrd_Path));

                    RegSetValueEx(happ,
                          "LMGRD_LOG_FILE",
                          0,
                          REG_SZ,
				Log_File_Path,
                          strlen(Log_File_Path));
                    RegSetValueEx(happ,
                          "License",
                          0,
                          REG_SZ,
                          License_Path,
                          strlen(License_Path));
                    RegSetValueEx(happ,
                          "Service",
                          0,
                          REG_SZ,
                          Service_Name,
                          strlen(Service_Name));


                // Finished with keys
                    RegCloseKey(happ);

        }
        RegCloseKey(hcpl);</pre>
<a name="Chapter 14"></a><hr><h1>Chapter 14 
<a name="_IX_542"></a>Netware NLM</h1>
<a name="14.1"></a><h2>14.1  Introduction and Requirements</h2>
<p>
FLEXlm<I></I> for Netware provides license server support on a Netware server which 
manages licensing via the IPX/SPX and TCP/IP protocol. This is accomplished by 
building a vendor-customized 
FLEXlm<I></I> vendor daemon NLM. The client software 
development is the same as the normal 
FLEXlm<I></I>, regardless of the transport protocol to 
be used.<p>
<p>
FLEXlm<I></I> for Netware NLM requires a WATCOM compiler version 10.0 or later and 
the Novell NLM SDK. Netware server version 3.x or 4.x is also required for running 
the vendor daemon NLM (Netware Loadable Module).<p>
<a name="_IX_543"></a><a name="14.2"></a><h2>14.2  Installation</h2>
<p>
To install, you should use the same procedure as installing all other 
FLEXlm<I></I> software 
and make sure to select the Novell Netware platform. Install your vendor daemon 
name, encryption seeds, and GLOBE<I>trotter</I>-provided vendor keys to include 
<TT>lm_code</TT>.<TT>h</TT> during the installation procedure. Build the vendor daemon by executing the 
batch file 
<TT>flexlm_dir\i86_z3\build.bat.</TT> When the batch file is completed, your 
FLEXlm<I></I> 
vendor daemon DEMO.NLM is ready for use. You may customize your vendor 
daemon as described elsewhere. The customization procedure and mechanism is 
exactly the same as for 
FLEXlm<I></I> on all other platforms. Copy the vendor daemon NLM 
to the Netware server SYS:\SYSTEM directory. Installation is now complete. Please 
refer to the next two sections on generating license files and starting the vendor daemon 
NLM. 
<p>
<a name="25649: 1Head: 15.3 Creating a License File For FLEXlm Vendor Daemon NLM"></a><a name="14.3"></a><h2>14.3  Creating a License File For Netware </h2>
<p>
The create license programs 
<TT>MAKEKEY</TT> and 
<TT>LMCRYPT</TT>, which are included in 
FLEXlm<I></I> for Win32, should be used to create the license file. To determine the 
hostname of the computer, type 
<TT>CONFIG</TT> on the console of the Netware server. Look 
for 
<TT>File</TT> 
<TT>Server Name:</TT> from the output. 
<TT>MAKEKEY</TT> queries for host id of the license 
server. For Netware servers, 
FLEXlm<I></I> uses the Ethernet address of the first network 
interface card as its host id. To find the Ethernet address, type 
<TT>CONFIG</TT> on the console 
of your Netware server and look for 
<TT>Node Address:</TT> from the output. 
<TT>MAKEKEY</TT> also 
queries for the transport address. When using TCP as the transport protocol, simply 
enter the desired port number such as 7182 or TCP:7182. When using IPX/SPX as the 
transport protocol, you must respond to the query with an SPX transport address, 
which consists of a socket number, a server node address, and an IPX network number. 
Enter the SPX transport address in the following format:<p>
<pre>	SPX:socket_number@node_address#network_number </pre>
</ol></ul><p>
For example, 
<p>
<pre>	1234@000000000001#2f14abf7. </pre>
</ol></ul><p>
The SPX socket number must be an unused decimal socket number on the server. If 
you use the 
FLEXlm<I></I> vendor daemon NLM on a Netware server, you may use the 
following commands to find out the node address and network number of the Netware 
server: From a Netware client, execute the file 
<TT>SYS:\system\netadmin.exe</TT>. Make the 
following menu selection in sequence: 
<TT>Manage Object -&gt; View</TT> or 
<TT>Edit Property</TT> of 
<TT>Object -&gt; View Server Information</TT>. Look for 
<TT>Node Address: 
</TT>and 
<TT>Network Address:</TT> on 
screen. Please note that in many cases, the node address of your Netware server is 
000000000001.<p>
<p>
If you would like 
FLEXlm<I></I> license server to support both IPX/SPX and TCP/IP clients 
concurrently, you must specify both transport addresses in the SERVER line of the 
license file. For example:<p>
<pre>   SERVER my_hostname my_hostid SPX:1234@000000000001#2f14abf7 TCP:7182</pre>
<a name="_IX_544"></a><a name="14.4"></a><h2>14.4  Starting the Vendor Daemon on a Netware Server </h2>
<p>
The 
FLEXlm<I></I> license server on Netware is started with the following command at the 
Netware server console:<p>
<pre><TT>LOAD vendor_daemon_nlm [-l log_file_name] [-c license_file] [-x lmremove] </TT></pre>
<dl><dt><I>vendor_daemon_nlm</I><dd>the file name of the vendor daemon NLM<dt><I>log_file_name</I><dd>the full path to the vendor daemon log file. The default log 
file is the system console. 
<dt><I>license_file</I><dd>the specified license file. Default is 
<TT>SYS:\flexlm\license.d</TT><I>at</I> 
<dt>-<I>x</I> lmremove 
<dd>used to disable 
<TT>lmremove</TT> utility.</dl><p>
You may optionally enter your 
FLEXlm<I></I> vendor daemon startup command in the 
Netware server 
<TT>AUTOEXEC</TT>.<TT>CNF</TT> file to auto-load the 
FLEXlm<I></I> vendor daemon NLM 
during Netware server boot time.<p>
<a name="14.5"></a><h2>14.5  Preparing the Client System to Use IPX/SPX for FLEXlm<I></I></h2>
<p>
In order to enable the 
FLEXlm<I></I> client programs on Windows NT systems to use 
IPX/SPX, the following items should be checked: 
<p>
<p>
The license file should specify the SPX transport address in the SERVER line as 
described in 
<a href="#25649: 1Head: 15.3 Creating a License File For FLEXlm Vendor Daemon NLM">Section 14.3, `Creating a License File For Netware,' on page 167</a>. 
You may manually change this field in the SERVER line of your license file. The 
Nwlink IPX/SPX Compatible Transport Driver must be properly installed and 
configured. You may use the Network icon from the Control Panel to verify this. 
FLEXlm<I></I> supports Windows NT version 3.5 and later. You may use the 
<TT>FLEXLM_COMM_TRANSPORT</TT> environment variable to switch the 
FLEXlm<I></I> 
transport protocol selection among TCP, UDP, and SPX. (You may use 
<TT>lc_set_attr(lm_job, LM_A_COMM_TRANSPORT, LM_SPX)</TT> to hard code your 
application to use IPX/SPX as the 
FLEXlm<I></I> transport protocol. This usage is 
generally not encouraged since it limits end-user flexibility.)<p>
<p>
In order to enable 
FLEXlm<I></I> client programs on Windows systems to use IPX/SPX, 
the following items must be checked: The license file should specify the SPX 
transport address in the SERVER line as described in 
<a href="#25649: 1Head: 15.3 Creating a License File For FLEXlm Vendor Daemon NLM">Section 14.3, `Creating a 
License File For Netware,' on page 167</a>.<p>
<p>
Netware client version 3.x or 4.x should be installed. 
<p>
<p>
The following files must exist in the 
<TT>WINDOWS</TT> or 
<TT>WINDOWS</TT>\<TT>SYSTEM</TT> directory, 
or other directory in the Windows DLL search path: 
<TT>NWCALLS</TT>.<TT>DLL</TT> 
<TT>NWIPXSPX</TT>.<TT>DLL</TT> 
<TT>TLI_SPX.DLl TLI_WIN.DLL</TT>	 These files are part of the Netware 
client software. 
<p>
<a name="_IX_545"></a><a name="14.6"></a><h2>14.6  Accessing License Servers via TCP/IP and SPX/IPX Concurrently </h2>
<p>
There may be situations at the end user sites where a Windows or NT system needs to 
access multiple license servers through TCP/IP and SPX/IPX concurrently. For 
example, you may be using an accounting package and a word processor whose license 
servers reside on a Unix and a Netware server respectively. In order to check out 
licenses for both products, you should follow the check list below in setting up the 
Windows or NT configuration: As a prerequisite, the Windows or NT system must first 
have TCP/IP and SPX/IPX protocol stacks configured to co-exist. Set the 
<TT>LM_LICENSE_FILE</TT> environment variable to the list of license files for your servers. 
For example: set 
<TT>LM_LICENSE_FILE=license1.dat; license2.dat; license3.dat</TT>. On 
Windows systems, this command must be done before Windows is started. On 
Windows NT systems, you may use the control panel to set environment variables. 
Please note that these license file are separated by `;', and the 
<TT>SERVER</TT> line in each 
license file specifies a license server and the communication protocol in order to access 
the server. 
<p>
<h3>14.6.1	 Notes</h3>
<p>
	Callbacks in the Netware NLM are defined as standard `C' functions. This is different 
than on the NT platform where the PASCAL calling conventions are used. Since the 
NLM is one module, no calls need to be made outside of the library, standard calling 
conventions can be used.<p>
<a name="Appendix A "></a><hr><h1>Appendix A  
<a name="41257: chap head: Distribution Kit Contents"></a><a name="_IX_546"></a>Industry-Standard Licensing APIs</h1>
<p>
FLEXlm<I></I> offers the most widely-used licensing API available - the 
<a name="_IX_547"></a>FLEXlm<I></I> API, 
which is used by over 1500 software vendors worldwide. However, there has been 
much effort expended in the search for a `standard' licensing API. 
<p>
<p>
FLEXlm<I></I> offers the ISV the choice of five standard APIs:<p>
<ul><li>The 
FLEXlm<I></I> Trivial API<li>The 
FLEXlm<I></I> Simple API<li>The 
FLEXlm<I></I> FLEXible API<li><a name="_IX_548"></a>Software License Working Group API<li><a name="_IX_549"></a>LSAPI (a proposed standard)</ul><p>
FLEXlm<I></I> is the only licensing system available which supports all five APIs.<p>
<a name="30581: 1head: 4.1 The FLEXlm API"></a><a name="_IX_550"></a><a name="A.1"></a><h2>A.1  The FLEXlm<I></I> FLEXible API</h2>
<p>
The 
FLEXlm<I></I> FLEXible API has evolved since 1988, with the input of most of the 
major software vendors in the 
Unix<I></I> software industry. The goal of the 
FLEXlm<I></I> API is 
to give you your choice of licensing models in an easy to implement, robust package. 
The 
FLEXlm<I></I> API is documented in 
<a href="#24121: ChapTitle: Chapter 4 FLEXible API">Chapter 4, `FLEXible API</a>.'<p>
<a name="_IX_551"></a><a name="A.2"></a><h2>A.2  The FLEXlm<I></I> Trivial and Simple APIs</h2>
<p>
These APIs are suitable for most applications, and are robust and easy to implement. 
See the 
FLEXlm Programmers Guide<I></I> for complete information on these.<p>
<a name="15633: 1head: 4.2 Software License Working Group"></a><a name="A.3"></a><h2>A.3  Software License Working Group</h2>
<p>
The Software License Working Group was a sub-group of the Network Computing 
Forum, organized by Apollo Computer in 1988. This group published a licensing 
system API which GLOBEtrotter believes to be the most usable of all the `standard' 
licensing APIs in existence to date. 
FLEXlm<I></I> has supported this interface since 1990. 
Even though this interface is vendor-neutral and well-designed, few software 
companies utilize this interface, and no other `standards' organizations adopted it.<p>
You cannot mix Software License Working Group calls with either the native 
FLEXlm<I></I> calls or the LSAPI calls.FLEXlm<I></I> on 
Windows and 
Windows NT systems do not support this API.<h4>Data types for all calls</h4>
<dl><dt><I>vendor_id (char *)</I><dd>Same as vendor daemon name<dt><I>vendor_key (VENDORCODE *)</I> 
<dd>Vendor's encryption seeds<dt><I>job_id (LM_HANDLE *)</I><dd>Job handle<dt><I>length (int)</I><dd>Length of a string<dt><I>text (char *)</I><dd>String<dt><I>status (int)</I><dd>Status return from call<dt><I>product_id (char *)</I><dd>Feature name<dt><I>version (char *)</I> 
<dd>Version of feature<dt><I>amount (int)</I><dd>Number of licenses<dt><I>queue (int)</I><dd>Enqueue request flag<dt><I>check_period (int)</I><dd>check_interval<dt><I>license_handle (char *)</I><dd>Handle for this license<dt><I>queue_position (int)</I><dd>Our position in the queue</dl><h4>General Calls</h4>
<dl><dt><I>ls_init (vendor_id, vendor_key, 
&amp;job_id):</I></dl><dl><dt><dd>Same as 
lc_init() 
<dt><I>ls_terminate (job_id):</I><dd>Terminate licensing operations<dt><I>ls_log_message (job_id, 
length, text, &amp;status)</I>:<dt><dd>Similar to 
lc_log()</dl><h4>License Brokering Calls</h4>
<p>
lb_request (job_id, product_id, version, amount, queue, check_period, 
&amp;license_handle)<p>
<dl><dt><dd>Check out a license</dl><p>
lb_check_wait (license_handle, check_period, &amp;queue_position)<p>
<dl><dt><dd>Check queue position for a license<dt>lb_wait_remove (license_handle)<dt><dd>Remove process from queue for this license</dl><p>
lb_confirm (license_handle, check_period)<p>
<dl><dt><dd>Inform daemon that license is still in use</dl><p>
lb_release (license_handle)<p>
<dl><dt><dd>Release a license (lc_checkin())</dl><p>
lb_get_cur_users (job_id, product_id, version, next, maximum_entries, queued, 
total_licenses, number_of_entries, entries)<p>
<dl><dt><dd>Get a list of users of `product_id' (like lc_userlist, 
only much harder to use).</dl><a name="_IX_552"></a><a name="19744: 1head: 4.3 LSAPI v1.1"></a><a name="A.4"></a><h2>A.4  LSAPI v1.1</h2>
<p>
The LSAPI interface, a licensing API first proposed in May, 1992, was designed by a 
consortium of software vendors with participation from several licensing system 
vendors. The main `claim to fame' of this interface is that it attempts to provide a 
solution whereby the end-user can choose the license server product from the licensing 
system vendor of their own choice. While the LSAPI seems to be a simple API, it hides 
the fact that your code will increase in complexity in order to solve the problem of the 
replaceable license server, (since both the license server and the licensing system 
library are, in theory, replaceable by the end-user, any security 
<I>must 
</I>be built into your 
code, 
<I>independent 
</I>of the license server). The complexity is exposed to you in the 
`challenge mechanism', which is a standard authentication technique known as 
`handshaking'.<p>
<p><hr>
Caution:	If you are considering using LSAPI in your product, you should read U.S. patent 
#5,375,206 issued to HP, and understand its implications.<hr><p>
<p>
LSAPI has several significant drawbacks compared to the 
FLEXlm<I></I> API. In addition, 
GLOBEtrotter believes that the stated goal of license server independence cannot be 
met by the current version of the LSAPI spec (see last point below). Some of the 
drawbacks of LSAPI compared to the native 
FLEXlm<I></I> API are:<p>
<ul><li>Unreasonable error reporting (only a total of 14 error codes.)<li>No ability for the vendor to support license queueing.<li>No vendor-specific checkout filtering.<li>New 
<a name="_IX_553"></a>hostid types are not definable by the software vendor.<li>No provision to pass messages between the client and license server.<li>No way to get license status without doing I/O to the license server.<li>No way to support a node-locked license without a license server.<li>No way to retrieve information about the licensing policy.<li>No way to ship a vendor-neutral license. This means that, in order to accomplish 
the stated goal of allowing your end-user to select the licensing system from the 
vendor of their choice, 
<I>YOU</I> would have to provide licenses in the format required 
by 
<I>EACH AND EVERY</I> license system which your customer might want to 
choose. In practice, what this means is that you would need to build and test with 
every possible licensing system.</ul><p><hr>
Note:	You cannot mix LSAPI calls with either the native 
FLEXlm<I></I> calls or the Software 
License Working Group calls.<hr><p>
<h4>Data types for all calls</h4>
<dl><dt><I>LS_ULONG<dd></I>unsigned long<dt><I>LS_STATUS_CODE</I><dd>unsigned long<dt>LS_STR<dd>char<dt><I>LS_CHALLENGE</I><dd>structure<dt><I>LS_CHALLENGE_FLEXLM</I><dd>structure<dt><I>LS_HANDLE</I><dd>unsigned long<dd><dt><I>LS_VOID</I><dd>void</dl><a name="A.5"></a><h2>A.5  LSAPI General Calls</h2>
<h4>List providers of licensing service</h4>
<p>
<I>LS_STATUS_CODE LSEnumProviders (LS_ULONG Index, LS_STR *Buffer)</I><p>
<h4>Get message text from licensing system</h4>
<dl><dt><I>LS_STATUS_CODE LSGetMessage(LS_HANDLE Handle</I><dt><I><dd>LS_STATUS_CODE Value,</I><dt><I><dd>LS_STR *Buffer, LS_ULONG BufferSize)</I></dl><h4>Query License information</h4>
<dl><dt><I>LS_STATUS_CODE LSQuery(LS_HANDLE Handle, LS_ULONG Information,</I><dt><I><dd>LS_VOID *InfoBuffer, LS_ULONG BufferSize, 
</I><dt><I><dd>LS_ULONG *ActualBufferSize)</I></dl><h4>Release license</h4>
<dl><dt><I>LS_STATUS_CODE LSRelease(LS_HANDLE Handle, LS_ULONG 
TotUnitsConsumed, LS_STR *LogComment)</I></dl><h4>Request license</h4>
<dl><dt><I>LS_STATUS_CODE LS</I>Request(LS_STR *LicenseSystem,<dt><dd>LS_STR *PublisherName, LS_STR *ProductName,<dt><dd>LS_STR *Version, LS_ULONG TotUnitsReserved, 
<dt><dd>LS_STR *LogComment,<dt><dd>LS_CHALLENGE *Challenge,<dt><dd><dd>LS_ULONG *TotUnitsGranted,<dt><dd>LS_HANDLE *Handle)</dl><p><hr>
Note:	The challenge in your first 
LSRequest() call must be of type 
<TT>LS_CHALLENGE_FLEXLM</TT>, which is a 
FLEXlm<I></I> vendor specific challenge 
mechanism. Challenge should be setup as in the following code example before 
calling 
LSRequest():<hr><p>
<pre>LS_CHALLENGE_FLEXLM *Challenge;</pre>
<pre>LM_CODE(vendor_code, ENCRYPTION_SEED1, ENCRYPTION_SEED2, VENDOR_KEY1,</pre>
<pre>		VENDOR_KEY2, VENDOR_KEY3, VENDOR_KEY4, VENDOR_KEY5);</pre>
<pre>...</pre>
<pre>Challenge-&gt;Protocol = LS_FLEXLM_PROTOCOL;</pre>
<pre>strcpy( Challenge-&gt;ChallengeData.VendorName, VENDOR_NAME);</pre>
<pre>Challenge-&gt;ChallengeData.VendorCode = vendor_code;</pre>
<pre>Challenge-&gt;Size = sizeof(*Challenge);</pre>
<pre>...</pre>
<pre>LSRequest( ...., (LS_CHALLENGE *)Challenge, ...);</pre>
<h4>Update license status</h4>
<dl><dt><I>LS_STATUS_CODE LSUpdate(LS_HANDLE Handle,</I><dt><I><dd>LS_ULONG TotUnitsConsumed,</I><dt><I><dd>LS_ULONG TotUnitsReserved,</I><dt><I><dd>LS_STR *LogComment,</I><dt><I><dd>LS_CHALLENGE *lpChallenge,</I><dt><I><dd>LS_ULONG *TotUnitsGranted)</I></dl><p>
For more details on the LSAPI interface, see the `License Service Application 
Programming Interface, API Specification v1.1, or contact Microsoft via e-mail at 
`<TT>lsapi@microsoft.com</TT>', or Dave Berry, Microsoft Developer Relations, 1 Microsoft 
Way, 4/2, Redmond, WA 98052-6399.<p>
<p>
Remember, you cannot mix LSAPI and native 
FLEXlm<I></I> calls in a single application. 
The license servers can support a mix of applications which use either native 
FLEXlm<I></I> 
or LSAPI, but a single executable must use either native 
FLEXlm<I></I> or LSAPI.<p>
<a name="Appendix B "></a><hr><h1>Appendix B  
The <a name="_IX_554"></a>Debug <a name="_IX_555"></a><a name="_IX_556"></a>Log File</h1>
<p>
FLEXlm<I></I> 
<a name="_IX_557"></a>daemons all generate log files in the following format.<p>
<pre>mm/dd hh:mm (VENDOR NAME) message</pre>
</ol></ul><p>
<p>
<dl><dt><I>mm/dd hh:mm</I><dd>The time that the message was logged.<dt><I><a name="_IX_558"></a>VENDOR NAME</I><dd>Either 
<TT>lmgrd</TT> or the daemon name. In the case where a 
single copy of the daemon cannot handle all of the 
concurrent clients, an optional `_' followed by a number 
indicates that this message comes from a child daemon 
process.<dt><I>message</I><dd>The text of the message.</dl><p>
The log files can be used to:<p>
<ul><li>Diagnose configuration problems.<li>Diagnose daemon software errors.</ul><p>
The content of these messages is described below. If you have a source kit, these 
messages are also found by searching for the `LOG' macros in the<TT>.c</TT> files in the 
<I>server</I>, 
<I>app</I>, and 
<I>master</I> directories.<p>
<p><hr>
Note:	The debug log file is NOT suitable for usage reporting.<hr><p>
<a name="B.1"></a><h2>B.1  Informational Messages</h2>
<dl><dt>Connected to node<dd>This daemon is connected to its peer on `node'.<dt>CONNECTED, master is name<dd>The license daemons log this message when a 
quorum is up and everyone has selected a master.<dt>DEMO mode supports only one SERVER host!
An attempt was made to configure a demo version 
of the software for more than one server host.<dt>DENIED: N feature to user (mm/dd/yy hh:mm)
`user' was denied access to `N' licenses of 
`feature'.<dt>EXITING DUE TO SIGNAL nnn
EXITING with code nnn. All daemons list the 
reason that the daemon has exited.<dt>EXPIRED: feature<dd>`feature' has passed its expiration date.<dt>IN: feature by user (N licenses) 
<dd>`user' has checked back in `N' licenses of 
`feature' at mm/dd/yy hh:mm.<dt>IN server died: feature by user (number licenses)
`user' has checked in `N' licenses by virtue of the 
fact that his server exited.<dt>License Manager server started<dd>The license daemon was started.<dt>Lost connection to host<dd>A daemon can no longer communicate with its 
peer on node `host', which can cause the clients 
to have to reconnect, or cause the number of 
daemons to go below the minimum number, in 
which case clients may start losing their licenses. 
If the license daemons lose the connection to the 
master, they will kill all the vendor daemons; 
vendor daemons will shut themselves down.<dt>Lost quorum<dd>The daemon lost quorum, so will process only 
connection requests from other deamons.<dt>MASTER SERVER died due to signal nnn
The license daemon received fatal signal nnn.<dt>MULTIPLE xxx servers running.<dt>Please kill, and restart license daemon
The license daemon has detected that multiple 
copies of vendor daemon `xxx' are running. The 
user should kill all `xxx' daemon processes and 
re-start the license daemon.<dt>OUT: feature by user (N licenses)<dd>`user' has checked out `N' licenses of `feature' 
<dt>Removing clients of children<dd>The top-level daemon logs this message when one 
of the child daemons exits.<dt>RESERVE feature for HOST name<dt>RESERVE feature for USER name
A license of `feature' is reserved for either user 
`name' or host `name'.<dt>REStarted xxx (internet port nnn)<dd>Vendor daemon `xxx' was restarted at internet 
port `nnn'.<dt>Retrying socket bind (address in use)
The license servers try to bind their sockets for 
approximately 6 minutes if they detect `address in 
use' errors.<dt>Selected (EXISTING) master node.
This license daemon has selected an existing 
master (node) as the master.<dt>SERVER shutdown requested.<dd>A daemon was requested to shut down via a user-generated kill command.<dt>[NEW] Server started for: feature-list
A (possibly new) server was started for the 
features listed.<dt>Shutting down xxx<dd>The license daemon is shutting down the vendor 
daemon xxx.<dt>SIGCHLD received. Killing child servers
A vendor daemon logs this message when a 
shutdown was requested by the license daemon.<dt>Started name<dd>The license daemon logs this message whenever it 
starts a new vendor daemon.<dt>Trying connection to node<dd>The daemon is attempting a connection to `node'.</dl><a name="B.2"></a><h2>B.2  Configuration Problems</h2>
<dl><dt>hostname: Not a valid server host, exiting
This daemon was run on an invalid hostname.<dt>hostname: Wrong hostid, exiting
The hostid is wrong for `hostname'.<dt>BAD CODE for feature-name<dd>The specified feature name has a bad 
<a name="_IX_559"></a>license key.<dt>CANNOT OPEN options file `file'
The options file specified in the license file could 
not be opened.<dt>Couldn't find a master<dd>The daemons could not agree on a master.<dt>license daemon: lost all connections
This message is logged when all the connections 
to a server are lost, which often indicates a 
network problem.<dt>lost lock, exiting<dt>Error closing lock file<dt>Unable to re-open lock file<dd>The vendor daemon has a problem with its lock 
file, usually because of an attempt to run more 
than one copy of the daemon on a single node. 
Locate the other daemon that is running via a `ps' 
command, and kill it with `kill -9'.<dt>NO DAEMON line for 
<I>daemon</I><dd>The license file does not contain a `VENDOR' 
line for `<I>daemon</I>'<dt>No `FLEXlm<I></I>' service found<dd>The TCP `FLEXlm<I></I>' service did not exist in 
/etc/services.<dt>No features to serve!<dd>A vendor daemon found no features to serve. This 
could be caused by bad data in the license file.<dt>UNSUPPORTED FEATURE request: feature by user
The `user' has requested a feature that this vendor 
daemon does not support. This can happen for a 
number of reasons: the license file is bad, the 
feature has expired, or the daemon is accessing the 
wrong license file.<dt>Unknown host: hostname<dd>The hostname specified on a `SERVER' line in 
the license file does not exist in the network 
database (probably /etc/hosts).<dt>lm_server: lost all connections<dd>This message is logged when all the connections 
to a server are lost. This probably indicates a 
network problem.<dt>NO DAEMON lines, exiting<dd>The license daemon logs this message if there are 
no VENDOR lines in the license file. Since there 
are no vendor daemons to start, there is nothing to 
do.<dt>NO DAEMON line for name<dd>A vendor daemon logs this error if it cannot find 
its own VENDOR name in the license file.</dl><a name="B.3"></a><h2>B.3  Daemon Software Errors</h2>
<dl><dt>accept: message<dd>An error was detected in the `accept' system call.<dt>ATTEMPT TO START VENDOR DAEMON xxx with NO MASTER<dt><dd>A vendor daemon was started with no master 
selected. This is an internal consistency error in 
the daemons.<dt>BAD PID message from nnn: pid: xxx (msg)
A top-level vendor daemon received an invalid 
PID message from one of its children (daemon 
number xxx).<dt>BAD SCONNECT message: (message)
An invalid `server connect' message was 
received.<dt>Cannot create pipes for server communication
The `pipe' call failed.<dt>Can't allocate server table space<dd>A malloc error. Check swap space.<dt>Connection to node TIMED OUT<dd>The daemon could not connect to `node'<dt>Error sending PID to master server<dd>The vendor daemon could not send its PID to the 
top-level server in the hierarchy.<dt>f_do_notify called with no valid feature
This is an internal consistency error.<dt>Illegal connection request to DAEMON
A connection request was made to `DAEMON', 
but this vendor daemon is not `DAEMON'<dt>Illegal server connection request<dd>A connection request came in from another server 
without a DAEMON name.<dt>KILL of child failed, errno = nnn<dd>A daemon could not kill its child.<dt>No internet port number specified<dd>A vendor daemon was started without an internet 
port.<dt>Not enough descriptors to re-create pipes
<dd>The `top-level' daemon detected that one of its 
sub-daemons exited. In trying to restart the chain 
of sub-daemons, it was unable to get the file 
descriptors to set up the pipes to communicate. 
This is a fatal error, and the daemons must be re-started.<dt>read: error message<dd>An error in a `read' system call was detected.<dt>recycle_control BUT WE DIDN'T HAVE CONTROL
<dd>The hierarchy of vendor daemons has become 
confused over who holds the control token. This is 
an internal error.<dt>return_reserved: can't find feature listhead
<dd>When a daemon is returning a reservation to the 
`free reservation' list, it could not find the listhead 
of features.<dt>select: message<dd>An error in a select system call was detected.<dt>Server exiting<dd>The server is exiting. This is normally due to an 
error.<dt>SHELLO for wrong DAEMON<dd>This vendor daemon was sent a `server hello' 
message that was destined for a different 
`DAEMON'.<dt>Unsolicited msg from parent!<dd>Normally, the top-level vendor daemon sends no 
unsolicited messages. If one arrives, this message 
is logged. This is a bug.<dt>WARNING: CORRUPTED options list (o-&gt;next == 0)<dt>Options list TERMINATED at bad entry
An internal inconsistency was detected in the 
daemon's option list.</dl><a name="Appendix C "></a><hr><h1>Appendix C  
FLEXlm<I></I> Status Return Values</h1>
<dl><dt>These are all the possible errors returned from 
lc_xxx() functions.<dt>Error number<dd>Symbolic Name and Description</dl><pre>-1 <a name="_IX_560"></a>LM_NOCONFFILE			"cannot find license file"</pre>
<dl><dt><dd>The license file cannot be opened. 
FLEXlm<I></I> will attempt to 
open the standard file 
<TT>/usr/local/flexlm/licenses/license.dat</TT>,(or 
<TT>C:\FLEXLM\LICENSE.DAT</TT> on 
Windows and 
Windows NT) or the file specified by the vendor (via 
lc_set_attr()), or the file specified by the user in 
<TT>LM_LICENSE_FILE</TT>.</dl><pre>-2 <a name="_IX_561"></a>LM_BADFILE			"invalid license file syntax"</pre>
<dl><dt><dd>A feature name is &gt; MAX_FEATURE_LEN,<dt><dd>A daemon name is &gt; MAX_DAEMON_LEN.<dt><dd>A server name is &gt; MAX_SERVER_NAME.<dt><dd>A feature specifies no hostid and # of licenses is &lt;= 0.</dl><pre>-3 <a name="_IX_562"></a>LM_NOSERVER			"cannot connect to a license server"</pre>
<dl><dt><dd>The daemon name specified in the license file FEATURE 
line does not match the vendor daemon name.</dl><pre>-4 <a name="_IX_563"></a>LM_MAXUSERS			"licensed number of users already reached",</pre>
<dl><dt><dd>The licenses number of users has been reached.</dl><pre>-5 <a name="_IX_564"></a>LM_NOFEATURE			"no such feature exists"</pre>
<dl><dt><dd>The feature could not be found in the license file.</dl><pre>-6 <a name="_IX_565"></a>LM_NOSERVICE 			"no TCP "license" service exists"</pre>
<dl><dt><dd>This happens if a SERVER line does not specify a TCP port 
number, and the TCP license service does not exist in 
<TT>/etc/services</TT>.</dl><pre>-7 <a name="_IX_566"></a>LM_NOSOCKET 			"no socket connection to license manager server"</pre>
<dl><dt><dd>lc_disconn() was called after the process had been 
disconnected from the socket. This error can also occur if 
an internal error happens within 
l_sndmsg() or 
l_rcvmsg().</dl><pre>-8 <a name="_IX_567"></a>LM_BADCODE			"encryption code in license file is inconsistent"</pre>
<dl><dt><dd>The code in a license file line does not match the other data 
in the license file. This is usually the result of not building 
all the software components with the same encryption 
seeds. Check 
<TT>makekey.c</TT>, 
<TT>lsvendor.c</TT>, and your application 
code carefully to insure that they are all built with the same 
encryption seeds.</dl><pre>-9 <a name="_IX_568"></a>LM_NOTTHISHOST			"invalid host"</pre>
<dl><dt><dd>The hostid specified in the license file does not match the 
node on which the software is running.</dl><pre>-10 <a name="_IX_569"></a>LM_LONGGONE			"feature has expired"</pre>
<dl><dt><dd>The feature has expired, i.e., today's date is after the 
expiration date in the license file.</dl><pre>-11 <a name="_IX_570"></a>LM_BADDATE			"invalid date format in license file"</pre>
<dl><dt><dd>The start or expiration date in the license file is invalid.</dl><pre>-12 <a name="_IX_571"></a>LM_BADCOMM			"invalid returned data from license server"</pre>
<dl><dt><dd>The port number returned from 
<TT>lmgrd</TT> is invalid.<dt><dd>An attempted connection to a vendor daemon did not result 
in a correct acknowledgment from the daemon.<dt><dd>The daemon did not send back a message within the 
timeout interval.<dt><dd>A message from the daemon had an invalid checksum.<dt><dd>An 
lc_userlist() request did not receive the correct data.</dl><pre>-13 <a name="_IX_572"></a>LM_NO_SERVER_IN_FILE </pre>
<pre>			"no SERVER lines in license file"</pre>
<dl><dt><dd>There is no SERVER line in the license file. All non-zero 
license count features need at least one SERVER line.</dl><pre>-14 <a name="_IX_573"></a>LM_BADHOST			"cannot find SERVER hostname in network database"</pre>
<dl><dt><dd>The 
gethostbyname() system call failed for the SERVER 
nodename in the license file.</dl><pre>-15 <a name="_IX_574"></a>LM_CANTCONNECT			"cannot connect to license server"</pre>
<dl><dt><dd>The 
connect() system call failed, while attempting to 
connect to the daemon. 
<dt><dd>The attempt to connect to the vendor daemon on all 
SERVER nodes was unsuccessful.<dt><dd>lc_status() returns 
<TT>LM_CANTCONNECT</TT> if the feature had 
been checked out but the program is in the process of 
reconnecting. 
<dt><dd>If reconnection fails, the final status return is 
<TT>LM_CANTCONNECT</TT>.</dl><pre>-16 <a name="_IX_575"></a>LM_CANTREAD			"cannot read data from license server"</pre>
<dl><dt><dd>The process cannot read data from the daemon within the 
timeout interval.<dt><dd>The connection was reset by the daemon (usually because 
the daemon exited) before the process attempted to read 
data.</dl><pre>-17 <a name="_IX_576"></a>LM_CANTWRITE			"cannot write data to license server"</pre>
<dl><dt><dd>The process could not write data to the daemon after the 
connection was established.</dl><pre>-18 <a name="_IX_577"></a>LM_NOSERVSUPP			"license server does not support this feature"</pre>
<dl><dt><dd>The feature has expired (on the server), or has not yet 
started, or the version is greater than the highest supported 
version.</dl><pre>-19 <a name="_IX_578"></a>LM_SELECTERR			"error in select system call"</pre>
<dl><dt><dd>The 
select()<I> 
</I>system call failed.</dl><pre>-20 <a name="_IX_579"></a>LM_SERVBUSY			"license server busy (no majority)",</pre>
<dl><dt><dd>The license server is busy establishing a quorum of server 
nodes so that licensing can start. This error is very rare, and 
checkout should be retried if this occurs.</dl><pre>-21 <a name="_IX_580"></a>LM_OLDVER			"license file does not support this version"</pre>
<dl><dt><dd>The version requested is greater than the highest version 
supported in the license file FEATURE line.</dl><pre>-22 <a name="_IX_581"></a>LM_CHECKINBAD			"feature checkin failure detected at license
			server"</pre>
<dl><dt><dd>The checkin request did not receive a good reply from the 
vendor daemon (the license might still be considered in 
use).</dl><pre>-23 <a name="_IX_582"></a>LM_BUSYNEWSERV			"license server temporarily busy (new server
			connecting)",</pre>
<dl><dt><dd>The vendor daemon is in the process of establishing a 
quorum condition. New requests from clients are deferred 
during this period. This request should be retried.</dl><pre>-24 <a name="_IX_583"></a>LM_USERSQUEUED 			"users are queued for this feature"</pre>
<dl><dt><dd>This error is similar to MAXUSERS, but supplies the 
additional information that there are other users in the 
queue for this feature.</dl><pre>-25 <a name="_IX_584"></a>LM_SERVLONGGONE 			"license server does not support this version of
			this feature"</pre>
<dl><dt><dd>The version specified in the checkout request is greater than 
the highest version number the daemon supports.</dl><pre>-26 <a name="_IX_585"></a>LM_TOOMANY 	"request for more licenses than this feature supports"</pre>
<dl><dt><dd>A checkout request was made for more licenses than are 
available. This request will never succeed.</dl><pre>-29 <a name="_IX_586"></a>LM_CANTFINDETHER 			"cannot find ethernet device"</pre>
<dl><dt><dd>The ethernet device could not be located on this system.</dl><pre>-30 <a name="_IX_587"></a>LM_NOREADLIC			"cannot read license file"</pre>
<dl><dt><dd>The license file cannot be read (errno == EPERM or 
EACCES).</dl><pre>-31 LM_TOOEARLY			"feature not yet available"</pre>
<dl><dt><dd>The feature is not enabled yet (current date is before the 
feature start date).</dl><pre>-32 LM_NOSUCHATTR			"No such attribute"</pre>
<dl><dt><dd>A call to 
lc_get_attr() or 
lc_set_attr() specified an 
unknown attribute code.</dl><pre>-33 <a name="_IX_588"></a>LM_BADHANDSHAKE 			"Bad encryption handshake with daemon"</pre>
<dl><dt><dd>The client performs an encryption handshake operation 
with the daemon prior to any licensing operations. This 
handshake operation failed.</dl><pre>-34 <a name="_IX_589"></a>LM_CLOCKBAD			"Clock difference too large between client and
			server"</pre>
<dl><dt><dd>The date on the client system does not agree closely enough 
with the date on the server (daemon) system. The amount 
of difference allowed is set by the software vendor with 
<TT>lc_set_attr(LM_A_MAX_TIMEDIFF, ...)</TT>.</dl><pre>-35 <a name="_IX_590"></a>LM_FEATQUEUE			"In the queue for this feature"</pre>
<dl><dt><dd>This checkout request has resulted in the process being 
placed in the queue for this feature. Subsequent calls to 
lc_status()<I> 
</I>will yield the status of this queued request.</dl><pre>-36 LM_FEATCORRUPT 			"Feature database corrupted in daemon"</pre>
<dl><dt><dd>The daemon's run-time feature data structures have 
become corrupted. This is an internal daemon error.</dl><pre>-37 <a name="_IX_591"></a>LM_BADFEATPARAM			"Duplicate selection mismatch for this feature"</pre>
<dl><dt><dd>The checkout request for this feature has specified a 
duplicate mask that does not match the mask specified by 
an earlier checkout. This is probably the result of using 
different versions of your client software, or from having an 
uninitialized variable in the 
<I>dup_group</I> field for 
lc_checkout(). 
</dl><pre>-38 <a name="_IX_592"></a>LM_FEATEXCLUDE 			"User/host on EXCLUDE list for feature"</pre>
<dl><dt><dd>The user/host/display has been excluded from this feature 
by an end-user's daemon option file.</dl><pre>-39 <a name="_IX_593"></a>LM_FEATNOTINCLUDE 			"User/host not on INCLUDE list for feature"</pre>
<dl><dt><dd>The user/host/display has NOT been included in this 
feature by an end-user's daemon option file.</dl><pre>-40 <a name="_IX_594"></a>LM_CANTMALLOC 			"Cannot allocate dynamic memory"</pre>
<dl><dt><dd>The 
malloc() call failed to return sufficient memory. 
</dl><pre>-41 <a name="_IX_595"></a>LM_NEVERCHECKOUT 			"Feature was never checked out"</pre>
<dl><dt><dd>This code is returned by 
lc_status() if the feature requested 
has never been checked out.</dl><pre>-42 <a name="_IX_596"></a>LM_BADPARAM			"Invalid parameter"</pre>
<dl><dt><dd>A call to 
lc_set_attr() specified an invalid value for its 
attribute.<dt><dd><I>lc_get_attr(LM_A_MASTER,...)</I><TT> 
</TT>called without connection 
already established to server.</dl><pre>-43 <a name="_IX_597"></a>LM_NOKEYDATA			"No FLEXlm key data supplied in lc_new_job() call"</pre>
<dl><dt><dd>No 
FLEXlm<I></I> key data was supplied to the 
lc_new_job() call. 
Some 
FLEXlm<I></I><I> 
</I>functions will be disabled.</dl><pre>-44 <a name="_IX_598"></a>LM_BADKEYDATA			"Invalid FLEXlm key data supplied"</pre>
<dl><dt><dd>Invalid 
FLEXlm<I></I> key data was supplied to the 
lc_new_job() 
call. Some 
FLEXlm<I></I> functions will be disabled.</dl><pre>-45 <a name="_IX_599"></a>LM_FUNCNOTAVAIL			"FLEXlm function not available in this version"</pre>
<dl><dt><dd>This 
FLEXlm<I></I> function is not available. This could be a 
result of a BADKEYDATA, NOKEYDATA, or DEMOKIT 
return from 
lc_new_job().</dl><pre>-47 <a name="_IX_600"></a>LM_NOCLOCKCHECK			"Clock setting check not available in daemon"</pre>
<dl><dt><dd>lc_checkout() returns this code when the CLOCK 
SETTING check between client and daemon is not 
supported in this daemon. To disable the clock check:</dl><pre>				lc_set_attr(LM_A_MAX_TIMEDIFF, -1)</pre>
<pre>-48 <a name="_IX_601"></a>LM_BADPLATFORM			"FLEXlm platform not enabled"</pre>
<dl><dt><dd>The software is running on a platform which is not 
supported by the vendor keys you have purchased. To 
purchase keys for additional platforms, contact 
GLOBEtrotter Software<I></I>.</dl><pre>-49 <a name="_IX_602"></a>LM_DATE_TOOBIG			"Date too late for binary format"</pre>
<dl><dt><dd>The start date format in 
FLEXlm<I></I> licenses are good until the 
year 2027. This is probably a bad date.</dl><pre>-50 <a name="_IX_603"></a>LM_EXPIREDKEYS			"FLEXlm key data has expired"</pre>
<dl><dt><dd>The 
FLEXlm<I></I> Demo vendor keys have expired. Contact 
Globetrotter Software for new demo keys.</dl><pre>-51 <a name="_IX_604"></a>LM_NOFLEXLMINIT 			"FLEXlm not initialized"</pre>
<dl><dt><dd>A 
FLEXlm<I></I> function was called before 
lc_new_job() was 
called. Always call 
lc_new_job() first.</dl><pre>-52 <a name="_IX_605"></a>LM_NOSERVRESP			"Server did not respond to message"</pre>
<dl><dt><dd>UDP communications failure. UDP communications are 
not guaranteed. 
FLEXlm<I></I> makes a best effort to recover 
from lost and garbled messages, but this indicates a failure.</dl><pre>-53 <a name="_IX_606"></a>LM_CHECKOUTFILTERED 	"Request rejected by vendor-defined filter"</pre>
<dl><dt><dd>lc_checkout() failed because of the vendor defined routine 
which is set in 
<TT>lsvendor.c</TT>: 
<I>ls_outfilter</I>.</dl><pre>-54 <a name="_IX_607"></a>LM_NOFEATSET			"No FEATURESET line present in license file"</pre>
<dl><dt><dd>lc_ck_feats() called, but no FEATURESET line in license 
file.</dl><pre>-55 <a name="_IX_608"></a>LM_BADFEATSET			"Incorrect FEATURESET line in license file"</pre>
<dl><dt><dd>Error return from 
lc_ck_feats()</dl><pre>-56 <a name="_IX_609"></a>LM_CANTCOMPUTEFEATSET 	"Cannot compute FEATURESET line"</pre>
<dl><dt><dd>Error return from 
lc_ck_feats(), which occurs because 
lc_feat_set()<I> 
</I>can not compute the FEATURESET line. This 
can happen because there are no FEATUREs in the file.</dl><pre>-57 <a name="_IX_610"></a>LM_SOCKETFAIL			"socket() call failed"</pre>
<dl><dt><dd>This can occur when the 
Unix<I></I> OS runs out of system 
resources.</dl><pre>-58 <a name="_IX_611"></a>LM_SETSOCKFAIL			"setsockopt() failed"</pre>
<dl><dt><dd>The 
setsockopt() call has failed. This is likely due to an OS 
error.</dl><pre>-59 <a name="_IX_612"></a>LM_BADCHECKSUM	 		"message checksum failure"</pre>
<dl><dt><dd>Communications error -- messages between client and 
server are encrypted and checksummed for security and 
integrity. The checksum will usually fail because of poor 
networking communications.</dl><pre>-61 <a name="_IX_613"></a>LM_SERVNOREADLIC 		"Cannot read license file from server"</pre>
<dl><dt><dd>This occurs when the license file, via 
<TT>LM_LICENSE_FILE</TT>, 
or 
<TT>lc_set_attr(LM_A_LICENSE_FILE, 
</TT><I>path</I><TT>)</TT>, is 
incorrectly defined. This only occurs in lmutil when 
<TT>LM_LICENSE_FILE</TT> is set to 
<I>port</I>@<I>host or @host</I>.</dl><pre>-62 <a name="_IX_614"></a>LM_NONETWORK			"Network software (tcp/ip) not available"</pre>
<dl><dt><dd>This is reported on systems where this is detectable. Some 
systems may have this problem, but the error will not be 
reported as 
<TT>LM_NONETWORK</TT> - system calls will simply 
fail.</dl><pre>-63 <a name="_IX_615"></a>LM_NOTLICADMIN			"Not a license administrator"</pre>
<dl><dt><dd>Various functions, such as 
lc_remove() and 
lc_shutdown(), 
require that the user be an license administrator, depending 
on how lmgrd was started.</dl><pre>-64 <a name="_IX_616"></a>LM_REMOVETOOSOON 	"lmremove request too soon"</pre>
<dl><dt><dd>An lc_remove request occurred, but ls_min_lmremove 
(defined in<I> lsve</I><TT>ndor.c</TT>) seconds have not elapsed since the 
license was checked out. See 
ls_vendor().</dl><pre>-65 <a name="_IX_617"></a>LM_BADVENDORDATA 	"Bad VENDORCODE struct passed to lc_new_job()"</pre>
<dl><dt><dd><TT>LM_CODE</TT> macro was not used to define the 
VENDORCODE argument for 
<I>lc_new_job</I>. See lm_code.h 
and lmflex.c for an example of how to use the 
<TT>LM_CODE</TT> 
macro.</dl><pre>-66 <a name="_IX_618"></a>LM_LIBRARYMISMATCH 	"FLEXlm include file/library mismatch"</pre>
<dl><dt><dd>An attempt was made to create a licensed binary with 
mismatching source/header files and 
liblmgr.a. The source 
code version must match the linking libraries.</dl><pre>-71  LM_BAD_TZ			"Invalid TZ environment variable"</pre>
<dl><dt><dd>On some operating systems, the end-user can significantly 
change the date using the TZ environment variable. This 
error detects this type of theft.</dl><pre>-72 <a name="_IX_619"></a>LM_OLDVENDORDATA			"'Old-style' vendor keys (3-word)"</pre>
<dl><dt><dd><I>lm_init()</I> detected that an old 
<TT>LM_CODE</TT> macro was used.</dl><pre>-73 <a name="_IX_620"></a>LM_LOCALFILTER			"Local checkout filter requested request"</pre>
<dl><dt><dd>Request was denied by filter specified in 
<TT>lc_set_attr(LM_A_CHECKOUTFILTER, 
</TT><I>filter</I><TT>)</TT>.</dl><pre>-74 <a name="_IX_621"></a>LM_ENDPATH			"Attempt to read beyond the end of LF path"</pre>
<dl><dt><dd>An error occurred with the list of license files.</dl><pre>-75 LM_VMS_SETIMR_FAILED	 	"SYS$SETIMR call failed"</pre>
<dl><dt><dd><TT>SYS$SETIMR</TT> is used on 
VMS to time out certain 
FLEXlm<I></I> 
system calls.</dl><pre>-76 LM_INTERNAL_ERROR		 "Internal FLEXlm Error - Please report to Globetrotter Software"</pre>
<pre>-77 LM_BAD_VERSION			"Bad version number - must be floating point number, with no letters"</pre>
<dl><dt><dd>A line in the license file has an invalid version number.<dt><dd>lc_checkout() was called with an invalid version character 
string.</dl><pre>-78 <a name="_IX_622"></a>LM_NOADMINAPI			"FLEXadmin API functions not available"</pre>
<dl><dt><dd>An attempt to get information from another company's 
vendor daemon was made via 
<TT>lc_get_attr(LM_A_VD_*, ...)</TT>. 
This function call is only allowed for the ISV's own vendor 
daemon.</dl><pre>-82  LM_BADPKG			"Invalid PACKAGE line in license file"</pre>
<dl><dt><dd>PACKAGE missing or invalid COMPONENTS.
A COMPONENT has number of licenses set, with 
OPTIONS=SUITE.
A COMPONENT has number of licenses==0</dl><pre>-83 <a name="_IX_623"></a>LM_SERVOLDVER			`Server FLEXlm version older than client's'</pre>
<dl><dt><dd>Vendor daemon 
FLEXlm<I></I> version is older than the client's 
FLEXlm<I></I> version. This is only supported with a v5.0+ 
client.</dl><pre>-84 <a name="_IX_624"></a>LM_USER_BASED			`Incorrect number of USERS/HOSTS INCLUDED in 
			options file -- see server log'</pre>
<dl><dt><dd>When a feature has the USER_BASED attribute, this error 
occurs when there no INCLUDE line in the end-user 
options file for this feature, or the number of users included 
exceeds the number authorized. See 
<a href="#79592: 2head: 9.1.3 FEATURE or INCREMENT Line">Section 6.3.4, 
`FEATURE or INCREMENT Line,' on page 96</a>, 
especially USER_BASED.</dl><pre>-85 <a name="_IX_625"></a>LM_NOSERVCAP			`Server doesn't support this request'</pre>
<dl><dt><dd>This occurs when a vendor daemon with a 
FLEXlm<I></I> version 
older than the client is being used. The daemon didn't 
understand and respond to the request made by the 
application.</dl><pre>-86 <a name="_IX_626"></a>LM_OBJECTUSED			`This license object already in use' </pre>
<dl><dt><dd><dd><dd>Java only. A second checkout against a license object 
generates this error. If multiple checkouts are needed, 
multiple license objects need to be created.</dl><pre>-87 <a name="_IX_627"></a>LM_MAXLIMIT			`Checkout exceeds MAX specified in options file'</pre>
<dl><dt><dd><dd><dd>End-user option MAX has been specified for this feature.</dl><pre>-88 <a name="_IX_628"></a>LM_BADSYSDATE			`System clock has been set back'</pre>
<dl><dt><dd><dd><dd>Returned from checkout call.</dl><pre>-89 <a name="_IX_629"></a>LM_PLATNOTLIC			`This platform not authorized by license'</pre>
<dl><dt><dd><dd><dd>Returned from checkout call where FEATURE line 
specifies 
<a name="_IX_630"></a>PLATFORMS='...'.</dl><pre>-90 <a name="_IX_631"></a>LM_FUTURE_FILE			`Future license file format ormisspelling in 
			 license file'</pre>
<dl><dt><dd><dd><dd>Returned from checkout call when license file attribute was 
introduced in a later 
FLEXlm<I></I> version than the client.</dl><pre>-91 <a name="_IX_632"></a>LM_DEFAULT_SEEDS			`ENCRYPTION_SEEDs are non-unique'</pre>
<dl><dt><dd>Returned from lc_new_job or lp_checkout() when vendor 
name is not `demo', but seeds are default seeds.</dl><pre>-92 <a name="_IX_633"></a>LM_SERVER_REMOVED			Feature removed during lmreread,or wrong SERVER
			line hostid</pre>
<dl><dt><dd>Checkout failure due to 2 possible causes. 1) the feature is 
removed during lmreread, but the client is reading an old 
copy of the license file which still has removed feature. 2) 
The hostid on the SERVER line is for a different host, so all 
features in this license file were removed.</dl><pre>-93 <a name="_IX_634"></a>LM_POOL			`This feature is available in a different 
			 license pool'</pre>
<dl><dt><dd>This is a possible response to 
LM_A_VD_FEATURE_INFO request, indicating that this 
INCREMENT line can be ignored, as it has been pooled 
with another line.</dl><pre>-94 <a name="_IX_635"></a>LM_LGEN_VER			`Attempt to generate license with 
			 incompatible attributes'</pre>
<dl><dt><dd>Occurs with -verfmt arguments to lmcrypt or makekey, or 
for lminstall, -overfmt. Also set by lc_cryptstr() and 
lc_chk_conf().</dl><pre>-95 <a name="_IX_636"></a>LM_NOT_THIS_HOST			`Network connect to THIS_HOST failed'</pre>
<dl><dt><dd>Returned by checkout. When `this_host' is used as a 
hostname. Replace this_host with a real hostname to 
resolve this error.</dl><pre>-96 <a name="_IX_637"></a>LM_HOSTDOWN			`Server node is down or not responding'</pre>
<dl><dt><dd>Returned by checkout; indicates the whole license-server 
system is not up, not just the lmgrd process.</dl><pre>-97 <a name="_IX_638"></a>LM_VENDOR_DOWN			`The desired vendor daemon is down'</pre>
<dl><dt><dd>Returned by checkout; indicates lmgrd is running, but not 
the vendor daemon.</dl><pre>-98 <a name="_IX_639"></a>LM_CANT_DECIMAL			`The FEATURE line can't be converted to 
			decimal format'</pre>
<dl><dt><dd>Returned by lc_cryptstr(), or lmcrypt/makekey/lminstall. 
See the section on Decimal Format for information on what 
can't be converted to decimal format.</dl><pre>-99 LM_BADDECFILE			`The decimal format license is typed incorrectly'</pre>
<dl><dt><dd>The internal checksum on the decimal line has indicated the 
line has been typed in incorrectly.</dl><pre>-100 <a name="_IX_640"></a>LM_REMOVE_LINGER			`Cannot remove a lingering license'</pre>
<dl><dt><dd>Returned to 
<TT>lmremove</TT> command. User has already exited, 
but license is lingering. lmremove doesn't remove the 
linger time.</dl><pre>-101 <a name="_IX_641"></a>LM_RESVFOROTHERS			`All licenses are reserved for others'</pre>
<dl><dt><dd>Checkout return value when a checkout will never succeed, 
since the end-user options file has all licenses reserved for 
others.</dl><pre>-106 <a name="_IX_642"></a>LM_SERVER_MAXED_OUT			`License server out of network connections'</pre>
<dl><dt><dd>The vendor daemon can't handle any more users. See the 
lmgrd debug log for further information.</dl><pre>-110 <a name="_IX_643"></a>LM_NODONGLE			`Dongle not attached, or can't read dongle'</pre>
<dl><dt><dd>In order to read the dongle hostid, the correct driver must 
be installed.  These drivers are available at 
www.globetrotter.com or from your software vendor.</dl><pre>-111 <a name="_IX_644"></a>LM_NORESLINK			`lmgr.res, Windows Resource file, not linked'</pre>
<dl><dt><dd>When linking Windows binaries, you must link with 
lmgr.lib as well as lmgr.res</dl><pre>-112 <a name="_IX_645"></a>LM_NODONGLEDRIVER	`Missing Dongle Driver'</pre>
<dl><dt><dd>In order to read the dongle hostid, the correct driver must 
be installed.  These drivers are available at 
www.globetrotter.com or from your software vendor.</dl><pre>-113 <a name="_IX_646"></a>LM_FLEXLOCK2CKOUT	`2 FLEXlock checkouts attempted'</pre>
<dl><dt><dd> Only 1 checkout is allowed with FLEXlock enabled 
apps.Subsequent checkout attempts will fail.  They should 
be disabled if first checkout succeeded in FLEXlock mode.</dl><a name="Appendix D "></a><hr><h1>Appendix D  
FLEX<I>lm</I> Limits</h1>
<p>
Any limitations such as string lengths are listed here. Items that are unlimited are also 
listed for clarification.<p>
<a name="_IX_647"></a><a name="D.1"></a><h2>D.1  License File Limits</h2>
<p>
The limits on names for the major parameters employed in the 
FLEXlm<I></I> license file are:<p>
<dl><dt>Host Name length<dd>32 characters<a name="_IX_648"></a><dt>FEATURE Name length<dd>30 characters<a name="_IX_649"></a><dt>FEATURE/INCREMENT/UPGRADE/PACKAGE line length 
<dt><dd>2048 characters<dt>VENDOR Names<dd>10 characters<a name="_IX_650"></a><dt>Version<dd>10 characters, in floating point format, e.g., 
<I>123.4567</I>, or 
<I>2.10</I><dt>Latest 
<a name="_IX_651"></a>expiration-date<dd>31-dec-9999 (but we recommend using `permanent' 
instead)<dt>Number of users<dd>32-bit integer<dt>Latest 
<a name="_IX_652"></a>start date<dd><a name="_IX_653"></a>license key: 
<dd>31-dec-2027
START=: 31-dec-9999<dt>Number of FEATUREs<dd>Unlimited (Same for INCREMENT/UPGRADE)<dt>Number of VENDORs<dd>Unlimited<dt>Number of SERVERs<dd>3 (Redundant server licenses are limited to 3 servers)<a name="_IX_654"></a><dt>OVERDRAFT<dd>32-bit integer<a name="_IX_655"></a><dt>USER_BASED=<I>n</I><dd>32-bit integer (Same for HOST_BASED)<dt>MINIMUM=<I>n<dd></I>32-bit integer<dt>Other optional FEATURE attributes
<dd>Limited only by the total length of the FEATURE line.</dl><a name="_IX_656"></a><p>
Decimal Format<p>
<dl><dt>Max readable length that can be converted to decimal<dd>
Approximately 100 characters. Since ascii text becomes 
much larger in decimal format, a FEATURE line of 100 
characters is unreadable and more prone to data entry errors 
in decimal format.<dt>Convertible Licences<dd>Everything but PACKAGE and FEATURESET lines.<dt>Convertible FEATURE names<dd>
Only officially supported FEATURE names. In particular, 
'-' (hyphen) cannot be converted.</dl><a name="_IX_657"></a><a name="D.2"></a><h2>D.2  End-User Options File Limits</h2>
<p>
The line length limit is the same as the FEATURE line length (2048 characters). There 
are no other string size limitations on anything in this file. Note that GROUPs can be 
made arbitrarily large by listing the GROUP more than once - FLEXlm<I></I> concatenates 
such entries.<p>
<a name="_IX_658"></a><a name="D.3"></a><h2>D.3  lc_set_attr() limits</h2>
<dl><a name="_IX_659"></a><dt>LM_A_DISPLAY_OVERRIDE<dd>32 characters<a name="_IX_660"></a><dt>LM_A_HOSTNAME_OVERRIDE<dd> 64 characters<a name="_IX_661"></a><dt>LM_A_USERNAME<dd>20 characters<a name="_IX_662"></a><dt>LM_A_CHECKOUT_DATA<dd>32 characters<a name="_IX_663"></a><dt>LM_A_CHECK_INTERVAL<dd>&gt;20 (seconds)</dl><a name="D.4"></a><h2>D.4  Other API limits</h2>
<dl><a name="_IX_664"></a><dt>Vendor-defined hostid length<dd>40 - including the `NAME=' prefix.<dt>Vendor-defined FEATURE 
<a name="_IX_665"></a>license key length
20<dt>Number of licenses in one 
<I>lc_checkout()</I> request
9999<dt>Long error message length<dd>1024 characters (length of string returned from 
<I>lc_errstring()</I>)</dl><a name="_IX_666"></a><a name="D.5"></a><h2>D.5  Vendor Daemon Limits</h2>
<h4>Number of Clients Per Vendor Daemon</h4>
<p>
When using TCP, a single vendor daemon can support as many clients as the system 
limit for file descriptors and sockets, which varies from around 250 on sunos4 (the only 
known system with a limit this low) to 4000 on OSF/1 (SCO comes with a configurable 
default of around 8). 
<p>
<p>
In practice, we encourage end-users to put servers on systems configured with enough 
file descriptors per process to support the number of end-users connecting to the 
vendor daemon, which may require reconfiguring the kernel to increase the number of 
file descriptors per process.<p>
<p>
Nearly all systems can handle 250 clients per vendor daemon without performance 
problems, and large systems can easily support over a thousand.<p>
<p>
While file descriptors are exhausted, additional vendor daemons are spawned to 
support the extra file descriptors. the maximum number of spawned daemons is 255, 
which effectively limits the maximum number of clients to 256*25 -(2* # servers -1) 
or approximately 6,400 per vendor daemon.<p>
<p>
When using UDP, there is no limit to the number of clients. Note that multiple daemons 
can be run on a single network, making the number of even TCP clients effectively 
unlimited.<p>
<h4>Number of Vendor Daemons Per Node</h4>
<p>
A 
<I>particular</I> vendor daemon can only be run once per node. This is a security 
mechanism to prevent extra licenses from being granted. 
<p>
<p>
There is no limit to the number of 
<I>different</I> vendor daemons that can be run per node.<p>
<a name="_IX_667"></a><a name="D.6"></a><h2>D.6  lmgrd</h2>
<dl><dt>lmgrd processes per node<dd>Unlimited<dt>Default port number range<dd>27000-27009<dt>License files per lmgrd process<dd>Unlimited</dl><a name="_IX_668"></a><a name="_IX_669"></a><a name="_IX_670"></a><a name="D.7"></a><h2>D.7  Sub-net, Domains, Wide-Area Networks</h2>
<p>
FLEXlm<I></I> has no limitations regarding subnets (since 
FLEXlm<I></I> does not use 
<I>broadcast</I> 
messages).<p>
<p>
If the hostname in the license file is fully-qualified (<I>name.domain.suf</I>) or is an IP-Address (<I>nnn.nnn.nnn.nnn</I>), then there are no limitations with regard to internet 
domains.<p>
<p>
There are no other limitations regarding wide-area networks.<p>
<a name="_IX_671"></a><a name="D.8"></a><h2>D.8  LM_LICENSE_FILE</h2>
<dl><dt>Number of licenses in path<dd>Unlimited</dl><a name="Appendix E "></a><hr><h1>Appendix E  
<a name="42591: AppTitle: Appendix F Additional lc_set_attr() Attributes"></a>Additional lc_set_attr() Attributes</h1>
<p>
The attributes listed in this section should be used with caution, as they are rarely 
needed, and can cause problems if inappropriately used.<p>
<a name="10309: 2head: 5.1.2 LM_A_CHECK_INTERVAL, LM_A_TIMER_TYPE"></a><a name="E.1"></a><h2>E.1  LM_A_ALLOW_SET_TRANSPORT</h2>
<h3>Type</h3>
<p>
int<p>
<p>
This option allows you to disable the end-user selection of communications transport, 
which they can do with either the daemon options file, or the 
<TT><a name="_IX_672"></a>FLEXLM_COMM_TRANSPORT</TT> environment variable.<p>
<h3>Default</h3>
<p>
On(1), i.e., end-users can select communications transport.<p>
<h4>See also</h4>
<ul><li><a href="#66148: 1head: 11.5 Communications Transport (TCP vs. UDP)">Section Chapter 11, `Communications Transport,' on page 145</a></ul><a name="_IX_673"></a><a name="E.2"></a><h2>E.2  LM_A_ALT_ENCRYPTION</h2>
<h3>Type</h3>
<p>
(VENDORCODE *)<p>
<p>
This option allows a vendor to more easily migrate to a new set of encryption seeds 
while still supporting old license files in the field. This option would be used in new 
applications until all the old license files in the field were replaced. 
<p>
<p>
Here's an example of the use of 
<TT>ALT_ENCRYPTION</TT>:<p>
<p>
Your company has 3 products, which are widely available, and you want eventually to 
make the old license files obsolete. You could do this by generating new license files 
with a new set of encryption seeds (the two hexadecimal numbers in lm_code.h that 
your company defines), but you might want to phase this in, since the 3 products will 
not all be re-released with the new encryption seeds for a year and you want the old 
versions to continue to work.<p>
<p>
The solution is to make the new products support both old and new license files, 
shipping with new vendor daemons that will accept both old and new license files. At 
this point, license files would be shipped generated with the new encryption seeds.<p>
<p>
Once all three new products become available, and all new license files are generated 
with the new encryption seeds; later versions of the products and vendor daemons can 
be released that will only accept the new encryption seeds.<p>
<p>
Here is an excerpt from the interim client code:<p>
<pre>lm_code.h:</pre>
<pre>	/* newcode */</pre>
<pre>	LM_CODE(newcode, ENCRYPTION_SEED1,</pre>
<pre>			ENCRYPTION_SEED2, VENDOR_KEY1, VENDOR_KEY2,</pre>
<pre>                        VENDOR_KEY3, VENDOR_KEY4, VENDOR_KEY5);</pre>
<pre>	/* oldcode */</pre>
<pre>	LM_CODE(oldcode, OLD_ENCRYPTION_SEED1,</pre>
<pre>                        OLD_ENCRYPTION_SEED2, VENDOR_KEY1, VENDOR_KEY2,</pre>
<pre>                        VENDOR_KEY3, VENDOR_KEY4, VENDOR_KEY5);</pre>
<pre>application.c:</pre>
<pre>	rc = lc_new_job((LM_HANDLE *)0, VENDOR_NAME, &amp;newcode, &amp;lm_job);</pre>
<pre>	lc_set_attr(lm_job, LM_A_ALT_ENCRYPTION, &amp;oldcode);</pre>
<pre>/* lc_checkout will try both newcode and oldcode */</pre>
<pre>	rc = lc_checkout(lm_job, feature, version, checkout_cnt,</pre>
<pre>			LM_CO_NOWAIT, &amp;newcode, LM_DUP_NONE);</pre>
</ol></ul><p>
Also, in the 
<TT>lsvendor.c</TT> file, the first version of the vendor daemon would need to 
support both encryption seeds, as follows:<p>
<pre>	/*</pre>
<pre>	 * Read license files using either vendorkeys and</pre>
<pre>	 * accept connections from clients using either</pre>
<pre>	 * vendorkeys</pre>
<pre>	 */</pre>
<pre>	VENDORCODE vendorkeys[] = {</pre>
<pre>		   {VENDORCODE_4, ENCRYPTION_SEED1, ENCRYPTION_SEED2,</pre>
<pre>		 	VENDOR_KEY1, VENDOR_KEY2, VENDOR_KEY3, </pre>
<pre>			VENDOR_KEY4,FLEXLM_VERSION, FLEXLM_REVISION},</pre>
<pre>		  {VENDORCODE_4, OLD_ENCRYPTION_SEED1, 			
		       OLD_ENCRYPTION_SEED2, VENDOR_KEY1, VENDOR_KEY2, 
		       VENDOR_KEY3, VENDOR_KEY4, FLEXLM_VERSION, 
		       FLEXLM_REVISION}};</pre>
</ol></ul><p>
The final version of the vendor daemon, (the one that would no longer support old 
license files) would have the second vendor key (the one with 
OLD_ENCRYPT_CODE_<I>n</I>) removed, and the next release of the applications would 
have the 
<TT>lc_set_attr(LM_A_ALT_ENCRYPTION,...)</TT><I> 
</I>call removed.<p>
<h3>Default</h3>
<p>
None.<p>
<a name="_IX_674"></a><a name="E.3"></a><h2>E.3  LM_A_COMM_TRANSPORT</h2>
<h3>Type</h3>
<p>
short<p>
<p>
Communications transport to use, one of 
<TT><a name="_IX_675"></a>LM_TCP</TT> or 
<TT><a name="_IX_676"></a>LM_UDP</TT>. It is recommended 
that this be set by the end-user (license administrator), not set in the application.<p>
<h3>Default</h3>
<p>
<I>LM_TCP</I>.<p>
<p><hr>
Note:	Not supported on 
<a name="_IX_677"></a>VMS.<hr><p>
<h4>See also</h4>
<ul><li><a href="#66148: 1head: 11.5 Communications Transport (TCP vs. UDP)">Section Chapter 11, `Communications Transport,' on page 145</a></ul><a name="_IX_678"></a><a name="E.4"></a><h2>E.4  LM_A_CONN_TIMEOUT</h2>
<h3>Type</h3>
<p>
int<p>
<p>
If specified as a positive integer, 
<I>conn_timeout</I> will set the timeout for connection to a 
vendor daemon, as well as subsequent reads from the daemon. For 
connect(), this 
timeout overrides the TCP/IP default of 45 seconds. 
<I>lc_set_attr()</I> will return 
<TT>LM_BADPARAM</TT>, which will also be returned from 
<I>lc_get_errno()</I>, if this value is &lt;0.<p>
<p><hr>
Note:	Prior to 
FLEXlm<I></I> v4.0, this timeout only applied to 
<I>connect()</I>.<hr><p>
<h3>Default</h3>
<p>
10 seconds. 
<p>
<a name="_IX_679"></a><a name="34313: 2head: 5.1.9 LM_A_CRYPT_CASE_SENSITIVE"></a><a name="E.5"></a><h2>E.5  LM_A_CRYPT_CASE_SENSITIVE</h2>
<h3>Type</h3>
<p>
short<p>
<p>
If specified as a non-zero integer, 
<TT>LM_A_CRYPT_CASE_SENSITIVE</TT><I> 
</I>will cause the 
output of the authentication routine to be compared to the code in the license file with 
a case-sensitive comparison. 
<p>
<h3>Default</h3>
<p>
Case-insensitive comparison. 
<p>
<a name="_IX_680"></a><a name="E.6"></a><h2>E.6  LM_A_DIAGS_ENABLED</h2>
<h3>Type</h3>
<p>
short<p>
<p>
This option allows 
FLEXlm<I></I> to produce some diagnostic output for failures of the 
lc_checkout() call if the environment variable 
<a name="_IX_681"></a><TT>FLEXLM_DIAGNOSTICS</TT> is set. If 
<TT>LM_A_DIAGS_ENABLED</TT> is set to 0, this diagnostic information is unconditionally 
disabled. 
<p>
<p>
The 
<TT>FLEXLM_DIAGNOSTICS</TT> environment variable can be used by your end-users to 
obtain more information if a checkout fails. If 
<TT>FLEXLM_DIAGNOSTICS</TT> is set, an 
lc_perror() call is made. If 
<TT>FLEXLM_DIAGNOSTICS</TT> is set to `2', then in addition to 
the 
lc_perror() call, the arguments to 
lc_checkout() (except for the KEY information) 
are printed to stderr, also (On Windows, this is logged to flex_err.log). 
<p>
<p>
The diagnostics are enabled by default. 
GLOBEtrotter Software<I></I> recommends that this 
be left<I> 
</I>enabled. This will allow us to help you debug your end-users' problems with 
error messages more explicit than, `can't get license'. In these situations, we are 
unable to help. We developed and distributed the 
<TT>FLEXLM_DIAGNOSTICS</TT> to enable 
us (and your support people) to help your end-users more effectively.<p>
<h3>Default</h3>
<p>
On (1).<p>
<a name="76398: 2head: 5.1.12 LM_A_DISABLE_ENV"></a><a name="E.7"></a><h2>E.7  LM_A_DISABLE_ENV</h2>
<h3>Type</h3>
<p>
short<p>
<p>
If set to a non-zero value, 
<I>disable_env</I> will force the 
FLEXlm<I></I> client routines to 
disregard the setting of the 
<a name="_IX_682"></a><TT>LM_LICENSE_FILE</TT> environment variable. It's rare that 
there's a legitimate reason to use this, but it does come up with certain utilities that may 
explicitly need to ignore the LM_LICENSE_FILE environment variable. It is strongly 
discouraged that this be used in your applications, as many end-user sites are familiar 
with 
FLEXlm<I></I>, and need to assume that $LM_LICENSE_FILE will be effective.<p>
<p><hr>
Note:	This must be set 
<I>before</I> LM_A_LICENSE_DEFAULT to be effective.<hr><p>
<h3>Default</h3>
<p>
<TT>LM_LICENSE_FILE</TT> environment variable enabled.<p>
<h4><B>See also</B></h4>
<ul><li><a href="#67269: 2head: 5.1.18 LM_A_LICENSE_FILE">Section E.10, `LM_A_LICENSE_FILE and LM_A_LICENSE_FILE_PTR,' on 
page 202</a><li><a href="#35936: 1head: 9.2 Locating the License File">Section 6.5, `Locating the License File,' on page 108</a></ul><a name="_IX_683"></a><a name="E.8"></a><h2>E.8  LM_A_EF_1, LM_A_EF_2, LM_A_EF_3, LM_A_EF_4, LM_A_EF_5</h2>
<h3>Type</h3>
<p>
int<p>
<p>
These five event flags are used on 
<a name="_IX_684"></a>VMS only. 
FLEXlm<I></I> client routines assign these 
event flags dynamically. You can reassign the event flags used by 
FLEXlm<I></I> by calling 
lc_set_attr() for the attributes 
<a name="LM_A_EF_1"></a><TT>LM_A_EF_1</TT>, 
<TT>LM_A_EF_2</TT>, 
<TT>LM_A_EF_3</TT>, 
<TT>LM_A_EF_4</TT>, or 
<TT>LM_A_EF_5</TT>. The only restriction is that flag #1 and flag #2 must be 
in the same event flag cluster. If you reset them, do it before calling any 
FLEXlm<I></I> 
routines. You can use 
<I>lib$get_ef</I> and 
<I>lib$free_ef</I> to assign event flag numbers, if 
desired.<p>
<h3>Default<I>:</I></h3>
<p>
Event flags assigned with 
<TT>lib$get_ef()</TT><p>
<a name="_IX_685"></a><a name="E.9"></a><h2>E.9  LM_A_ETHERNET_BOARDS</h2>
<h3>Type</h3>
<p>
(char **)<p>
<p>
This table of ethernet devices, if specified, will be searched before the standard 
FLEXlm<I></I> ethernet device table is searched. This can be used either to override the 
FLEXlm<I></I> device order, or to add new devices that are not built into the 
FLEXlm<I></I> table. 
This table is used for both 
<I>Ultrix</I> and 
<a name="_IX_686"></a>VMS systems but not for 
Windows and 
Windows NT systems. The table should be specified as a NULL-terminated array of 
character string pointers, as in the following example (this example is the standard 
<I><a name="_IX_687"></a>Ultrix</I> table):<p>
<pre>	char *our_ethernet_boards[] =</pre>
<pre>		"qe0", "de0", "se0", "ni0", "ln0", "xna0", "ne0", 0};</pre>
<pre>	lc_set_attr(LM_A_ETHERNET_BOARDS, our_ethernet_boards);</pre>
</ol></ul><p>
For 
VMS systems, be sure to include each interface in the table four times as xxa0:, 
xxa1:, xxa2:, and xxa3: (for device xx). The following example is the 
FLEXlm<I></I> 
standard ethernet device table for 
VMS:<p>
<pre>{"flexlm_hostid0", "flexlm_hostid1", "flexlm_hostid2", "flexlm_hostid3",</pre>
<pre>"_xqa0:", "_xqa1:", "_xqa2:", "_xqa3:",  /* DELQA, DEQNA, DESQA */</pre>
<pre>"_xea0:", "_xea1:", "_xea2:", "_xea3:",  /* DEUNA, DELUA */</pre>
<pre>"_esa0:", "_esa1:", "_esa2:", "_esa3:",  /* DESVA */</pre>
<pre>"_eta0:", "_eta1:", "_eta2:", "_eta3:",  /* DEBNA */</pre>
<pre>"_eza0:", "_eza1:", "_eza2:", "_eza3:",  /* uVAX 4000 */</pre>
<pre>"_exa0:", "_exa1:", "_exa2:", "_exa3:",  /* VAX 9000 */</pre>
<pre>"_ewa0:", "_ewa1:", "_ewa2:", "_ewa3:",  /* Alpha */</pre>
<pre>0 };</pre>
</ol></ul><p>
In order to update your daemon for a new set of ethernet addresses, you will need to 
put this call to 
lc_set_attr() into an initialization routine and set 
<I><a name="_IX_688"></a>ls_user_init1</I> to the 
name of your initialization routine, as in the following example:<p>
<p>
In any source module:<p>
<pre>	void daemon_init()</pre>
<pre>	{</pre>
<pre>		static char *new_board[] = {"new_board", 0};</pre>
<pre>			</pre>
<pre>			lc_set_attr(LM_A_ETHERNET_BOARDS, new_board);</pre>
<pre>	}</pre>
</ol></ul><p>
	In 
<TT>lsvendor.c</TT>:<p>
<pre>		extern void daemon_init();</pre>
<pre>		void (*ls_user_init1)() = daemon_init;</pre>
</ol></ul><p>
Then, modify the makefile for the daemon to include your module with 
daemon_init(), 
or put this module into the 
liblmgr_as.a archive. On 
<I>Ultrix</I> systems, 
<TT>CONFIG_DAEMON</TT> will automatically make the edit to 
<TT>lsvendor.c</TT> if you answer 
`daemon_init' to the daemon initialization (START) question.<p>
<h3>Default</h3>
<p>
Only standard 
FLEXlm<I></I> table searched.<p>
<a name="67269: 2head: 5.1.18 LM_A_LICENSE_FILE"></a><a name="E.10"></a><h2>E.10  LM_A_LICENSE_FILE and LM_A_LICENSE_FILE_PTR</h2>
<h3>Type</h3>
<p>
(char *)<p>
<p><hr>
Note:	It is recommended that 
<TT>LM_A_LICENSE_DEFAULT</TT> be used instead of 
<TT>LM_A_LICENSE_FILE and LM_A_LICENSE_FILE_PTR</TT>.<hr><p>
<h4>See also</h4>
<ul><li><a href="#12939: 1Head: 9.18 LM_A_LICENSE_DEFAULT">Section 5.15, `LM_A_LICENSE_DEFAULT,' on page 78</a><li><a href="#76398: 2head: 5.1.12 LM_A_DISABLE_ENV">Section E.7, `LM_A_DISABLE_ENV,' on page 200</a><li><a href="#35936: 1head: 9.2 Locating the License File">Section 6.5, `Locating the License File,' on page 108</a></ul><a name="E.11"></a><h2>E.11  LM_A_MAX_TIMEDIFF</h2>
<p>
Obsolete. This check is now automatically performed when needed.<p>
<a name="_IX_689"></a><a name="E.12"></a><h2>E.12  LM_A_NO_TRAFFIC_ENCRYPT</h2>
<h3>Type</h3>
<p>
short<p>
<p>
This field allows you to defeat the authentication of traffic that happens between client 
and server programs. If you set this parameter to a non-zero value, client-server 
communications will be unencrypted, as they were in V1.x 
FLEXlm<I></I>. DO NOT 
CHANGE THIS VALUE WITHOUT CONTACTING 
GLOBEtrotter Software<I></I> 
support.<p>
<h3>Default</h3>
<p>
0, Traffic is encrypted.<p>
<a name="_IX_690"></a><a name="E.13"></a><h2>E.13  LM_A_PERIODIC_CALL</h2>
<h3>Type</h3>
<p>
Pointer to a function returning int. Return value not used.<p>
<p>
This function, if specified, will be called each 
<TT><a name="_IX_691"></a>LM_A_PERIODIC_COUNT</TT><I> 
</I>times that 
lc_timer() is called. 
lc_timer() is called directly or automatically depending on the 
value of 
<TT><a name="_IX_692"></a>LM_A_CHECK_INTERVAL</TT>.<p>
<h3>Default</h3>
<p>
No periodic call.<p>
<h4>See also</h4>
<ul><li><a href="#53814: 2head: 5.1.3 LM_A_CHECK_INTERVAL, LM_A_TIMER_TYPE">Section 5.3, `LM_A_CHECK_INTERVAL,' on page 73</a><li><a href="#21737: 1Head: 4.22 lc_heartbeat">Section 4.22, `lc_heartbeat,' on page 46</a></ul><a name="_IX_693"></a><a name="E.14"></a><h2>E.14  LM_A_PERIODIC_COUNT</h2>
<h3>Type</h3>
<p>
int<p>
<p>
This is the count of how many times 
<a name="_IX_694"></a>lc_timer() must be called before the function 
specified by 
<TT>LM_A_PERIODIC_CALL</TT><I> 
</I>is called. 
lc_timer() is called directly or 
automatically depending on the value of 
<TT><a name="_IX_695"></a>LM_A_CHECK_INTERVAL</TT>.<p>
<h3>Default</h3>
<p>
0 (No 
<I>PERIODIC_CALL</I>).<p>
<h4>See also</h4>
<ul><li><a href="#53814: 2head: 5.1.3 LM_A_CHECK_INTERVAL, LM_A_TIMER_TYPE">Section 5.3, `LM_A_CHECK_INTERVAL,' on page 73</a><li><a href="#21737: 1Head: 4.22 lc_heartbeat">Section 4.22, `lc_heartbeat,' on page 46</a></ul><a name="_IX_696"></a><a name="E.15"></a><h2>E.15  LM_A_USE_START_DATE</h2>
<h3>Type</h3>
<p>
short<p>
<p>
This field allows you to use the start date that is built into the license file for each 
feature. If the current system date is earlier than the start date, then checkouts of the 
feature will be disabled. If set to a non-zero value, the start date will be used. 
<TT>LM_A_USE_START_DATE</TT> can only be turned off with 
lc_set_attr().<p>
<p><hr>
Note:	If you use your own authentication routine, you must either disable the use of the start 
date, or create an 
<a name="_IX_697"></a>license key which contains a valid start date. See the description of 
the 
<TT><a name="_IX_698"></a>LM_A_USER_CRYPT</TT> attribute.<hr><p>
<h3>Default</h3>
<p>
1, Use start date.<p>
<a name="37464: 2head: 5.1.34 LM_A_USER_CRYPT"></a><a name="_IX_699"></a><a name="E.16"></a><h2>E.16  LM_A_USER_CRYPT</h2>
<h3>Type</h3>
<p>
Pointer to a function returning (char *). Return value is the 
<a name="_IX_700"></a>license key.<p>
<p>
The function pointer crypt can be set to point to a vendor-supplied authentication 
routine to be used in place of the default routine.<p>
<h3>Default</h3>
<p>
FLEXlm<I></I> standard authentication routine.<p>
<p>
The 
<I>crypt</I> routine is called as follows:<p>
<pre>(*crypt)(job, conf, sdate, key);</pre>
</ol></ul><p>
<p>
<dl><dt>(LM_HANDLE *) 
<I>job</I><dd>FLEXlm<I></I> job.<dt>(<a name="_IX_701"></a>CONFIG *) 
<I>conf</I><dd>CONFIG structure pointer.<dt>(char *) 
<I>sdate</I><dd>4-byte encoded start date.<dt>(<a name="_IX_702"></a>VENDORCODE *) 
<I>key</I><dd>Pointer to the 1st argument to the 
<a name="_IX_703"></a><TT>LM_CODE</TT> 
macro in lm_code.h, where 
<I>code.data[0]</I> and 
<I>code.data[1]</I> have been XOR'd with 
<TT><a name="VENDOR_KEY5"></a>VENDOR_KEY5</TT>, so that the encryption seeds are 
as specified in lm_code.h</dl><p>
Because of the complexities of the current CONFIG format, we recommend the 
following procedure for setting a vendor-defined authentication routine:<p>
<ol><li>set LM_A_USER_CRYPT to your function, e.g., 
<I>our_crypt</I>().<li>our_crypt should do the following:<pre>	our_crypt(job, conf, sdate, key)
	{</pre>
<pre>	 char *lic_key;

		lc_set_attr(job, LM_A_USER_CRYPT, (LM_A_VAL_TYPE)0);
		lic_key = lc_crypt(job, conf, sdate, key);
		lc_set_attr(job, LM_A_USER_CRYPT,
			(LM_A_VAL_TYPE)our_crypt);</pre>
<pre>		/* modify the license-key */</pre>
<pre>		return (modified(lic_key));</pre>
<pre>	}</pre>
</ol></ul><p>
The example above first calls the standard authentication routine (lc_crypt()). Then 
our_encrypt() modifies the license key and returns the modified value. A simple, but 
useful way to modify the key is to turn it into a 32-bit integer and XOR it with a fixed 
number. If the license key contains an embedded start date, then you'll have to first 
remove the embedded start-date from the license key, perform the modification, and 
then re-insert the start-date into the license key.<p>
<p>
The returned string must be 12 (short with no license key), 16 (long with no embedded 
start-date) or 20 (long with start-date) characters long.<p>
<h4>See Also</h4>
<ul><li><a href="#33883: 2head: 3.4.8 lc_cryptstr">Section 4.10, `lc_cryptstr,' on page 36</a><li><a href="#34134: 2head: 7.4.24 ls_user_crypt">Section 8.3.28, `ls_user_crypt,' on page 133</a></ul><p><hr><a name="_IX"></a><h1>Index</h1><p>
<li><a href="#_IX_517">/dev/lan0</a>
<li><a href="#_IX_217"></a>
<li><a href="#_IX_408">@host:contacting license server</a>
<li><a href="#_IX_514">AIX</a>
<li><a href="#_IX_255">ANY:lc_gethostid</a>
<li><a href="#_IX_546">API:Industry standards</a>
<li><a href="#_IX_28">BINARY_KIT</a>
<li><a href="#_IX_458">checkin callback:in vendor daemon</a>
<li><a href="#_IX_456">checkin filter:in vendor daemon</a>
<li><a href="#_IX_462">checkout filter:in vendor daemon</a>
<li><a href="#_IX_452">chroot:and ls_do_checkroot</a>
<li><a href="#_IX_10">client:definition</a>
<li><a href="#_IX_499">Communications Transport (TCP vs. UDP)</a>
<li><a href="#_IX_504">COMM_TRANSPORT:UDP vs TCP</a>
<li><a href="#_IX_400">COMPONENTS:PACKAGE line syntax</a>
<li><a href="#_IX_401">COMPONENTS=</a>
<li><a href="#_IX_64">CONFIG:lc_auth_data</a>
<li><a href="#_IX_701">CONFIG</a>
<li><a href="#_IX_483">configuring FLEXlm:number of server nodes</a>
<li><a href="#_IX_477">CONFIG_DAEMON</a>
<li><a href="#_IX_350">daemon death:automatic reconnection</a>
<li><a href="#_IX_290">daemon death:detecting</a>
<li><a href="#_IX_11">daemon:definition</a>
<li><a href="#_IX_374">DAEMON:line syntax</a>
<li><a href="#_IX_510">Data General</a>
<li><a href="#_IX_554">Debug Log File:syntax</a>
<li><a href="#_IX_428">debug log file</a>
<li><a href="#_IX_488">Debugging hints</a>
<li><a href="#_IX_656">Decimal format licenses:limits</a>
<li><a href="#_IX_406">Decimal Format Licenses</a>
<li><a href="#_IX_117">decimal format:lc_convert</a>
<li><a href="#_IX_388">DEMO:Hostid on FEATURE line</a>
<li><a href="#_IX_256">DEMO:lc_getid_type</a>
<li><a href="#_IX_4">DISK_SERIAL_NUM</a>
<li><a href="#_IX_86">DISPLAY:dup_group</a>
<li><a href="#_IX_308">DisplayString</a>
<li><a href="#_IX_530">DLL</a>
<li><a href="#_IX_669">Domains:limits</a>
<li><a href="#_IX_541">Dongles:windows</a>
<li><a href="#_IX_94">Duplicate Grouping Mask</a>
<li><a href="#_IX_48">DUP_GROUP:and lingering licenses</a>
<li><a href="#_IX_699">encryption routine:user</a>
<li><a href="#_IX_476">ENCRYPTION_SEED</a>
<li><a href="#_IX_657">End-User Options File:limits</a>
<li><a href="#_IX_411">END_LICENSE</a>
<li><a href="#_IX_539">Ethernet Address:Windows</a>
<li><a href="#_IX_35">examples</a>
<li><a href="#_IX_72">exinstal.c:lc_check_key</a>
<li><a href="#_IX_123">exinstal.c:lc_convert</a>
<li><a href="#_IX_382">expiration date:FEATURE line</a>
<li><a href="#_IX_651">expiration date:limits</a>
<li><a href="#_IX_648">FEATURE Name length</a>
<li><a href="#_IX_379">feature name:FEATURE line</a>
<li><a href="#_IX_8">feature:defintion</a>
<li><a href="#_IX_649">FEATURE:limits</a>
<li><a href="#_IX_377">FEATURE:line syntax </a>
<li><a href="#_IX_210">FEATURESET</a>
<li><a href="#_IX_227">FEATURESET</a>
<li><a href="#_IX_230">FEATURESET</a>
<li><a href="#_IX_465">FEATURESET</a>
<li><a href="#_IX_497">FEATURESET</a>
<li><a href="#_IX_29">FLEXible API:example application</a>
<li><a href="#_IX_57">FLEXible API:function listing</a>
<li><a href="#_IX_25">FLEXible API:overview</a>
<li><a href="#_IX_5">FLEXible API</a>
<li><a href="#_IX_416">FLEXID</a>
<li><a href="#_IX_547">FLEXlm API</a>
<li><a href="#_IX_550">FLEXlm API</a>
<li><a href="#_IX_37">FLEXlm.po</a>
<li><a href="#_IX_505">FLEXLM_COMM_TRANSPORT</a>
<li><a href="#_IX_672">FLEXLM_COMM_TRANSPORT</a>
<li><a href="#_IX_681">FLEXLM_DIAGNOSTICS:LM_A_DIAGS_ENABLED</a>
<li><a href="#_IX_337">FORTRAN:and SIGALRM</a>
<li><a href="#_IX_309">gethostname:LM_A_DISPLAY_OVERRIDE</a>
<li><a href="#_IX_313">gethostname:LM_A_HOST_OVERRIDE</a>
<li><a href="#_IX_154">Heartbeats:lc_timer</a>
<li><a href="#_IX_36">Heartbeats:overview</a>
<li><a href="#_IX_511">Hewlett Packard</a>
<li><a href="#_IX_415">Host ID:determining with lmhostid</i></a>
<li><a href="#_IX_414">Host ID:on different machine types</a>
<li><a href="#_IX_85">HOST:dup_group</a>
<li><a href="#_IX_232">hostid:lc_gethostid</a>
<li><a href="#_IX_233">HOSTID:lc_gethostid</a>
<li><a href="#_IX_360">HOSTID:LM_A_VENDOR_ID_DECLARE</a>
<li><a href="#_IX_553">hostid:LSAPI</a>
<li><a href="#_IX_234">hostid</a>
<li><a href="#_IX_387">HOSTID=:FEATURE attribute</a>
<li><a href="#_IX_247">HOSTID_DISK_SERIAL_NUM</a>
<li><a href="#_IX_239">HOSTID_DISPLAY</a>
<li><a href="#_IX_236">HOSTID_ETHER</a>
<li><a href="#_IX_243">HOSTID_FLEXID1_KEY</a>
<li><a href="#_IX_244">HOSTID_FLEXID2_KEY</a>
<li><a href="#_IX_245">HOSTID_FLEXID3_KEY</a>
<li><a href="#_IX_246">HOSTID_FLEXID4_KEY</a>
<li><a href="#_IX_240">HOSTID_HOSTNAME</a>
<li><a href="#_IX_252">HOSTID_INTEL32</a>
<li><a href="#_IX_253">HOSTID_INTEL64</a>
<li><a href="#_IX_254">HOSTID_INTEL96</a>
<li><a href="#_IX_422">HOSTID_INTEL</a>
<li><a href="#_IX_248">HOSTID_INTERNET</a>
<li><a href="#_IX_235">HOSTID_LONG</a>
<li><a href="#_IX_249">HOSTID_SERNUM_ID</a>
<li><a href="#_IX_242">HOSTID_STRING</a>
<li><a href="#_IX_241">HOSTID_UNAME_LONG</a>
<li><a href="#_IX_238">HOSTID_USER</a>
<li><a href="#_IX_251">HOSTID_VENDOR</a>
<li><a href="#_IX_258">HOSTTYPE</a>
<li><a href="#_IX_512">IBM</a>
<li><a href="#_IX_391">ID=:FEATURE attribute</a>
<li><a href="#_IX_417">ID=:Hostid type</a>
<li><a href="#_IX_250">ID=</a>
<li><a href="#_IX_418">ID_STRING:Hostid type</a>
<li><a href="#_IX_378">INCREMENT:line syntax</a>
<li><a href="#_IX_467">INCREMENT:ls_use_all_feature_lines</a>
<li><a href="#_IX_543">Installation:Netware</a>
<li><a href="#_IX_421">Intel Pentium III+ Hostid</a>
<li><a href="#_IX_177">job:lc_new_job</a>
<li><a href="#_IX_42">LANG:Internationalization for Solaris</a>
<li><a href="#_IX_63">lc_auth_data</a>
<li><a href="#_IX_208">lc_baddate</a>
<li><a href="#_IX_45">lc_checkin:and lingering licenses</a>
<li><a href="#_IX_296">lc_checkin:LM_A_CHECKOUT_DATA\xd1 DUP_VENDOR</a>
<li><a href="#_IX_343">lc_checkin:LM_A_UDP_TIMEOUT</a>
<li><a href="#_IX_73">lc_checkin</a>
<li><a href="#_IX_302">lc_checkout:LM_A_CHECKOUT_FILTER</a>
<li><a href="#_IX_295">lc_checkout</a>
<li><a href="#_IX_78">lc_checkout</a>
<li><a href="#_IX_115">lc_check_key:lc_convert</a>
<li><a href="#_IX_67">lc_check_key</a>
<li><a href="#_IX_113">lc_chk_conf</a>
<li><a href="#_IX_209">lc_ck_feats</a>
<li><a href="#_IX_114">lc_convert</a>
<li><a href="#_IX_121">LC_CONVERT_TO_DECIMAL</a>
<li><a href="#_IX_120">LC_CONVERT_TO_READABLE</a>
<li><a href="#_IX_215">lc_copy_hostid</a>
<li><a href="#_IX_216">lc_crypt</a>
<li><a href="#_IX_124">lc_cryptstr</a>
<li><a href="#_IX_222">lc_disconn</a>
<li><a href="#_IX_223">lc_display</a>
<li><a href="#_IX_191">lc_errstring:lc_perror</a>
<li><a href="#_IX_133">lc_errstring</a>
<li><a href="#_IX_134">lc_errstring</a>
<li><a href="#_IX_135">lc_errstring</a>
<li><a href="#_IX_136">lc_expire_days</a>
<li><a href="#_IX_138">lc_feat_list</a>
<li><a href="#_IX_226">lc_feat_set</a>
<li><a href="#_IX_140">lc_first_job</a>
<li><a href="#_IX_62">lc_free_hostid():l_new_hostid</a>
<li><a href="#_IX_142">lc_free_hostid</a>
<li><a href="#_IX_532">lc_free_job:Windows</a>
<li><a href="#_IX_119">lc_free_mem:lc_convert</a>
<li><a href="#_IX_132">lc_free_mem:lc_cryptstr</a>
<li><a href="#_IX_146">lc_free_mem</a>
<li><a href="#_IX_143">lc_gethostid:lc_free_hostid</a>
<li><a href="#_IX_231">lc_gethostid</a>
<li><a href="#_IX_144">lc_getid_type:lc_free_hostid</a>
<li><a href="#_IX_287">lc_get_attr:lc_set_attr</a>
<li><a href="#_IX_53">lc_get_attr:multiple jobs</a>
<li><a href="#_IX_147">lc_get_attr</a>
<li><a href="#_IX_152">lc_get_config</a>
<li><a href="#_IX_228">lc_get_errno</a>
<li><a href="#_IX_229">lc_get_feats</a>
<li><a href="#_IX_153">lc_heartbeat</a>
<li><a href="#_IX_165">lc_hostid</a>
<li><a href="#_IX_224">lc_hostname</a>
<li><a href="#_IX_257">lc_hosttype</a>
<li><a href="#_IX_166">lc_idle</a>
<li><a href="#_IX_531">lc_init:windows</a>
<li><a href="#_IX_170">lc_init</a>
<li><a href="#_IX_259">lc_isadmin</a>
<li><a href="#_IX_263">lc_lic_where</a>
<li><a href="#_IX_171">lc_log</a>
<li><a href="#_IX_265">lc_master_list</a>
<li><a href="#_IX_145">lc_new_job:lc_free_job</a>
<li><a href="#_IX_51">lc_new_job:multiple jobs</a>
<li><a href="#_IX_173">lc_new_job</a>
<li><a href="#_IX_188">lc_next_conf</a>
<li><a href="#_IX_141">lc_next_job</a>
<li><a href="#_IX_345">lc_perror:LM_A_USER_EXITCALL</a>
<li><a href="#_IX_189">lc_perror</a>
<li><a href="#_IX_269">lc_remove</a>
<li><a href="#_IX_46">lc_set_attr:and lingering licenses</a>
<li><a href="#_IX_59">lc_set_attr:building your application</a>
<li><a href="#_IX_658">lc_set_attr:limits</a>
<li><a href="#_IX_285">lc_set_attr:listing of attributes</a>
<li><a href="#_IX_192">lc_set_attr</a>
<li><a href="#_IX_273">lc_shutdown</a>
<li><a href="#_IX_276">lc_status</a>
<li><a href="#_IX_493">lc_timer():debugging</a>
<li><a href="#_IX_694">lc_timer:LM_A_PERIODIC_COUNT</a>
<li><a href="#_IX_346">lc_timer:LM_A_USER_EXITCALL</a>
<li><a href="#_IX_352">lc_timer:LM_A_USER_RECONNECT</a>
<li><a href="#_IX_277">lc_timer</a>
<li><a href="#_IX_300">lc_userlist:LM_A_CHECKOUT_DATA\xd1 DUP_VENDOR</a>
<li><a href="#_IX_201">lc_userlist</a>
<li><a href="#_IX_225">lc_username</a>
<li><a href="#_IX_471">lc_vsend:ls_vendor_msg</a>
<li><a href="#_IX_204">lc_vsend</a>
<li><a href="#_IX_365">Lenient Licensing:REPORTLOG and OVERDRAFT</a>
<li><a href="#_IX_60">liblmgr.a:building your application</a>
<li><a href="#_IX_260">license administrator</a>
<li><a href="#_IX_348">license daemon:automatic reconnection</a>
<li><a href="#_IX_15">license daemon:definition</a>
<li><a href="#_IX_288">license daemon:detecting daemon death</a>
<li><a href="#_IX_647">License File Limits</a>
<li><a href="#_IX_20">license file list:definition</a>
<li><a href="#_IX_496">license file:combining license files from multiple vendors</a>
<li><a href="#_IX_19">license file:definition</a>
<li><a href="#_IX_405">license file:example</a>
<li><a href="#_IX_407">license file:location</a>
<li><a href="#_IX_443">license file:VMS default location</a>
<li><a href="#_IX_21">license key:definition</a>
<li><a href="#_IX_384">license key:FEATURE</a>
<li><a href="#_IX_386">license key:FEATURE</a>
<li><a href="#_IX_403">License key:FEATURESET</a>
<li><a href="#_IX_218">license key:lc_crypt</a>
<li><a href="#_IX_125">license key:lc_cryptstr</a>
<li><a href="#_IX_423">license key:length and start-date</a>
<li><a href="#_IX_404">license key:license file comments</a>
<li><a href="#_IX_371">license key:license file format</a>
<li><a href="#_IX_326">license key:LM_A_LKEY_LONG</a>
<li><a href="#_IX_700">license key:LM_A_USER_CRYPT</a>
<li><a href="#_IX_697">license key:LM_A_USE_START_DATE</a>
<li><a href="#_IX_559">license key:LM_BADCODE error</a>
<li><a href="#_IX_96">License key:LM_BADCODE</a>
<li><a href="#_IX_449">license key:ls_crypt_case_sensitive</a>
<li><a href="#_IX_413">license key:port@host</a>
<li><a href="#_IX_395">license key:SUPERSEDE</a>
<li><a href="#_IX_22">license server:definition</a>
<li><a href="#_IX_68">license-key:lc_check_key</a>
<li><a href="#_IX_665">license-key:limits</a>
<li><a href="#_IX_322">license-key:LM_LGEN_VER</a>
<li><a href="#_IX_653">license-key:start-date limits</a>
<li><a href="#_IX_9">license:definition</a>
<li><a href="#_IX_324">LINGER:LM_A_LINGER</a>
<li><a href="#_IX_43">Linger:overview</a>
<li><a href="#_IX_44">LINGER</a>
<li><a href="#_IX_436">lmadmin group:lmgrd</a>
<li><a href="#_IX_261">lmadmin group</a>
<li><a href="#_IX_426">lmadmin:and lmgrd</a>
<li><a href="#_IX_270">lmadmin:lc_remove</a>
<li><a href="#_IX_31">lmclient.c</a>
<li><a href="#_IX_58">lmclient.h:building your application</a>
<li><a href="#_IX_274">lmdown:lc_shutdown</a>
<li><a href="#_IX_429">lmdown:lmgrd -x lmdown</a>
<li><a href="#_IX_41">lmerrors.h:internationalization</a>
<li><a href="#_IX_30">lmflex.c</a>
<li><a href="#_IX_555">lmgrd log file</a>
<li><a href="#_IX_14">lmgrd:definition</a>
<li><a href="#_IX_38">lmgrd:internationalization for solaris</a>
<li><a href="#_IX_667">lmgrd:limits</a>
<li><a href="#_IX_424">lmgrd:syntax and use</a>
<li><a href="#_IX_439">lmrandom</a>
<li><a href="#_IX_430">lmremove:lmgrd -x lmremove</a>
<li><a href="#_IX_425">lmreread:and lmgrd</a>
<li><a href="#_IX_34">lmsimple.c</a>
<li><a href="#_IX_202">lmstat:lc_userlist</a>
<li><a href="#_IX_299">lmstat:LM_A_CHECKOUT_DATA\xd1 DUP_VENDOR</a>
<li><a href="#_IX_55">lmstrip:overview</a>
<li><a href="#_IX_527">lmswitch:VMS command</a>
<li><a href="#_IX_40">lmutil:Internationalization for Solaris</a>
<li><a href="#_IX_503">LM_A_ALLOW_SET_TRANSPORT</a>
<li><a href="#_IX_506">LM_A_ALLOW_SET_TRANSPORT</a>
<li><a href="#_IX_673">LM_A_ALT_ENCRYPTION</a>
<li><a href="#_IX_398">LM_A_CHECKOUTFILTER:use with VENDOR_STRING</a>
<li><a href="#_IX_301">LM_A_CHECKOUTFILTER</a>
<li><a href="#_IX_662">LM_A_CHECKOUT_DATA:limits</a>
<li><a href="#_IX_293">LM_A_CHECKOUT_DATA\xd1 DUP_VENDOR</a>
<li><a href="#_IX_278">LM_A_CHECK_INTERVAL:lc_timer</a>
<li><a href="#_IX_663">LM_A_CHECK_INTERVAL:limits</a>
<li><a href="#_IX_351">LM_A_CHECK_INTERVAL:LM_A_USER_RECONNECT</a>
<li><a href="#_IX_692">LM_A_CHECK_INTERVAL</a>
<li><a href="#_IX_695">LM_A_CHECK_INTERVAL</a>
<li><a href="#_IX_507">LM_A_COMM_TRANSPORT</a>
<li><a href="#_IX_674">LM_A_COMM_TRANSPORT</a>
<li><a href="#_IX_678">LM_A_CONN_TIMEOUT</a>
<li><a href="#_IX_385">LM_A_CRYPT_CASE_SENSITIVE</a>
<li><a href="#_IX_679">LM_A_CRYPT_CASE_SENSITIVE</a>
<li><a href="#_IX_680">LM_A_DIAGS_ENABLED</a>
<li><a href="#_IX_659">LM_A_DISPLAY_OVERRIDE:limits</a>
<li><a href="#_IX_304">LM_A_DISPLAY_OVERRIDE</a>
<li><a href="#_IX_683">LM_A_EF_1</a>
<li><a href="#_IX_685">LM_A_ETHERNET_BOARDS</a>
<li><a href="#_IX_310">LM_A_FLEXLOCK</a>
<li><a href="#_IX_311">LM_A_FLEXLOCK_INSTALL_ID</a>
<li><a href="#_IX_660">LM_A_HOSTNAME_OVERRIDE:limits</a>
<li><a href="#_IX_312">LM_A_HOST_OVERRIDE</a>
<li><a href="#_IX_314">LM_A_HOST_OVERRIDE</a>
<li><a href="#_IX_315">LM_A_HOST_OVERRIDE</a>
<li><a href="#_IX_316">LM_A_LF_LIST</a>
<li><a href="#_IX_317">LM_A_LICENSE_CASE_SENSITIVE</a>
<li><a href="#_IX_319">LM_A_LICENSE_DEFAULT</a>
<li><a href="#_IX_118">LM_A_LICENSE_FMT_VER:lc_convert</a>
<li><a href="#_IX_126">LM_A_LICENSE_FMT_VER:lc_cryptstr</a>
<li><a href="#_IX_321">LM_A_LICENSE_FMT_VER</a>
<li><a href="#_IX_323">LM_A_LINGER</a>
<li><a href="#_IX_47">LM_A_LINGER</a>
<li><a href="#_IX_325">LM_A_LKEY_LONG</a>
<li><a href="#_IX_327">LM_A_LKEY_LONG</a>
<li><a href="#_IX_328">LM_A_LKEY_LONG</a>
<li><a href="#_IX_689">LM_A_NO_TRAFFIC_ENCRYPT</a>
<li><a href="#_IX_329">LM_A_PC_PROMPT_FOR_FILE</a>
<li><a href="#_IX_330">LM_A_PC_PROMPT_FOR_FILE</a>
<li><a href="#_IX_690">LM_A_PERIODIC_CALL</a>
<li><a href="#_IX_691">LM_A_PERIODIC_COUNT</a>
<li><a href="#_IX_693">LM_A_PERIODIC_COUNT</a>
<li><a href="#_IX_157">LM_A_RECONNECT_DONE:lc_timer</a>
<li><a href="#_IX_158">LM_A_RECONNECT_DONE:lc_timer</a>
<li><a href="#_IX_159">LM_A_RECONNECT_DONE:lc_timer</a>
<li><a href="#_IX_331">LM_A_RETRY_CHECKOUT</a>
<li><a href="#_IX_156">LM_A_RETRY_COUNT:lc_timer</a>
<li><a href="#_IX_332">LM_A_RETRY_COUNT</a>
<li><a href="#_IX_279">LM_A_RETRY_INTERVAL:lc_timer</a>
<li><a href="#_IX_333">LM_A_RETRY_INTERVAL</a>
<li><a href="#_IX_362">LM_A_REVISION</a>
<li><a href="#_IX_334">LM_A_SETITIMER</a>
<li><a href="#_IX_335">LM_A_SIGNAL</a>
<li><a href="#_IX_338">LM_A_SIGNAL</a>
<li><a href="#_IX_162">LM_A_TCP_TIMEOUT:lc_timer</a>
<li><a href="#_IX_283">LM_A_TCP_TIMEOUT:lc_timer</a>
<li><a href="#_IX_339">LM_A_TCP_TIMEOUT</a>
<li><a href="#_IX_76">LM_A_UDP_TIMEOUT:lc_checkin</a>
<li><a href="#_IX_169">LM_A_UDP_TIMEOUT:lc_idle</a>
<li><a href="#_IX_161">LM_A_UDP_TIMEOUT:lc_timer</a>
<li><a href="#_IX_282">LM_A_UDP_TIMEOUT:lc_timer</a>
<li><a href="#_IX_341">LM_A_UDP_TIMEOUT</a>
<li><a href="#_IX_509">LM_A_UDP_TIMEOUT</a>
<li><a href="#_IX_661">LM_A_USERNAME:limits</a>
<li><a href="#_IX_473">LM_A_USER_CRYPT:ls_user_crypt</a>
<li><a href="#_IX_698">LM_A_USER_CRYPT</a>
<li><a href="#_IX_344">LM_A_USER_EXITCALL</a>
<li><a href="#_IX_347">LM_A_USER_OVERRIDE</a>
<li><a href="#_IX_155">LM_A_USER_RECONNECT:lc_timer</a>
<li><a href="#_IX_353">LM_A_USER_RECONNECT_DONE</a>
<li><a href="#_IX_696">LM_A_USE_START_DATE</a>
<li><a href="#_IX_193">LM_A_VAL_TYPE:lc_set_attr</a>
<li><a href="#_IX_286">LM_A_VAL_TYPE</a>
<li><a href="#_IX_151">LM_A_VD_FEATURE_INFO:lc_get_attyr</a>
<li><a href="#_IX_355">LM_A_VD_FEATURE_INFO</a>
<li><a href="#_IX_150">LM_A_VD_GENERIC_INFO:lc_get_attr</a>
<li><a href="#_IX_354">LM_A_VD_GENERIC_INFO</a>
<li><a href="#_IX_361">LM_A_VENDOR_GETHOSTID</a>
<li><a href="#_IX_359">LM_A_VENDOR_ID_DECLARE</a>
<li><a href="#_IX_363">LM_A_WINDOWS_MODULE_HANDLE</a>
<li><a href="#_IX_612">LM_BADCHECKSUM</a>
<li><a href="#_IX_495">LM_BADCODE:debugging hints</a>
<li><a href="#_IX_95">LM_BADCODE:lc_checkout</a>
<li><a href="#_IX_69">LM_BADCODE:lc_check_key</a>
<li><a href="#_IX_567">LM_BADCODE</a>
<li><a href="#_IX_571">LM_BADCOMM</a>
<li><a href="#_IX_570">LM_BADDATE</a>
<li><a href="#_IX_97">LM_BADFEATPARAM:lc_checkout</a>
<li><a href="#_IX_591">LM_BADFEATPARAM</a>
<li><a href="#_IX_213">LM_BADFEATSET</a>
<li><a href="#_IX_608">LM_BADFEATSET</a>
<li><a href="#_IX_268">LM_BADFILE</a>
<li><a href="#_IX_561">LM_BADFILE</a>
<li><a href="#_IX_98">LM_BADHANDSHAKE:lc_checkout</a>
<li><a href="#_IX_588">LM_BADHANDSHAKE</a>
<li><a href="#_IX_573">LM_BADHOST</a>
<li><a href="#_IX_178">LM_BADKEYDATA</a>
<li><a href="#_IX_598">LM_BADKEYDATA</a>
<li><a href="#_IX_70">LM_BADPARAM:lc_check_key</a>
<li><a href="#_IX_122">LM_BADPARAM:lc_convert</a>
<li><a href="#_IX_596">LM_BADPARAM</a>
<li><a href="#_IX_99">LM_BADPARAM</a>
<li><a href="#_IX_601">LM_BADPLATFORM</a>
<li><a href="#_IX_100">LM_BADSYSDATE:lc_checkout</a>
<li><a href="#_IX_628">LM_BADSYSDATE</a>
<li><a href="#_IX_179">LM_BADVENDORDATA</a>
<li><a href="#_IX_617">LM_BADVENDORDATA</a>
<li><a href="#_IX_101">LM_BAD_VERSION:lc_checkout</a>
<li><a href="#_IX_102">LM_BUSYNEWSERV</a>
<li><a href="#_IX_582">LM_BUSYNEWSERV</a>
<li><a href="#_IX_212">LM_CANTCOMPUTEFEATSET</a>
<li><a href="#_IX_609">LM_CANTCOMPUTEFEATSET</a>
<li><a href="#_IX_103">LM_CANTCONNECT:lc_checkout</a>
<li><a href="#_IX_574">LM_CANTCONNECT</a>
<li><a href="#_IX_586">LM_CANTFINDETHER</a>
<li><a href="#_IX_594">LM_CANTMALLOC</a>
<li><a href="#_IX_575">LM_CANTREAD</a>
<li><a href="#_IX_576">LM_CANTWRITE</a>
<li><a href="#_IX_639">LM_CANT_DECIMAL</a>
<li><a href="#_IX_581">LM_CHECKINBAD</a>
<li><a href="#_IX_606">LM_CHECKOUTFILTERED</a>
<li><a href="#_IX_77">LM_CI_ALL_FEATURES</a>
<li><a href="#_IX_589">LM_CLOCKBAD</a>
<li><a href="#_IX_478">lm_code.h</a>
<li><a href="#_IX_703">LM_CODE</a>
<li><a href="#_IX_66">LM_CO_LOCALTEST:lc_auth_data</a>
<li><a href="#_IX_83">LM_CO_LOCALTEST</a>
<li><a href="#_IX_195">LM_CO_NOWAIT:lc_status</a>
<li><a href="#_IX_80">LM_CO_NOWAIT</a>
<li><a href="#_IX_197">LM_CO_QUEUE:lc_status</a>
<li><a href="#_IX_82">LM_CO_QUEUE</a>
<li><a href="#_IX_196">LM_CO_WAIT:lc_status</a>
<li><a href="#_IX_79">LM_CO_WAIT</a>
<li><a href="#_IX_81">LM_CO_WAIT</a>
<li><a href="#_IX_131">LM_CRYPT_DECIMAL:lc_cryptstr</a>
<li><a href="#_IX_129">LM_CRYPT_FORCE</a>
<li><a href="#_IX_130">LM_CRYPT_IGNORE_FEATNAME_ERRS</a>
<li><a href="#_IX_128">LM_CRYPT_ONLY</a>
<li><a href="#_IX_602">LM_DATE_TOOBIG</a>
<li><a href="#_IX_180">LM_DEFAULT_SEEDS</a>
<li><a href="#_IX_632">LM_DEFAULT_SEEDS</a>
<li><a href="#_IX_91">LM_DUP_DISP</a>
<li><a href="#_IX_90">LM_DUP_HOST</a>
<li><a href="#_IX_88">LM_DUP_NONE</a>
<li><a href="#_IX_89">LM_DUP_USER</a>
<li><a href="#_IX_294">LM_DUP_VENDOR:LM_A_CHECKOUT_DATA</a>
<li><a href="#_IX_92">LM_DUP_VENDOR</a>
<li><a href="#_IX_621">LM_ENDPATH</a>
<li><a href="#_IX_603">LM_EXPIREDKEYS</a>
<li><a href="#_IX_182">LM_EXPIRED_KEYS</a>
<li><a href="#_IX_592">LM_FEATEXCLUDE</a>
<li><a href="#_IX_593">LM_FEATNOTINCLUDE</a>
<li><a href="#_IX_199">LM_FEATQUEUE:lc_status</a>
<li><a href="#_IX_104">LM_FEATQUEUE</a>
<li><a href="#_IX_590">LM_FEATQUEUE</a>
<li><a href="#_IX_646">LM_FLEXLOCK2CKOUT</a>
<li><a href="#_IX_105">LM_FUNCNOTAVAIL</a>
<li><a href="#_IX_214">LM_FUNCNOTAVAIL</a>
<li><a href="#_IX_599">LM_FUNCNOTAVAIL</a>
<li><a href="#_IX_71">LM_FUTURE_FILE:lc_check_key</a>
<li><a href="#_IX_631">LM_FUTURE_FILE</a>
<li><a href="#_IX_637">LM_HOSTDOWN</a>
<li><a href="#_IX_203">lm_isres</a>
<li><a href="#_IX_181">LM_KEY_NO_DATA</a>
<li><a href="#_IX_183">LM_KEY_NO_DATA</a>
<li><a href="#_IX_635">LM_LGEN_VER</a>
<li><a href="#_IX_184">LM_LIBRARYMISMATCH</a>
<li><a href="#_IX_618">LM_LIBRARYMISMATCH</a>
<li><a href="#_IX_264">LM_LICENSE_FILE:lc_lic_where</a>
<li><a href="#_IX_498">LM_LICENSE_FILE:license-file list</a>
<li><a href="#_IX_671">LM_LICENSE_FILE:limits</a>
<li><a href="#_IX_431">LM_LICENSE_FILE:lmgrd</a>
<li><a href="#_IX_682">LM_LICENSE_FILE:LM_A_DISABLE_ENV</a>
<li><a href="#_IX_320">LM_LICENSE_FILE:LM_A_LICENSE_DEFAULT</a>
<li><a href="#_IX_52">LM_LICENSE_FILE:multiple jobs</a>
<li><a href="#_IX_487">LM_LICENSE_FILE:redundant servers via</a>
<li><a href="#_IX_303">LM_LOCALFILTER:LM_A_CHECKOUT_FILTER</a>
<li><a href="#_IX_107">LM_LOCALFILTER</a>
<li><a href="#_IX_620">LM_LOCALFILTER</a>
<li><a href="#_IX_172">LM_LOG_MAX_LEN</a>
<li><a href="#_IX_569">LM_LONGGONE</a>
<li><a href="#_IX_627">LM_MAXLIMIT</a>
<li><a href="#_IX_108">LM_MAXUSERS</a>
<li><a href="#_IX_563">LM_MAXUSERS</a>
<li><a href="#_IX_200">LM_NEVERCHECKOUT</a>
<li><a href="#_IX_595">LM_NEVERCHECKOUT</a>
<li><a href="#_IX_174">lm_new.o</a>
<li><a href="#_IX_175">lm_new.obj</a>
<li><a href="#_IX_356">LM_NOADMINAPI:LM_A_VD_*_INFO</a>
<li><a href="#_IX_149">LM_NOADMINAPI</a>
<li><a href="#_IX_622">LM_NOADMINAPI</a>
<li><a href="#_IX_600">LM_NOCLOCKCHECK</a>
<li><a href="#_IX_560">LM_NOCONFFILE</a>
<li><a href="#_IX_643">LM_NODONGLE</a>
<li><a href="#_IX_645">LM_NODONGLEDRIVER</a>
<li><a href="#_IX_211">LM_NOFEATSET</a>
<li><a href="#_IX_607">LM_NOFEATSET</a>
<li><a href="#_IX_65">LM_NOFEATURE:lc_auth_data</a>
<li><a href="#_IX_106">LM_NOFEATURE</a>
<li><a href="#_IX_109">LM_NOFEATURE</a>
<li><a href="#_IX_137">LM_NOFEATURE</a>
<li><a href="#_IX_139">LM_NOFEATURE</a>
<li><a href="#_IX_564">LM_NOFEATURE</a>
<li><a href="#_IX_207">LM_NOFILEVSEND</a>
<li><a href="#_IX_604">LM_NOFLEXLMINIT</a>
<li><a href="#_IX_597">LM_NOKEYDATA</a>
<li><a href="#_IX_186">LM_NONETWORK</a>
<li><a href="#_IX_614">LM_NONETWORK</a>
<li><a href="#_IX_587">LM_NOREADLIC</a>
<li><a href="#_IX_644">LM_NORESLINK</a>
<li><a href="#_IX_625">LM_NOSERVCAP</a>
<li><a href="#_IX_562">LM_NOSERVER</a>
<li><a href="#_IX_565">LM_NOSERVICE</a>
<li><a href="#_IX_605">LM_NOSERVRESP</a>
<li><a href="#_IX_110">LM_NOSERVSUPP</a>
<li><a href="#_IX_577">LM_NOSERVSUPP</a>
<li><a href="#_IX_566">LM_NOSOCKET</a>
<li><a href="#_IX_148">LM_NOSUCHATTR:lc_get_attr</a>
<li><a href="#_IX_194">LM_NOSUCHATTR</a>
<li><a href="#_IX_271">LM_NOTLICADMIN</a>
<li><a href="#_IX_275">LM_NOTLICADMIN</a>
<li><a href="#_IX_615">LM_NOTLICADMIN</a>
<li><a href="#_IX_568">LM_NOTTHISHOST</a>
<li><a href="#_IX_636">LM_NOT_THIS_HOST</a>
<li><a href="#_IX_267">LM_NO_SERVER_IN_FILE</a>
<li><a href="#_IX_572">LM_NO_SERVER_IN_FILE</a>
<li><a href="#_IX_626">LM_OBJECTUSED</a>
<li><a href="#_IX_185">LM_OLDVENDORDATA</a>
<li><a href="#_IX_187">LM_OLDVENDORDATA</a>
<li><a href="#_IX_619">LM_OLDVENDORDATA</a>
<li><a href="#_IX_111">LM_OLDVER</a>
<li><a href="#_IX_580">LM_OLDVER</a>
<li><a href="#_IX_629">LM_PLATNOTLIC</a>
<li><a href="#_IX_634">LM_POOL</a>
<li><a href="#_IX_272">LM_REMOVETOOSOON</a>
<li><a href="#_IX_616">LM_REMOVETOOSOON</a>
<li><a href="#_IX_640">LM_REMOVE_LINGER</a>
<li><a href="#_IX_641">LM_RESVFOROTHERS</a>
<li><a href="#_IX_578">LM_SELECTERR</a>
<li><a href="#_IX_112">LM_SERVBUSY</a>
<li><a href="#_IX_579">LM_SERVBUSY</a>
<li><a href="#_IX_266">LM_SERVER:lc_master_list</a>
<li><a href="#_IX_642">LM_SERVER_MAXED_OUT</a>
<li><a href="#_IX_633">LM_SERVER_REMOVED</a>
<li><a href="#_IX_584">LM_SERVLONGGONE</a>
<li><a href="#_IX_613">LM_SERVNOREADLIC</a>
<li><a href="#_IX_623">LM_SERVOLDVER</a>
<li><a href="#_IX_611">LM_SETSOCKFAIL</a>
<li><a href="#_IX_610">LM_SOCKETFAIL</a>
<li><a href="#_IX_675">LM_TCP</a>
<li><a href="#_IX_585">LM_TOOMANY</a>
<li><a href="#_IX_676">LM_UDP</a>
<li><a href="#_IX_198">LM_USERSQUEUED:lc_status</a>
<li><a href="#_IX_583">LM_USERSQUEUED</a>
<li><a href="#_IX_624">LM_USER_BASED</a>
<li><a href="#_IX_638">LM_VENDOR_DOWN</a>
<li><a href="#_IX_318">LM_VER_BEHAVIOR:LM_A_LICENSE_CASE_SENSITIVE</a>
<li><a href="#_IX_556">Log File</a>
<li><a href="#_IX_427">logfile:lmgrd debug logfile</a>
<li><a href="#_IX_549">LSAPI</a>
<li><a href="#_IX_552">LSAPI</a>
<li><a href="#_IX_164">lsvendor.c:lc_timer</a>
<li><a href="#_IX_205">lsvendor.c:lc_vsend</a>
<li><a href="#_IX_438">lsvendor.c</a>
<li><a href="#_IX_442">lsvendor.c</a>
<li><a href="#_IX_480">ls_attr.h</a>
<li><a href="#_IX_444">ls_compare_vendor_on_increment</a>
<li><a href="#_IX_445">ls_compare_vendor_on_upgrade</a>
<li><a href="#_IX_446">ls_conn_timeout</a>
<li><a href="#_IX_448">ls_crypt_case_sensitive</a>
<li><a href="#_IX_450">ls_daemon_periodic</a>
<li><a href="#_IX_451">ls_do_checkroot</a>
<li><a href="#_IX_453">ls_dump_send_data</a>
<li><a href="#_IX_454">ls_enforce_startdate</a>
<li><a href="#_IX_479">ls_get_attr</a>
<li><a href="#_IX_457">ls_incallback</a>
<li><a href="#_IX_455">ls_infilter</a>
<li><a href="#_IX_163">ls_minimum_user_timeout:lc_timer</a>
<li><a href="#_IX_284">ls_minimum_user_timeout:lc_timer</a>
<li><a href="#_IX_461">ls_outfilter</a>
<li><a href="#_IX_460">ls_read_wait</a>
<li><a href="#_IX_298">ls_show_vendor_def</a>
<li><a href="#_IX_463">ls_show_vendor_def</a>
<li><a href="#_IX_464">ls_tell_startdate</a>
<li><a href="#_IX_472">ls_user_crypt</a>
<li><a href="#_IX_688">ls_user_init1:LM_A_ETHERNET_BOARDS</a>
<li><a href="#_IX_469">ls_user_init1</a>
<li><a href="#_IX_470">ls_user_init2</a>
<li><a href="#_IX_474">ls_user_lockfile</a>
<li><a href="#_IX_466">ls_use_all_feature_lines</a>
<li><a href="#_IX_206">ls_vendor_msg:lc_vsend</a>
<li><a href="#_IX_219">l_extract_date:lc_crypt</a>
<li><a href="#_IX_176">l_n36_buf</a>
<li><a href="#_IX_61">l_new_hostid</a>
<li><a href="#_IX_368">MAX_OVERDRAFT</a>
<li><a href="#_IX_297">MAX_VENDOR_CHECKOUT_DATA\xd1 DUP_VENDOR</a>
<li><a href="#_IX_50">Multiple Jobs</a>
<li><a href="#_IX_516">NCR</a>
<li><a href="#_IX_542">Netware NLM</a>
<li><a href="#_IX_544">Netware Server</a>
<li><a href="#_IX_485">Netware: no redundant support</a>
<li><a href="#_IX_433">Netware:lmgrd</a>
<li><a href="#_IX_434">Netware:starting vendor daemon</a>
<li><a href="#_IX_383">number of licenses:FEATURE line</a>
<li><a href="#_IX_1">OpenVMS:hostid</a>
<li><a href="#_IX_2">OpenVMS:hostid</a>
<li><a href="#_IX_402">OPTIONS=SUITE</a>
<li><a href="#_IX_367">OVERDRAFT:and Lenient Licensing</a>
<li><a href="#_IX_357">OVERDRAFT:detecting with SUITEs</a>
<li><a href="#_IX_654">OVERDRAFT:limits</a>
<li><a href="#_IX_364">PACKAGE:and Demo licensing</a>
<li><a href="#_IX_490">pclose():debugging</a>
<li><a href="#_IX_518">Platform-Specific Notes:SGI</a>
<li><a href="#_IX_524">Platform-Specific Notes:VAX/VMS</a>
<li><a href="#_IX_389">PLATFORMS=:FEATURE attribute</a>
<li><a href="#_IX_630">PLATFORMS=</a>
<li><a href="#_IX_370">port address:allowed license file changes</a>
<li><a href="#_IX_412">port@host:and redundant servers</a>
<li><a href="#_IX_409">port@host:contacting license server</a>
<li><a href="#_IX_540">Quick-Win</a>
<li><a href="#_IX_447">redundant servers:connection timeout</a>
<li><a href="#_IX_49">redundant servers:multiple jobs</a>
<li><a href="#_IX_481">redundant servers</a>
<li><a href="#_IX_366">REPORTLOG:and Lenient Licensing</a>
<li><a href="#_IX_513">RS/6000</a>
<li><a href="#_IX_515">RS/6000</a>
<li><a href="#_IX_419">SCO:hostid</a>
<li><a href="#_IX_521">SCO</a>
<li><a href="#_IX_536">SDK standard callback routines</a>
<li><a href="#_IX_54">security guidelines</a>
<li><a href="#_IX_16">server node:definition</a>
<li><a href="#_IX_482">server nodes:deciding number of</a>
<li><a href="#_IX_17">server nodes:definition</a>
<li><a href="#_IX_18">server nodes:multiple</a>
<li><a href="#_IX_369">SERVER:allowed license file changes</a>
<li><a href="#_IX_372">SERVER:line syntax</a>
<li><a href="#_IX_486">SERVER:redundant servers</a>
<li><a href="#_IX_336">setitimer:LM_A_SETITIMER</a>
<li><a href="#_IX_520">sgi64</a>
<li><a href="#_IX_519">SGI</a>
<li><a href="#_IX_492">SIGALRM:debugging</a>
<li><a href="#_IX_291">SIGALRM</a>
<li><a href="#_IX_292">SIGALRM</a>
<li><a href="#_IX_494">SIGPIPE:debugging</a>
<li><a href="#_IX_33">Simple API:example application</a>
<li><a href="#_IX_24">Simple API:overview</a>
<li><a href="#_IX_7">Simple API</a>
<li><a href="#_IX_93">SITE LICENSE:dup_group</a>
<li><a href="#_IX_489">sleep():debugging</a>
<li><a href="#_IX_390">SN=:FEATURE attribute</a>
<li><a href="#_IX_548">Software License Working Group API</a>
<li><a href="#_IX_551">Software License Working Group</a>
<li><a href="#_IX_522">Solaris</a>
<li><a href="#_IX_27">Source:Installation</a>
<li><a href="#_IX_545">SPX/IPX</a>
<li><a href="#_IX_652">start-date:limits</a>
<li><a href="#_IX_392">START=:FEATURE attribute</a>
<li><a href="#_IX_410">START_LICENSE</a>
<li><a href="#_IX_668">Sub-nets:limits</a>
<li><a href="#_IX_358">SUITE:detecting OVERDRAFT in</a>
<li><a href="#_IX_393">SUITE_DUP_GROUP:FEATURE attribute</a>
<li><a href="#_IX_394">SUPERSEDE:FEATURE attribute</a>
<li><a href="#_IX_523">SVR4</a>
<li><a href="#_IX_491">system():debugging</a>
<li><a href="#_IX_501">TCP:communications transport</a>
<li><a href="#_IX_74">TCP:lc_checkin</a>
<li><a href="#_IX_340">TCP:LM_A_TCP_TIMEOUT</a>
<li><a href="#_IX_116">this_host:lc_convert</a>
<li><a href="#_IX_537">Time Zone (Windows)</a>
<li><a href="#_IX_459">timeout value:setting</a>
<li><a href="#_IX_167">TIMEOUT:lc_idle</a>
<li><a href="#_IX_160">TIMEOUT:lc_timer</a>
<li><a href="#_IX_281">TIMEOUT:lc_timer</a>
<li><a href="#_IX_502">TRANSPORT:UDP vs TCP</a>
<li><a href="#_IX_32">Trivial API:example application</a>
<li><a href="#_IX_23">Trivial API:overview</a>
<li><a href="#_IX_6">Trivial API</a>
<li><a href="#_IX_538">TZ environment variable</a>
<li><a href="#_IX_508">UDP:communications transport</a>
<li><a href="#_IX_75">UDP:lc_checkin</a>
<li><a href="#_IX_168">UDP:lc_idle</a>
<li><a href="#_IX_280">UDP:lc_timer</a>
<li><a href="#_IX_342">UDP</a>
<li><a href="#_IX_687">Ultrix</a>
<li><a href="#_IX_56">Unix:lmstrip and Unix libraries</a>
<li><a href="#_IX_468">UPGRADE:ls_use_all_feature_lines</a>
<li><a href="#_IX_399">UPGRADE:syntax</a>
<li><a href="#_IX_84">USER:dup_group</a>
<li><a href="#_IX_396">USER_BASED:FEATURE attribute</a>
<li><a href="#_IX_655">USER_BASED:limits</a>
<li><a href="#_IX_237">VAX:ethernet hostid</a>
<li><a href="#_IX_557">vendor daemon log file</a>
<li><a href="#_IX_349">vendor daemon:automatic reconnection</a>
<li><a href="#_IX_441">vendor daemon:building</a>
<li><a href="#_IX_437">Vendor Daemon:configuring</a>
<li><a href="#_IX_12">vendor daemon:definition</a>
<li><a href="#_IX_13">vendor daemon:definition</a>
<li><a href="#_IX_289">vendor daemon:detecting daemon death</a>
<li><a href="#_IX_39">vendor daemon:internationalization for Solaris</a>
<li><a href="#_IX_666">Vendor Daemon:limits</a>
<li><a href="#_IX_664">Vendor-defined hostid:limits</a>
<li><a href="#_IX_420">Vendor-defined hostid</a>
<li><a href="#_IX_558">VENDOR:debug log file</a>
<li><a href="#_IX_87">VENDOR:dup_group</a>
<li><a href="#_IX_380">vendor:FEATURE line</a>
<li><a href="#_IX_373">VENDOR:line syntax</a>
<li><a href="#_IX_221">VENDORCODE:lc_crypt</a>
<li><a href="#_IX_702">VENDORCODE</a>
<li><a href="#_IX_220">VENDOR_KEY5:lc_crypt</a>
<li><a href="#_IX_127">VENDOR_KEY5:lc_cryptstr</a>
<li><a href="#_IX_475">VENDOR_KEY:and ENCRYPTION_SEEDs</a>
<li><a href="#_IX_397">VENDOR_STRING:FEATURE attribute</a>
<li><a href="#_IX_381">version:FEATURE line</a>
<li><a href="#_IX_650">Version:limits</a>
<li><a href="#_IX_526">VMS FLEXlm</a>
<li><a href="#_IX_376">VMS:and VENDOR line</a>
<li><a href="#_IX_440">VMS:building vendor daemon</a>
<li><a href="#_IX_500">VMS:communications transport</a>
<li><a href="#_IX_26">VMS:Installation</a>
<li><a href="#_IX_262">VMS:lc_isadmin</a>
<li><a href="#_IX_432">VMS:lmgrd</a>
<li><a href="#_IX_484">VMS:redundant servers</a>
<li><a href="#_IX_525">VMS</a>
<li><a href="#_IX_677">VMS</a>
<li><a href="#_IX_684">VMS</a>
<li><a href="#_IX_686">VMS</a>
<li><a href="#_IX_670">Wide-Area Networks:limits</a>
<li><a href="#_IX_375">Windows NT:and VENDOR line</a>
<li><a href="#_IX_435">Windows NT:lmgrd</a>
<li><a href="#_IX_529">Windows NT</a>
<li><a href="#_IX_528">Windows:FLEXlm differences</a>
<li><a href="#_IX_3">Windows:hostids</a>
<li><a href="#_IX_190">Windows:lc_perror</a>
<li><a href="#_IX_535">WinSock</a>
<li><a href="#_IX_534">WSACleanup</a>
<li><a href="#_IX_533">WSAStartup</a>
<li><a href="#_IX_305">X-Display name</a>
<li><a href="#_IX_306">XOpenDisplay</a>
<li><a href="#_IX_307">XtAppInitialize:LM_A_DISPLAY_OVERRIDE</a>
</body></html>
